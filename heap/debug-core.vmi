((call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/exceptions.scm" . 6145))
 (call
   (push.const . syntax)
   (push.const . core.exceptions\x27;guard)
   (push.const
     (else)
     ("../stdlib/core/exceptions.scm" . 22533)
     ((_ (var clause ... (else e1 e2 ...)) b1 b2 ...)
      ((call/cc
         (lambda (guard-k)
           (with-exception-handler
             (lambda (condition)
               ((call/cc
                  (lambda (handler-k)
                    (guard-k
                      (lambda () (let ((var condition)) (cond clause ... (else e1 e2 ...)))))))))
             (lambda ()
               (call-with-values
                 (lambda () b1 b2 ...)
                 (lambda args (guard-k (lambda () (apply values args))))))))))
      ((b2 . 1) (b1 . 0) (e2 . 1) (e1 . 0) (clause . 1) (var . 0))
      (values
        apply
        args
        call-with-values
        else
        cond
        let
        handler-k
        condition
        with-exception-handler
        guard-k
        lambda
        call/cc))
     ((_ (var clause ...) b1 b2 ...)
      ((call/cc
         (lambda (guard-k)
           (with-exception-handler
             (lambda (condition)
               ((call/cc
                  (lambda (handler-k)
                    (guard-k
                      (lambda ()
                        (let ((var condition))
                          (cond clause
                                ...
                                (else (handler-k (lambda () (raise-continuable condition))))))))))))
             (lambda ()
               (call-with-values
                 (lambda () b1 b2 ...)
                 (lambda args (guard-k (lambda () (apply values args))))))))))
      ((b2 . 1) (b1 . 0) (clause . 1) (var . 0))
      (values
        apply
        args
        call-with-values
        raise-continuable
        else
        cond
        let
        handler-k
        condition
        with-exception-handler
        guard-k
        lambda
        call/cc)))
   (push.const
     (with-exception-handler import . \x2E;with-exception-handler)
     (lambda import . \x2E;lambda)
     (call-with-values import . \x2E;call-with-values)
     (cond import . \x2E;cond)
     (raise-continuable import . \x2E;raise-continuable)
     (var unbound)
     (else import . \x2E;else)
     (_ import . \x2E;_)
     (condition import . \x2E;condition)
     (let import . \x2E;let)
     (... import . \x2E;...)
     (guard-k unbound)
     (b1 unbound)
     (e1 unbound)
     (guard import . core.exceptions\x27;guard)
     (b2 unbound)
     (apply import . \x2E;apply)
     (clause unbound)
     (values import . \x2E;values)
     (e2 unbound)
     (call/cc import . \x2E;call/cc)
     (handler-k unbound)
     (args unbound))
   (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/exceptions.scm" . 6145))
 (push.const . core.exceptions)
 (push.const . #f)
 (push.const
   (with-exception-handler import . \x2E;with-exception-handler)
   (guard import . core.exceptions\x27;guard)
   (raise import . \x2E;raise)
   (raise-continuable import . \x2E;raise-continuable)
   (else import . \x2E;else)
   (=> import . \x2E;=>))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/exceptions.scm" . 6145))

((call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core primitives))))
 (call
   (push.const core intrinsics)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core intrinsics))))
 (call
   (push.const
     (e2 unbound)
     (lambda import . \x2E;lambda)
     (parameterize import . core.parameters\x27;parameterize)
     (save unbound)
     (tmp1 unbound)
     (param unbound)
     (_ import . \x2E;_)
     (body unbound)
     (let import . \x2E;let)
     (... import . \x2E;...)
     (e1 unbound)
     (parameterize-aux import . core.parameters\x27;parameterize-aux)
     (value unbound)
     (new unbound)
     (more unbound)
     (set! import . \x2E;set!)
     (tmp2 unbound)
     (dynamic-wind import . \x2E;dynamic-wind)
     (stash unbound))
   (extend . 1)
   (call
     (push.const . syntax)
     (push.const . core.parameters\x27;parameterize-aux)
     (push.const
       ()
       ("../stdlib/core/parameters.scm" . 14341)
       ((_ () ((save new param value) ...) body ...)
        (let ((save #f) ... (new value) ...)
          (dynamic-wind
            (lambda () (set! save (param)) ... (param new) ...)
            (lambda () body ...)
            (lambda () (param save) ...)))
        ((body . 1) (value . 1) (param . 1) (new . 1) (save . 1))
        (set! lambda dynamic-wind let))
       ((_ ((e1 e2) . more) (stash ...) body ...)
        (parameterize-aux more (stash ... (tmp1 tmp2 e1 e2)) body ...)
        ((body . 1) (stash . 1) (more . 0) (e2 . 0) (e1 . 0))
        (tmp2 tmp1 parameterize-aux)))
     (push.iloc.0 . 0)
     (apply.gloc.of
       \x2E;set-top-level-macro!
       (\x2E;set-top-level-macro!
         'syntax
         'core.parameters\x27;parameterize-aux
         '(()
           ("../stdlib/core/parameters.scm" . 14341)
           ((_ () ((save new param value) ...) body ...)
            (let ((save #f) ... (new value) ...)
              (dynamic-wind
                (lambda () (set! save (param)) ... (param new) ...)
                (lambda () body ...)
                (lambda () (param save) ...)))
            ((body . 1) (value . 1) (param . 1) (new . 1) (save . 1))
            (set! lambda dynamic-wind let))
           ((_ ((e1 e2) . more) (stash ...) body ...)
            (parameterize-aux more (stash ... (tmp1 tmp2 e1 e2)) body ...)
            ((body . 1) (stash . 1) (more . 0) (e2 . 0) (e1 . 0))
            (tmp2 tmp1 parameterize-aux)))
         \x2E;L7)))
   (push.const . syntax)
   (push.const . core.parameters\x27;parameterize)
   (push.const
     ()
     ("../stdlib/core/parameters.scm" . 25605)
     ((_ ((e1 e2) ...) body ...)
      (parameterize-aux ((e1 e2) ...) () body ...)
      ((body . 1) (e2 . 1) (e1 . 1))
      (parameterize-aux)))
   (push.iloc.0 . 0)
   (apply.gloc.of
     \x2E;set-top-level-macro!
     (\x2E;set-top-level-macro!
       'syntax
       'core.parameters\x27;parameterize
       '(()
         ("../stdlib/core/parameters.scm" . 25605)
         ((_ ((e1 e2) ...) body ...)
          (parameterize-aux ((e1 e2) ...) () body ...)
          ((body . 1) (e2 . 1) (e1 . 1))
          (parameterize-aux)))
       \x2E;L7)))
 (push.const . core.parameters)
 (push.const . #f)
 (push.const
   (make-parameter import . \x2E;make-parameter)
   (parameterize import . core.parameters\x27;parameterize))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'core.parameters
     #f
     '((make-parameter import . \x2E;make-parameter)
       (parameterize import . core.parameters\x27;parameterize)))))

((call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/arithmetic.scm" . 6145))
 (close
   (2 0 . core.arithmetic\x27;flmod)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;fldiv 2 "../stdlib/core/arithmetic.scm" . 129043)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;fl* 2 "../stdlib/core/arithmetic.scm" . 129038)
   (ret.subr.gloc.of \x2E;fl- "../stdlib/core/arithmetic.scm" . 129031))
 (set.gloc.of core.arithmetic\x27;flmod)
 (close
   (2 0 . core.arithmetic\x27;fldiv-and-mod)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;fldiv 2 "../stdlib/core/arithmetic.scm" . 133136)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of \x2E;fl* 2 "../stdlib/core/arithmetic.scm" . 134170)
   (push.subr.gloc.of \x2E;fl- 2 "../stdlib/core/arithmetic.scm" . 134163)
   (ret.subr.gloc.of \x2E;values "../stdlib/core/arithmetic.scm" . 134153))
 (set.gloc.of core.arithmetic\x27;fldiv-and-mod)
 (close
   (2 0 . core.arithmetic\x27;flmod0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;fldiv0 2 "../stdlib/core/arithmetic.scm" . 138259)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;fl* 2 "../stdlib/core/arithmetic.scm" . 138254)
   (ret.subr.gloc.of \x2E;fl- "../stdlib/core/arithmetic.scm" . 138247))
 (set.gloc.of core.arithmetic\x27;flmod0)
 (close
   (2 0 . core.arithmetic\x27;fldiv0-and-mod0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;fldiv0 2 "../stdlib/core/arithmetic.scm" . 142353)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of \x2E;fl* 2 "../stdlib/core/arithmetic.scm" . 143387)
   (push.subr.gloc.of \x2E;fl- 2 "../stdlib/core/arithmetic.scm" . 143380)
   (ret.subr.gloc.of \x2E;values "../stdlib/core/arithmetic.scm" . 143369))
 (set.gloc.of core.arithmetic\x27;fldiv0-and-mod0)
 (push.const . 2)
 (subr.gloc.of \x2E;fixnum-width 0)
 (push)
 (subr.gloc.of \x2E;expt 2 "../stdlib/core/arithmetic.scm" . 145434)
 (set.gloc.of core.arithmetic\x27;2^fixnum-width)
 (close
   (2 0 . core.arithmetic\x27;fxmod)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;fxdiv 2 "../stdlib/core/arithmetic.scm" . 149523)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;fx* 2 "../stdlib/core/arithmetic.scm" . 149518)
   (ret.subr.gloc.of \x2E;fx- "../stdlib/core/arithmetic.scm" . 149511))
 (set.gloc.of core.arithmetic\x27;fxmod)
 (close
   (2 0 . core.arithmetic\x27;fxdiv-and-mod)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;fxdiv 2 "../stdlib/core/arithmetic.scm" . 153616)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of \x2E;fx* 2 "../stdlib/core/arithmetic.scm" . 154650)
   (push.subr.gloc.of \x2E;fx- 2 "../stdlib/core/arithmetic.scm" . 154643)
   (ret.subr.gloc.of \x2E;values "../stdlib/core/arithmetic.scm" . 154633))
 (set.gloc.of core.arithmetic\x27;fxdiv-and-mod)
 (close
   (2 0 . core.arithmetic\x27;fxmod0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;fxdiv0 2 "../stdlib/core/arithmetic.scm" . 158739)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;fx* 2 "../stdlib/core/arithmetic.scm" . 158734)
   (ret.subr.gloc.of \x2E;fx- "../stdlib/core/arithmetic.scm" . 158727))
 (set.gloc.of core.arithmetic\x27;fxmod0)
 (close
   (2 0 . core.arithmetic\x27;fxdiv0-and-mod0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;fxdiv0 2 "../stdlib/core/arithmetic.scm" . 162833)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.iloc.0 . 0)
   (push.iloc.1 . 1)
   (push.subr.gloc.of \x2E;fx* 2 "../stdlib/core/arithmetic.scm" . 163867)
   (push.subr.gloc.of \x2E;fx- 2 "../stdlib/core/arithmetic.scm" . 163860)
   (ret.subr.gloc.of \x2E;values "../stdlib/core/arithmetic.scm" . 163849))
 (set.gloc.of core.arithmetic\x27;fxdiv0-and-mod0)
 (close
   (3 0 . core.arithmetic\x27;fx+/carry)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.subr.gloc.of \x2E;+ 3 "../stdlib/core/arithmetic.scm" . 167953)
   (extend . 1)
   (call
     (push.iloc.0 . 0)
     (push.gloc.of core.arithmetic\x27;2^fixnum-width)
     (apply.gloc.of \x2E;mod0 "../stdlib/core/arithmetic.scm" . 168978))
   (push)
   (push.iloc.0 . 0)
   (push.gloc.of core.arithmetic\x27;2^fixnum-width)
   (push.subr.gloc.of \x2E;div0 2 "../stdlib/core/arithmetic.scm" . 170002)
   (ret.subr.gloc.of \x2E;values "../stdlib/core/arithmetic.scm" . 171017))
 (set.gloc.of core.arithmetic\x27;fx+/carry)
 (close
   (3 0 . core.arithmetic\x27;fx-/carry)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.subr.gloc.of \x2E;- 3 "../stdlib/core/arithmetic.scm" . 175121)
   (extend . 1)
   (call
     (push.iloc.0 . 0)
     (push.gloc.of core.arithmetic\x27;2^fixnum-width)
     (apply.gloc.of \x2E;mod0 "../stdlib/core/arithmetic.scm" . 176146))
   (push)
   (push.iloc.0 . 0)
   (push.gloc.of core.arithmetic\x27;2^fixnum-width)
   (push.subr.gloc.of \x2E;div0 2 "../stdlib/core/arithmetic.scm" . 177170)
   (ret.subr.gloc.of \x2E;values "../stdlib/core/arithmetic.scm" . 178185))
 (set.gloc.of core.arithmetic\x27;fx-/carry)
 (close
   (3 0 . core.arithmetic\x27;fx*/carry)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;* 2 "../stdlib/core/arithmetic.scm" . 182292)
   (push.iloc.0 . 2)
   (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/arithmetic.scm" . 182289)
   (extend . 1)
   (call
     (push.iloc.0 . 0)
     (push.gloc.of core.arithmetic\x27;2^fixnum-width)
     (apply.gloc.of \x2E;mod0 "../stdlib/core/arithmetic.scm" . 183314))
   (push)
   (push.iloc.0 . 0)
   (push.gloc.of core.arithmetic\x27;2^fixnum-width)
   (push.subr.gloc.of \x2E;div0 2 "../stdlib/core/arithmetic.scm" . 184338)
   (ret.subr.gloc.of \x2E;values "../stdlib/core/arithmetic.scm" . 185353))
 (set.gloc.of core.arithmetic\x27;fx*/carry)
 (close
   (4 0 . core.arithmetic\x27;fxrotate-bit-field)
   (push.iloc.0 . 2)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;fx- 2 "../stdlib/core/arithmetic.scm" . 193557)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;fxpositive? 1 "../stdlib/core/arithmetic.scm" . 194573)
   (if.true
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (push.subr.gloc.of \x2E;fx- 2 "../stdlib/core/arithmetic.scm" . 198710)
     (push.subr.gloc.of \x2E;fxbit-field 3 "../stdlib/core/arithmetic.scm" . 198689)
     (push.iloc.1 . 3)
     (push.subr.gloc.of \x2E;fxarithmetic-shift-left 2 "../stdlib/core/arithmetic.scm" . 197664)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.subr.gloc.of \x2E;fxbit-field 3 "../stdlib/core/arithmetic.scm" . 200737)
     (push.iloc.0 . 0)
     (push.iloc.1 . 3)
     (push.subr.gloc.of \x2E;fx- 2 "../stdlib/core/arithmetic.scm" . 200763)
     (push.subr.gloc.of \x2E;fxarithmetic-shift-right 2 "../stdlib/core/arithmetic.scm" . 199712)
     (push.subr.gloc.of \x2E;fxior 2 "../stdlib/core/arithmetic.scm" . 196639)
     (ret.subr.gloc.of \x2E;fxcopy-bit-field "../stdlib/core/arithmetic.scm" . 195597))
   (ret.iloc 1 . 0))
 (set.gloc.of core.arithmetic\x27;fxrotate-bit-field)
 (close
   (3 0 . core.arithmetic\x27;fxreverse-bit-field)
   (push.iloc.0 . 2)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;fx- 2 "../stdlib/core/arithmetic.scm" . 208917)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;fxpositive? 1 "../stdlib/core/arithmetic.scm" . 209933)
   (if.true
     (extend.enclose+
       (3 0 . loop)
       (push.iloc.0 . 2)
       (subr.gloc.of \x2E;fxzero? 1 "../stdlib/core/arithmetic.scm" . 211987)
       (if.true
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 3 . 2)
         (push.iloc.0 . 0)
         (ret.subr.gloc.of \x2E;fxcopy-bit-field "../stdlib/core/arithmetic.scm" . 213011))
       (push.iloc.0 . 1)
       (push.const . 1)
       (push.subr.gloc.of \x2E;fxand 2 "../stdlib/core/arithmetic.scm" . 214048)
       (subr.gloc.of \x2E;fxzero? 1 "../stdlib/core/arithmetic.scm" . 214039)
       (if.true
         (push.iloc.0 . 0)
         (push.const . 1)
         (push.subr.gloc.of \x2E;fxarithmetic-shift-left 2 "../stdlib/core/arithmetic.scm" . 215069)
         (push.iloc.0 . 1)
         (push.const . 1)
         (push.subr.gloc.of
           \x2E;fxarithmetic-shift-right
           2
           "../stdlib/core/arithmetic.scm"
           .
           216093)
         (push.iloc.0 . 2)
         (push.const . 1)
         (push.subr.gloc.of \x2E;fx- 2 "../stdlib/core/arithmetic.scm" . 217117)
         (apply.iloc+ (1 . 0) "../stdlib/core/arithmetic.scm" . 215063))
       (push.iloc.0 . 0)
       (push.const . 1)
       (push.subr.gloc.of \x2E;fxarithmetic-shift-left 2 "../stdlib/core/arithmetic.scm" . 218148)
       (push.const . 1)
       (push.subr.gloc.of \x2E;fxior 2 "../stdlib/core/arithmetic.scm" . 218141)
       (push.iloc.0 . 1)
       (push.const . 1)
       (push.subr.gloc.of \x2E;fxarithmetic-shift-right 2 "../stdlib/core/arithmetic.scm" . 219165)
       (push.iloc.0 . 2)
       (push.const . 1)
       (push.subr.gloc.of \x2E;fx- 2 "../stdlib/core/arithmetic.scm" . 220189)
       (apply.iloc+ (1 . 0) "../stdlib/core/arithmetic.scm" . 218135))
     (push.const . 0)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc 2 . 2)
     (push.subr.gloc.of \x2E;fxbit-field 3 "../stdlib/core/arithmetic.scm" . 210988)
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "../stdlib/core/arithmetic.scm" . 211983))
   (ret.iloc 1 . 0))
 (set.gloc.of core.arithmetic\x27;fxreverse-bit-field)
 (gloc.of \x2E;bitwise-arithmetic-shift)
 (set.gloc.of core.arithmetic\x27;bitwise-arithmetic-shift-left)
 (close
   (3 0 . core.arithmetic\x27;bitwise-if)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;bitwise-and 2 "../stdlib/core/arithmetic.scm" . 227348)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;bitwise-not 1 "../stdlib/core/arithmetic.scm" . 228385)
   (push.iloc.0 . 2)
   (push.subr.gloc.of \x2E;bitwise-and 2 "../stdlib/core/arithmetic.scm" . 228372)
   (ret.subr.gloc.of \x2E;bitwise-ior "../stdlib/core/arithmetic.scm" . 227335))
 (set.gloc.of core.arithmetic\x27;bitwise-if)
 (close
   (2 0 . core.arithmetic\x27;bitwise-bit-set?)
   (push.const . 1)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;bitwise-arithmetic-shift 2 "../stdlib/core/arithmetic.scm" . 232480)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;bitwise-and 2 "../stdlib/core/arithmetic.scm" . 232467)
   (push.subr.gloc.of \x2E;zero? 1 "../stdlib/core/arithmetic.scm" . 232460)
   (ret.subr.gloc.of \x2E;not "../stdlib/core/arithmetic.scm" . 232455))
 (set.gloc.of core.arithmetic\x27;bitwise-bit-set?)
 (close
   (3 0 . core.arithmetic\x27;bitwise-copy-bit)
   (push.const . 1)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;bitwise-arithmetic-shift 2 "../stdlib/core/arithmetic.scm" . 236564)
   (push.iloc.0 . 2)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;bitwise-arithmetic-shift 2 "../stdlib/core/arithmetic.scm" . 237594)
   (push.iloc.0 . 0)
   (apply.gloc.of core.arithmetic\x27;bitwise-if "../stdlib/core/arithmetic.scm" . 237577))
 (set.gloc.of core.arithmetic\x27;bitwise-copy-bit)
 (close
   (3 0 . core.arithmetic\x27;bitwise-bit-field)
   (push.iloc.0 . 0)
   (push.const . -1)
   (push.iloc.0 . 2)
   (push.subr.gloc.of \x2E;bitwise-arithmetic-shift 2 "../stdlib/core/arithmetic.scm" . 241696)
   (push.subr.gloc.of \x2E;bitwise-not 1 "../stdlib/core/arithmetic.scm" . 241683)
   (push.subr.gloc.of \x2E;bitwise-and 2 "../stdlib/core/arithmetic.scm" . 242729)
   (push.iloc.0 . 1)
   (apply.gloc.of
     core.arithmetic\x27;bitwise-arithmetic-shift-right
     "../stdlib/core/arithmetic.scm"
     .
     242697))
 (set.gloc.of core.arithmetic\x27;bitwise-bit-field)
 (close
   (4 0 . core.arithmetic\x27;bitwise-copy-bit-field)
   (push.const . -1)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;bitwise-arithmetic-shift 2 "../stdlib/core/arithmetic.scm" . 250901)
   (push.const . -1)
   (push.iloc.0 . 2)
   (push.subr.gloc.of \x2E;bitwise-arithmetic-shift 2 "../stdlib/core/arithmetic.scm" . 251938)
   (push.subr.gloc.of \x2E;bitwise-not 1 "../stdlib/core/arithmetic.scm" . 251925)
   (push.subr.gloc.of \x2E;bitwise-and 2 "../stdlib/core/arithmetic.scm" . 252948)
   (push.iloc.0 . 3)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;bitwise-arithmetic-shift 2 "../stdlib/core/arithmetic.scm" . 253978)
   (push.iloc.0 . 0)
   (apply.gloc.of core.arithmetic\x27;bitwise-if "../stdlib/core/arithmetic.scm" . 253961))
 (set.gloc.of core.arithmetic\x27;bitwise-copy-bit-field)
 (close
   (2 0 . core.arithmetic\x27;bitwise-arithmetic-shift-right)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;- 1 "../stdlib/core/arithmetic.scm" . 258085)
   (ret.subr.gloc.of \x2E;bitwise-arithmetic-shift "../stdlib/core/arithmetic.scm" . 258055))
 (set.gloc.of core.arithmetic\x27;bitwise-arithmetic-shift-right)
 (close
   (4 0 . core.arithmetic\x27;bitwise-rotate-bit-field)
   (push.iloc.0 . 2)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;- 2 "../stdlib/core/arithmetic.scm" . 266261)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;positive? 1 "../stdlib/core/arithmetic.scm" . 267277)
   (if.true
     (call
       (push.iloc.1 . 3)
       (push.iloc.0 . 0)
       (apply.gloc.of \x2E;mod "../stdlib/core/arithmetic.scm" . 268315))
     (push)
     (extend . 1)
     (call
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (apply.gloc.of
         core.arithmetic\x27;bitwise-bit-field
         "../stdlib/core/arithmetic.scm"
         .
         269340))
     (push)
     (extend . 1)
     (push.iloc 3 . 0)
     (push.iloc 3 . 1)
     (push.iloc 3 . 2)
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;bitwise-arithmetic-shift 2 "../stdlib/core/arithmetic.scm" . 270364)
     (call
       (push.iloc.0 . 0)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;- 2 "../stdlib/core/arithmetic.scm" . 271427)
       (apply.gloc.of
         core.arithmetic\x27;bitwise-arithmetic-shift-right
         "../stdlib/core/arithmetic.scm"
         .
         271388))
     (push)
     (push.subr.gloc.of \x2E;bitwise-ior 2 "../stdlib/core/arithmetic.scm" . 272411)
     (apply.gloc.of
       core.arithmetic\x27;bitwise-copy-bit-field
       "../stdlib/core/arithmetic.scm"
       .
       273423))
   (ret.iloc 1 . 0))
 (set.gloc.of core.arithmetic\x27;bitwise-rotate-bit-field)
 (close
   (3 0 . core.arithmetic\x27;bitwise-reverse-bit-field)
   (push.iloc.0 . 2)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;- 2 "../stdlib/core/arithmetic.scm" . 281621)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;positive? 1 "../stdlib/core/arithmetic.scm" . 282637)
   (if.true
     (extend.enclose+
       (3 0 . loop)
       (push.iloc.0 . 2)
       (subr.gloc.of \x2E;zero? 1 "../stdlib/core/arithmetic.scm" . 284691)
       (if.true
         (push.iloc 3 . 0)
         (push.iloc 3 . 1)
         (push.iloc 3 . 2)
         (push.iloc.0 . 0)
         (apply.gloc.of
           core.arithmetic\x27;bitwise-copy-bit-field
           "../stdlib/core/arithmetic.scm"
           .
           285715))
       (push.iloc.0 . 1)
       (push.const . 1)
       (push.subr.gloc.of \x2E;bitwise-and 2 "../stdlib/core/arithmetic.scm" . 286750)
       (subr.gloc.of \x2E;zero? 1 "../stdlib/core/arithmetic.scm" . 286743)
       (if.true
         (push.iloc.0 . 0)
         (push.const . 1)
         (push.subr.gloc.of
           \x2E;bitwise-arithmetic-shift
           2
           "../stdlib/core/arithmetic.scm"
           .
           287773)
         (call
           (push.iloc.0 . 1)
           (push.const . 1)
           (apply.gloc.of
             core.arithmetic\x27;bitwise-arithmetic-shift-right
             "../stdlib/core/arithmetic.scm"
             .
             288797))
         (push)
         (push.n+.iloc (0 . 2) -1 "../stdlib/core/arithmetic.scm" . 289821)
         (apply.iloc+ (1 . 0) "../stdlib/core/arithmetic.scm" . 287767))
       (push.iloc.0 . 0)
       (push.const . 1)
       (push.subr.gloc.of \x2E;bitwise-arithmetic-shift 2 "../stdlib/core/arithmetic.scm" . 290858)
       (push.const . 1)
       (push.subr.gloc.of \x2E;bitwise-ior 2 "../stdlib/core/arithmetic.scm" . 290845)
       (call
         (push.iloc.0 . 1)
         (push.const . 1)
         (apply.gloc.of
           core.arithmetic\x27;bitwise-arithmetic-shift-right
           "../stdlib/core/arithmetic.scm"
           .
           291869))
       (push)
       (push.n+.iloc (0 . 2) -1 "../stdlib/core/arithmetic.scm" . 292893)
       (apply.iloc+ (1 . 0) "../stdlib/core/arithmetic.scm" . 290839))
     (push.const . 0)
     (call
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (apply.gloc.of
         core.arithmetic\x27;bitwise-bit-field
         "../stdlib/core/arithmetic.scm"
         .
         283692))
     (push)
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "../stdlib/core/arithmetic.scm" . 284687))
   (ret.iloc 1 . 0))
 (set.gloc.of core.arithmetic\x27;bitwise-reverse-bit-field)
 (push.const . core.arithmetic)
 (push.const . #f)
 (push.const
   (fixnum? import . \x2E;fixnum?)
   (fixnum-width import . \x2E;fixnum-width)
   (least-fixnum import . \x2E;least-fixnum)
   (greatest-fixnum import . \x2E;greatest-fixnum)
   (fx=? import . \x2E;fx=?)
   (fx<? import . \x2E;fx<?)
   (fx>? import . \x2E;fx>?)
   (fx<=? import . \x2E;fx<=?)
   (fx>=? import . \x2E;fx>=?)
   (fxzero? import . \x2E;fxzero?)
   (fxpositive? import . \x2E;fxpositive?)
   (fxnegative? import . \x2E;fxnegative?)
   (fxodd? import . \x2E;fxodd?)
   (fxeven? import . \x2E;fxeven?)
   (fxmax import . \x2E;fxmax)
   (fxmin import . \x2E;fxmin)
   (fx+ import . \x2E;fx+)
   (fx* import . \x2E;fx*)
   (fx- import . \x2E;fx-)
   (fxdiv import . \x2E;fxdiv)
   (fxmod import . core.arithmetic\x27;fxmod)
   (fxdiv-and-mod import . core.arithmetic\x27;fxdiv-and-mod)
   (fxdiv0 import . \x2E;fxdiv0)
   (fxmod0 import . core.arithmetic\x27;fxmod0)
   (fxdiv0-and-mod0 import . core.arithmetic\x27;fxdiv0-and-mod0)
   (fx+/carry import . core.arithmetic\x27;fx+/carry)
   (fx-/carry import . core.arithmetic\x27;fx-/carry)
   (fx*/carry import . core.arithmetic\x27;fx*/carry)
   (fxnot import . \x2E;fxnot)
   (fxand import . \x2E;fxand)
   (fxior import . \x2E;fxior)
   (fxxor import . \x2E;fxxor)
   (fxif import . \x2E;fxif)
   (fxbit-count import . \x2E;fxbit-count)
   (fxlength import . \x2E;fxlength)
   (fxfirst-bit-set import . \x2E;fxfirst-bit-set)
   (fxbit-set? import . \x2E;fxbit-set?)
   (fxcopy-bit import . \x2E;fxcopy-bit)
   (fxbit-field import . \x2E;fxbit-field)
   (fxcopy-bit-field import . \x2E;fxcopy-bit-field)
   (fxarithmetic-shift import . \x2E;fxarithmetic-shift)
   (fxarithmetic-shift-left import . \x2E;fxarithmetic-shift-left)
   (fxarithmetic-shift-right import . \x2E;fxarithmetic-shift-right)
   (fxrotate-bit-field import . core.arithmetic\x27;fxrotate-bit-field)
   (fxreverse-bit-field import . core.arithmetic\x27;fxreverse-bit-field)
   (flonum? import . \x2E;flonum?)
   (real->flonum import . \x2E;real->flonum)
   (fl=? import . \x2E;fl=?)
   (fl<? import . \x2E;fl<?)
   (fl>? import . \x2E;fl>?)
   (fl<=? import . \x2E;fl<=?)
   (fl>=? import . \x2E;fl>=?)
   (flinteger? import . \x2E;flinteger?)
   (flzero? import . \x2E;flzero?)
   (flpositive? import . \x2E;flpositive?)
   (flnegative? import . \x2E;flnegative?)
   (flodd? import . \x2E;flodd?)
   (fleven? import . \x2E;fleven?)
   (flfinite? import . \x2E;flfinite?)
   (flinfinite? import . \x2E;flinfinite?)
   (flnan? import . \x2E;flnan?)
   (flmax import . \x2E;flmax)
   (flmin import . \x2E;flmin)
   (fl+ import . \x2E;fl+)
   (fl* import . \x2E;fl*)
   (fl- import . \x2E;fl-)
   (fl/ import . \x2E;fl/)
   (fldiv-and-mod import . core.arithmetic\x27;fldiv-and-mod)
   (fldiv import . \x2E;fldiv)
   (flmod import . core.arithmetic\x27;flmod)
   (fldiv0-and-mod0 import . core.arithmetic\x27;fldiv0-and-mod0)
   (fldiv0 import . \x2E;fldiv0)
   (flmod0 import . core.arithmetic\x27;flmod0)
   (flnumerator import . \x2E;flnumerator)
   (fldenominator import . \x2E;fldenominator)
   (flfloor import . \x2E;flfloor)
   (flceiling import . \x2E;flceiling)
   (fltruncate import . \x2E;fltruncate)
   (flround import . \x2E;flround)
   (flexp import . \x2E;flexp)
   (flexpt import . \x2E;flexpt)
   (fllog import . \x2E;fllog)
   (flsin import . \x2E;flsin)
   (flcos import . \x2E;flcos)
   (fltan import . \x2E;fltan)
   (flasin import . \x2E;flasin)
   (flacos import . \x2E;flacos)
   (flatan import . \x2E;flatan)
   (flabs import . \x2E;flabs)
   (flsqrt import . \x2E;flsqrt)
   (fixnum->flonum import . \x2E;fixnum->flonum)
   (bitwise-not import . \x2E;bitwise-not)
   (bitwise-and import . \x2E;bitwise-and)
   (bitwise-ior import . \x2E;bitwise-ior)
   (bitwise-xor import . \x2E;bitwise-xor)
   (bitwise-if import . core.arithmetic\x27;bitwise-if)
   (bitwise-bit-count import . \x2E;bitwise-bit-count)
   (bitwise-length import . \x2E;bitwise-length)
   (bitwise-first-bit-set import . \x2E;bitwise-first-bit-set)
   (bitwise-bit-set? import . core.arithmetic\x27;bitwise-bit-set?)
   (bitwise-copy-bit import . core.arithmetic\x27;bitwise-copy-bit)
   (bitwise-bit-field import . core.arithmetic\x27;bitwise-bit-field)
   (bitwise-copy-bit-field import . core.arithmetic\x27;bitwise-copy-bit-field)
   (bitwise-arithmetic-shift import . \x2E;bitwise-arithmetic-shift)
   (bitwise-arithmetic-shift-left import . core.arithmetic\x27;bitwise-arithmetic-shift-left)
   (bitwise-arithmetic-shift-right import . core.arithmetic\x27;bitwise-arithmetic-shift-right)
   (bitwise-rotate-bit-field import . core.arithmetic\x27;bitwise-rotate-bit-field)
   (bitwise-reverse-bit-field import . core.arithmetic\x27;bitwise-reverse-bit-field)
   (&no-infinities import . \x2E;&no-infinities)
   (make-no-infinities-violation import . \x2E;make-no-infinities-violation)
   (no-infinities-violation? import . \x2E;no-infinities-violation?)
   (&no-nans import . \x2E;&no-nans)
   (make-no-nans-violation import . \x2E;make-no-nans-violation)
   (no-nans-violation? import . \x2E;no-nans-violation?))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/arithmetic.scm" . 6145))

((call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/sorting.scm" . 6145))
 (close
   (2 0 . core.sorting\x27;list-sort)
   (extend.unbound . 3)
   (push.close+
     (2 0 . merge)
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (iloc.0 . 1)
     (if.null? (ret.iloc 0 . 0))
     (call
       (push.car.iloc (0 . 1) "../stdlib/core/sorting.scm" . 23575)
       (push.car.iloc (0 . 0) "../stdlib/core/sorting.scm" . 23586)
       (apply.iloc (2 . 0) "../stdlib/core/sorting.scm" . 23569))
     (if.true
       (push.car.iloc (0 . 1) "../stdlib/core/sorting.scm" . 24599)
       (call
         (push.iloc.0 . 0)
         (push.cdr.iloc (0 . 1) "../stdlib/core/sorting.scm" . 24622)
         (apply.iloc+ (1 . 0) "../stdlib/core/sorting.scm" . 24610))
       (ret.cons "../stdlib/core/sorting.scm" . 24593))
     (push.car.iloc (0 . 0) "../stdlib/core/sorting.scm" . 25623)
     (call
       (push.cdr.iloc (0 . 0) "../stdlib/core/sorting.scm" . 25641)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 0) "../stdlib/core/sorting.scm" . 25634))
     (ret.cons "../stdlib/core/sorting.scm" . 25617))
   (push.close+
     (2 0 . sort)
     (=n.iloc (0 . 1) 1 "../stdlib/core/sorting.scm" . 29714)
     (if.true
       (push.car.iloc (0 . 0) "../stdlib/core/sorting.scm" . 30744)
       (ret.subr.gloc.of \x2E;list "../stdlib/core/sorting.scm" . 30738))
     (=n.iloc (0 . 1) 2 "../stdlib/core/sorting.scm" . 31762)
     (if.true
       (call
         (push.cadr.iloc (0 . 0) "../stdlib/core/sorting.scm" . 32796)
         (push.car.iloc (0 . 0) "../stdlib/core/sorting.scm" . 32807)
         (apply.iloc (2 . 0) "../stdlib/core/sorting.scm" . 32790))
       (if.true
         (push.cadr.iloc (0 . 0) "../stdlib/core/sorting.scm" . 33820)
         (push.car.iloc (0 . 0) "../stdlib/core/sorting.scm" . 33831)
         (ret.subr.gloc.of \x2E;list "../stdlib/core/sorting.scm" . 33814))
       (push.car.iloc (0 . 0) "../stdlib/core/sorting.scm" . 34844)
       (push.cadr.iloc (0 . 0) "../stdlib/core/sorting.scm" . 34854)
       (ret.subr.gloc.of \x2E;list "../stdlib/core/sorting.scm" . 34838))
     (push.iloc.0 . 1)
     (push.const . 2)
     (push.subr.gloc.of \x2E;div 2 "../stdlib/core/sorting.scm" . 36893)
     (extend . 1)
     (call
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.iloc+ (2 . 1) "../stdlib/core/sorting.scm" . 37915))
     (push)
     (call
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;list-tail 2 "../stdlib/core/sorting.scm" . 38945)
       (push.iloc.1 . 1)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;- 2 "../stdlib/core/sorting.scm" . 38965)
       (apply.iloc+ (2 . 1) "../stdlib/core/sorting.scm" . 38939))
     (push)
     (apply.iloc+ (2 . 0) "../stdlib/core/sorting.scm" . 37908))
   (push.close+
     (1 0 . divide)
     (extend.enclose+
       (2 0 . loop)
       (cdr.iloc (0 . 1) "../stdlib/core/sorting.scm" . 44059)
       (if.null?
         (push.iloc.0 . 0)
         (push.const)
         (ret.subr.gloc.of \x2E;values "../stdlib/core/sorting.scm" . 44070))
       (call
         (push.car.iloc (0 . 1) "../stdlib/core/sorting.scm" . 46110)
         (push.cadr.iloc (0 . 1) "../stdlib/core/sorting.scm" . 46120)
         (apply.iloc (4 . 0) "../stdlib/core/sorting.scm" . 46104))
       (if.true
         (push.n+.iloc (0 . 0) 1 "../stdlib/core/sorting.scm" . 47134)
         (push.cdr.iloc (0 . 1) "../stdlib/core/sorting.scm" . 47144)
         (apply.iloc+ (1 . 0) "../stdlib/core/sorting.scm" . 47128))
       (push.iloc.0 . 0)
       (push.cdr.iloc (0 . 1) "../stdlib/core/sorting.scm" . 48164)
       (ret.subr.gloc.of \x2E;values "../stdlib/core/sorting.scm" . 48152))
     (push.const . 1)
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "../stdlib/core/sorting.scm" . 44045))
   (enclose . 3)
   (iloc.1 . 1)
   (if.null?.ret.const)
   (push.iloc.1 . 1)
   (push.subr.gloc.of \x2E;length 1 "../stdlib/core/sorting.scm" . 52249)
   (extend . 1)
   (push.close (0 0) (push.iloc 3 . 1) (apply.iloc+ (2 . 2) "../stdlib/core/sorting.scm" . 53287))
   (push.close
     (2 0)
     (iloc.0 . 1)
     (if.null? (ret.iloc 3 . 1))
     (push.iloc 3 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;list-head 2 "../stdlib/core/sorting.scm" . 56352)
     (call
       (push.iloc.0 . 1)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;- 2 "../stdlib/core/sorting.scm" . 57387)
       (apply.iloc+ (2 . 1) "../stdlib/core/sorting.scm" . 57376))
     (push)
     (apply.iloc+ (2 . 0) "../stdlib/core/sorting.scm" . 56345))
   (apply.gloc.of
     \x2E;call-with-values
     (\x2E;call-with-values
       (lambda () (divide\x60;183* lst\x60;182*))
       (lambda (n\x60;200* rest\x60;200*)
         (if (\x2E;null? rest\x60;200*)
             lst\x60;182*
             (merge\x60;183*
               (\x2E;list-head lst\x60;182* n\x60;200*)
               (sort\x60;183* rest\x60;200* (\x2E;- len\x60;198* n\x60;200*))))))))
 (set.gloc.of core.sorting\x27;list-sort)
 (close
   (2 0 . core.sorting\x27;vector-sort)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;vector->list 1 "../stdlib/core/sorting.scm" . 61458)
   (extend . 1)
   (call
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of core.sorting\x27;list-sort "../stdlib/core/sorting.scm" . 62485))
   (push)
   (extend . 1)
   (push.iloc.1 . 0)
   (iloc.0 . 0)
   (if.eq? (ret.iloc 2 . 1))
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;list->vector "../stdlib/core/sorting.scm" . 65554))
 (set.gloc.of core.sorting\x27;vector-sort)
 (close
   (2 0 . core.sorting\x27;vector-sort!)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;vector-length 1 "../stdlib/core/sorting.scm" . 69649)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . 2)
   (push.subr.gloc.of \x2E;div 2 "../stdlib/core/sorting.scm" . 69693)
   (push.const . 1)
   (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/sorting.scm" . 69690)
   (push.subr.gloc.of \x2E;make-vector 1 "../stdlib/core/sorting.scm" . 69677)
   (extend . 1)
   (extend.unbound . 2)
   (push.close
     (2 0 . simple-sort!)
     (extend.enclose+
       (1 0 . loop1)
       (iloc.0 . 0)
       (<.iloc (2 . 1) "../stdlib/core/sorting.scm" . 74774)
       (if.true
         (push.iloc.0 . 0)
         (push.vector-ref.iloc (6 . 1) "../stdlib/core/sorting.scm" . 75807)
         (push.iloc.0 . 0)
         (extend . 2)
         (extend.enclose+
           (1 0 . loop2)
           (iloc.0 . 0)
           (<=.iloc (5 . 1) "../stdlib/core/sorting.scm" . 77857)
           (if.true
             (call
               (call
                 (push.iloc.0 . 0)
                 (push.vector-ref.iloc (9 . 1) "../stdlib/core/sorting.scm" . 78891)
                 (push.iloc 2 . 0)
                 (apply.iloc (9 . 0) "../stdlib/core/sorting.scm" . 78885))
               (if.false.ret)
               (iloc.0 . 0)
               (vector-ref.iloc (9 . 1) "../stdlib/core/sorting.scm" . 80943)
               (set.iloc (2 . 0) "../stdlib/core/sorting.scm" . 80935)
               (iloc.0 . 0)
               (set.iloc (2 . 1) "../stdlib/core/sorting.scm" . 81959)
               (ret.const.unspec))
             (push.n+.iloc (0 . 0) 1 "../stdlib/core/sorting.scm" . 82984)
             (apply.iloc+ (1 . 0) "../stdlib/core/sorting.scm" . 82977))
           (push.iloc 9 . 1)
           (push.iloc 2 . 1)
           (push.iloc 3 . 0)
           (push.vector-ref.iloc (9 . 1) "../stdlib/core/sorting.scm" . 85045)
           (subr.gloc.of \x2E;vector-set! 3 "../stdlib/core/sorting.scm" . 85025)
           (push.iloc 9 . 1)
           (push.iloc 3 . 0)
           (push.iloc 2 . 0)
           (subr.gloc.of \x2E;vector-set! 3 "../stdlib/core/sorting.scm" . 86049)
           (push.n+.iloc (3 . 0) 1 "../stdlib/core/sorting.scm" . 87080)
           (apply.iloc+ (4 . 0) "../stdlib/core/sorting.scm" . 87073))
         (push.n+.iloc (2 . 0) 1 "../stdlib/core/sorting.scm" . 76839)
         (apply.iloc+ (0 . 0) "../stdlib/core/sorting.scm" . 77850))
       (ret.const.unspec))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "../stdlib/core/sorting.scm" . 74767))
   (push.close
     (2 0 . sort!)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;- 2 "../stdlib/core/sorting.scm" . 91159)
     (push.const . 10)
     (subr.gloc.of \x2E;> 2 "../stdlib/core/sorting.scm" . 91156)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/sorting.scm" . 92199)
       (push.const . 2)
       (push.subr.gloc.of \x2E;div 2 "../stdlib/core/sorting.scm" . 92194)
       (extend . 1)
       (call
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.iloc (2 . 1) "../stdlib/core/sorting.scm" . 93206))
       (call
         (push.n+.iloc (0 . 0) 1 "../stdlib/core/sorting.scm" . 94237)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 1) "../stdlib/core/sorting.scm" . 94230))
       (extend.enclose+
         (2 0 . loop)
         (iloc.0 . 0)
         (>.iloc (2 . 0) "../stdlib/core/sorting.scm" . 96287)
         (if.true
           (extend.enclose+
             (3 0 . loop)
             (call
               (iloc.0 . 0)
               (<=.iloc (5 . 1) "../stdlib/core/sorting.scm" . 98349)
               (if.false.ret)
               (push.iloc.0 . 1)
               (push.iloc 2 . 1)
               (ret.subr.gloc.of \x2E;< "../stdlib/core/sorting.scm" . 98362))
             (if.true
               (call
                 (push.iloc.0 . 1)
                 (push.vector-ref.iloc (7 . 0) "../stdlib/core/sorting.scm" . 99381)
                 (push.iloc.0 . 0)
                 (push.vector-ref.iloc (9 . 1) "../stdlib/core/sorting.scm" . 99402)
                 (apply.iloc (9 . 0) "../stdlib/core/sorting.scm" . 99375))
               (if.true
                 (push.iloc 9 . 1)
                 (push.iloc.0 . 2)
                 (push.iloc.0 . 1)
                 (push.vector-ref.iloc (7 . 0) "../stdlib/core/sorting.scm" . 100420)
                 (subr.gloc.of \x2E;vector-set! 3 "../stdlib/core/sorting.scm" . 100399)
                 (push.iloc.0 . 0)
                 (push.n+.iloc (0 . 1) 1 "../stdlib/core/sorting.scm" . 101432)
                 (push.n+.iloc (0 . 2) 1 "../stdlib/core/sorting.scm" . 101441)
                 (apply.iloc+ (1 . 0) "../stdlib/core/sorting.scm" . 101423))
               (push.iloc 9 . 1)
               (push.iloc.0 . 2)
               (push.iloc.0 . 0)
               (push.vector-ref.iloc (9 . 1) "../stdlib/core/sorting.scm" . 103492)
               (subr.gloc.of \x2E;vector-set! 3 "../stdlib/core/sorting.scm" . 103471)
               (push.n+.iloc (0 . 0) 1 "../stdlib/core/sorting.scm" . 104501)
               (push.iloc.0 . 1)
               (push.n+.iloc (0 . 2) 1 "../stdlib/core/sorting.scm" . 104513)
               (apply.iloc+ (1 . 0) "../stdlib/core/sorting.scm" . 104495))
             (extend.enclose+
               (2 0 . loop)
               (iloc.0 . 0)
               (<.iloc (4 . 1) "../stdlib/core/sorting.scm" . 107569)
               (if.true
                 (push.iloc 11 . 1)
                 (push.iloc.0 . 1)
                 (push.iloc.0 . 0)
                 (push.vector-ref.iloc (9 . 0) "../stdlib/core/sorting.scm" . 108614)
                 (subr.gloc.of \x2E;vector-set! 3 "../stdlib/core/sorting.scm" . 108593)
                 (push.n+.iloc (0 . 0) 1 "../stdlib/core/sorting.scm" . 109623)
                 (push.n+.iloc (0 . 1) 1 "../stdlib/core/sorting.scm" . 109632)
                 (apply.iloc+ (1 . 0) "../stdlib/core/sorting.scm" . 109617))
               (ret.const.unspec))
             (push.iloc.1 . 1)
             (push.iloc.1 . 2)
             (apply.iloc+ (0 . 0) "../stdlib/core/sorting.scm" . 107562))
           (push.n+.iloc (3 . 0) 1 "../stdlib/core/sorting.scm" . 97326)
           (push.const . 0)
           (push.iloc 4 . 0)
           (apply.iloc+ (0 . 0) "../stdlib/core/sorting.scm" . 98337))
         (push.iloc 5 . 0)
         (push.iloc.0 . 1)
         (push.iloc.0 . 0)
         (push.vector-ref.iloc (7 . 1) "../stdlib/core/sorting.scm" . 111672)
         (subr.gloc.of \x2E;vector-set! 3 "../stdlib/core/sorting.scm" . 111647)
         (push.n+.iloc (0 . 0) 1 "../stdlib/core/sorting.scm" . 112677)
         (push.n+.iloc (0 . 1) 1 "../stdlib/core/sorting.scm" . 112685)
         (apply.iloc+ (1 . 0) "../stdlib/core/sorting.scm" . 112671))
       (push.iloc 2 . 0)
       (push.const . 0)
       (apply.iloc+ (0 . 0) "../stdlib/core/sorting.scm" . 96280))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.iloc (1 . 0) "../stdlib/core/sorting.scm" . 114708))
   (enclose . 2)
   (push.const . 0)
   (push.n+.iloc (2 . 0) -1 "../stdlib/core/sorting.scm" . 116754)
   (apply.iloc (0 . 1) "../stdlib/core/sorting.scm" . 116745))
 (set.gloc.of core.sorting\x27;vector-sort!)
 (push.const . core.sorting)
 (push.const . #f)
 (push.const
   (list-sort import . core.sorting\x27;list-sort)
   (vector-sort import . core.sorting\x27;vector-sort)
   (vector-sort! import . core.sorting\x27;vector-sort!))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/sorting.scm" . 6145))

((call
   (push.const core arithmetic)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/bytevectors.scm" . 6145))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/bytevectors.scm" . 6145))
 (close
   (4 0 . core.bytevectors\x27;bytevector-uint-ref)
   (push.iloc.0 . 2)
   (const . big)
   (if.eq?
     (push.iloc.0 . 1)
     (push.iloc.0 . 3)
     (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/bytevectors.scm" . 47129)
     (extend . 1)
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (>=.iloc (2 . 0) "../stdlib/core/bytevectors.scm" . 49174)
       (if.true (ret.iloc 0 . 1))
       (push.n+.iloc (0 . 0) 1 "../stdlib/core/bytevectors.scm" . 51228)
       (push.const . 256)
       (push.iloc.0 . 1)
       (push.subr.gloc.of \x2E;* 2 "../stdlib/core/bytevectors.scm" . 51239)
       (push.iloc 3 . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;bytevector-u8-ref 2 "../stdlib/core/bytevectors.scm" . 51251)
       (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/bytevectors.scm" . 51236)
       (apply.iloc+ (1 . 0) "../stdlib/core/bytevectors.scm" . 51222))
     (push.iloc 2 . 1)
     (push.const . 0)
     (apply.iloc+ (0 . 0) "../stdlib/core/bytevectors.scm" . 49170))
   (push.iloc.0 . 2)
   (const . little)
   (if.eq?
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (<.iloc (2 . 1) "../stdlib/core/bytevectors.scm" . 54292)
       (if.true (ret.iloc 0 . 1))
       (push.n+.iloc (0 . 0) -1 "../stdlib/core/bytevectors.scm" . 56346)
       (push.const . 256)
       (push.iloc.0 . 1)
       (push.subr.gloc.of \x2E;* 2 "../stdlib/core/bytevectors.scm" . 56357)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;bytevector-u8-ref 2 "../stdlib/core/bytevectors.scm" . 56369)
       (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/bytevectors.scm" . 56354)
       (apply.iloc+ (1 . 0) "../stdlib/core/bytevectors.scm" . 56340))
     (push.iloc.1 . 1)
     (push.iloc.1 . 3)
     (push.const . -1)
     (push.subr.gloc.of \x2E;+ 3 "../stdlib/core/bytevectors.scm" . 53276)
     (push.const . 0)
     (apply.iloc+ (0 . 0) "../stdlib/core/bytevectors.scm" . 54288))
   (push.const . bytevector-uint-ref)
   (push.const . "expected endianness, but got ~r, as argument 3")
   (push.iloc.0 . 2)
   (push.subr.gloc.of \x2E;format 2 "../stdlib/core/bytevectors.scm" . 59427)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.subr.gloc.of \x2E;list 4 "../stdlib/core/bytevectors.scm" . 60451)
   (apply.gloc.of \x2E;assertion-violation "../stdlib/core/bytevectors.scm" . 58382))
 (set.gloc.of core.bytevectors\x27;bytevector-uint-ref)
 (close
   (4 0 . core.bytevectors\x27;bytevector-sint-ref)
   (push.iloc.0 . 2)
   (const . big)
   (if.eq?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;bytevector-u8-ref 2 "../stdlib/core/bytevectors.scm" . 65557)
     (push.const . 127)
     (subr.gloc.of \x2E;> 2 "../stdlib/core/bytevectors.scm" . 65554)
     (if.true
       (call
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.0 . 2)
         (push.iloc.0 . 3)
         (apply.gloc.of
           core.bytevectors\x27;bytevector-uint-ref
           "../stdlib/core/bytevectors.scm"
           .
           66581))
       (push)
       (push.const . 256)
       (push.iloc.0 . 3)
       (push.subr.gloc.of \x2E;expt 2 "../stdlib/core/bytevectors.scm" . 66624)
       (ret.subr.gloc.of \x2E;- "../stdlib/core/bytevectors.scm" . 66578))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of
       core.bytevectors\x27;bytevector-uint-ref
       "../stdlib/core/bytevectors.scm"
       .
       67602))
   (push.iloc.0 . 2)
   (const . little)
   (if.eq?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 3)
     (push.const . -1)
     (push.subr.gloc.of \x2E;+ 3 "../stdlib/core/bytevectors.scm" . 69675)
     (push.subr.gloc.of \x2E;bytevector-u8-ref 2 "../stdlib/core/bytevectors.scm" . 69653)
     (push.const . 127)
     (subr.gloc.of \x2E;> 2 "../stdlib/core/bytevectors.scm" . 69650)
     (if.true
       (call
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.0 . 2)
         (push.iloc.0 . 3)
         (apply.gloc.of
           core.bytevectors\x27;bytevector-uint-ref
           "../stdlib/core/bytevectors.scm"
           .
           70677))
       (push)
       (push.const . 256)
       (push.iloc.0 . 3)
       (push.subr.gloc.of \x2E;expt 2 "../stdlib/core/bytevectors.scm" . 70720)
       (ret.subr.gloc.of \x2E;- "../stdlib/core/bytevectors.scm" . 70674))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of
       core.bytevectors\x27;bytevector-uint-ref
       "../stdlib/core/bytevectors.scm"
       .
       71698))
   (push.const . bytevector-uint-ref)
   (push.const . "expected endianness, but got ~r, as argument 3")
   (push.iloc.0 . 2)
   (push.subr.gloc.of \x2E;format 2 "../stdlib/core/bytevectors.scm" . 74787)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.subr.gloc.of \x2E;list 4 "../stdlib/core/bytevectors.scm" . 75811)
   (apply.gloc.of \x2E;assertion-violation "../stdlib/core/bytevectors.scm" . 73742))
 (set.gloc.of core.bytevectors\x27;bytevector-sint-ref)
 (close
   (5 0 . core.bytevectors\x27;bytevector-uint-set!)
   (call
     (=n.iloc (0 . 2) 0 "../stdlib/core/bytevectors.scm" . 79886)
     (if.true
       (push.iloc.0 . 1)
       (push.iloc.0 . 4)
       (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/bytevectors.scm" . 80921)
       (extend . 1)
       (extend.enclose+
         (1 0 . loop)
         (iloc.0 . 0)
         (>=.iloc (2 . 0) "../stdlib/core/bytevectors.scm" . 82969)
         (if.true (ret.const.unspec))
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (push.const . 0)
         (subr.gloc.of \x2E;bytevector-u8-set! 3 "../stdlib/core/bytevectors.scm" . 85017)
         (push.n+.iloc (0 . 0) 1 "../stdlib/core/bytevectors.scm" . 86047)
         (apply.iloc+ (1 . 0) "../stdlib/core/bytevectors.scm" . 86041))
       (push.iloc 2 . 1)
       (apply.iloc+ (0 . 0) "../stdlib/core/bytevectors.scm" . 82962))
     (push.const . 0)
     (push.iloc.0 . 2)
     (push.const . 256)
     (push.iloc.0 . 4)
     (push.subr.gloc.of \x2E;expt 2 "../stdlib/core/bytevectors.scm" . 87063)
     (subr.gloc.of \x2E;< 3 "../stdlib/core/bytevectors.scm" . 87054)
     (if.true
       (push.iloc.0 . 3)
       (const . big)
       (if.eq?
         (extend.enclose+
           (2 0 . loop)
           (iloc.0 . 0)
           (<.iloc (2 . 1) "../stdlib/core/bytevectors.scm" . 91168)
           (if.true (ret.const.unspec))
           (push.iloc 2 . 0)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.const . 255)
           (push.subr.gloc.of \x2E;bitwise-and 2 "../stdlib/core/bytevectors.scm" . 93241)
           (subr.gloc.of \x2E;bytevector-u8-set! 3 "../stdlib/core/bytevectors.scm" . 93216)
           (push.n+.iloc (0 . 0) -1 "../stdlib/core/bytevectors.scm" . 94246)
           (push.iloc.0 . 1)
           (push.const . -8)
           (push.subr.gloc.of
             \x2E;bitwise-arithmetic-shift
             2
             "../stdlib/core/bytevectors.scm"
             .
             94254)
           (apply.iloc+ (1 . 0) "../stdlib/core/bytevectors.scm" . 94240))
         (push.iloc.1 . 1)
         (push.iloc.1 . 4)
         (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/bytevectors.scm" . 89125)
         (push.const . 1)
         (push.subr.gloc.of \x2E;- 2 "../stdlib/core/bytevectors.scm" . 89122)
         (push.iloc.1 . 2)
         (apply.iloc+ (0 . 0) "../stdlib/core/bytevectors.scm" . 91161))
       (push.iloc.0 . 3)
       (const . little)
       (if.eq?
         (push.iloc.0 . 1)
         (push.iloc.0 . 4)
         (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/bytevectors.scm" . 96288)
         (extend . 1)
         (extend.enclose+
           (2 0 . loop)
           (iloc.0 . 0)
           (>=.iloc (2 . 0) "../stdlib/core/bytevectors.scm" . 98336)
           (if.true (ret.const.unspec))
           (push.iloc 3 . 0)
           (push.iloc.0 . 0)
           (push.iloc.0 . 1)
           (push.const . 255)
           (push.subr.gloc.of \x2E;bitwise-and 2 "../stdlib/core/bytevectors.scm" . 100409)
           (subr.gloc.of \x2E;bytevector-u8-set! 3 "../stdlib/core/bytevectors.scm" . 100384)
           (push.n+.iloc (0 . 0) 1 "../stdlib/core/bytevectors.scm" . 101414)
           (push.iloc.0 . 1)
           (push.const . -8)
           (push.subr.gloc.of
             \x2E;bitwise-arithmetic-shift
             2
             "../stdlib/core/bytevectors.scm"
             .
             101422)
           (apply.iloc+ (1 . 0) "../stdlib/core/bytevectors.scm" . 101408))
         (push.iloc 2 . 1)
         (push.iloc 2 . 2)
         (apply.iloc+ (0 . 0) "../stdlib/core/bytevectors.scm" . 98329))
       (ret.const.unspec))
     (push.const . bytevector-uint-set!)
     (push.const . "value out of range, ~s as argument 3")
     (push.iloc.0 . 2)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/bytevectors.scm" . 104483)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.iloc.0 . 4)
     (push.subr.gloc.of \x2E;list 5 "../stdlib/core/bytevectors.scm" . 105507)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/bytevectors.scm" . 103438))
   (ret.const.unspec))
 (set.gloc.of core.bytevectors\x27;bytevector-uint-set!)
 (close
   (5 0 . core.bytevectors\x27;bytevector-sint-set!)
   (call
     (push.const . 2)
     (push.iloc.0 . 4)
     (push.const . 8)
     (push.subr.gloc.of \x2E;* 2 "../stdlib/core/bytevectors.scm" . 110626)
     (push.const . 1)
     (push.subr.gloc.of \x2E;- 2 "../stdlib/core/bytevectors.scm" . 110623)
     (push.subr.gloc.of \x2E;expt 2 "../stdlib/core/bytevectors.scm" . 110615)
     (extend . 1)
     (push.n+.iloc (0 . 0) 1 "../stdlib/core/bytevectors.scm" . 111642)
     (push.subr.gloc.of \x2E;- 1 "../stdlib/core/bytevectors.scm" . 111639)
     (push.iloc.1 . 2)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;< 3 "../stdlib/core/bytevectors.scm" . 112653)
     (if.true
       (>n.iloc (1 . 2) 0 "../stdlib/core/bytevectors.scm" . 113681)
       (if.true
         (push.iloc.1 . 0)
         (push.iloc.1 . 1)
         (push.iloc.1 . 2)
         (push.iloc.1 . 3)
         (push.iloc.1 . 4)
         (apply.gloc.of
           core.bytevectors\x27;bytevector-uint-set!
           "../stdlib/core/bytevectors.scm"
           .
           114705))
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (push.const . 256)
       (push.iloc.1 . 4)
       (push.subr.gloc.of \x2E;expt 2 "../stdlib/core/bytevectors.scm" . 115767)
       (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/bytevectors.scm" . 115760)
       (push.iloc.1 . 3)
       (push.iloc.1 . 4)
       (apply.gloc.of
         core.bytevectors\x27;bytevector-uint-set!
         "../stdlib/core/bytevectors.scm"
         .
         115729))
     (push.const . bytevector-sint-set!)
     (push.const . "value out of range, ~s as argument 3")
     (push.iloc.1 . 2)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/bytevectors.scm" . 117794)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.iloc.1 . 3)
     (push.iloc.1 . 4)
     (push.subr.gloc.of \x2E;list 5 "../stdlib/core/bytevectors.scm" . 118818)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/bytevectors.scm" . 116749))
   (ret.const.unspec))
 (set.gloc.of core.bytevectors\x27;bytevector-sint-set!)
 (close
   (3 0 . core.bytevectors\x27;bytevector->uint-list)
   (extend.enclose+
     (2 0 . loop)
     (>n.iloc (0 . 0) -1 "../stdlib/core/bytevectors.scm" . 124941)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 2)
       (push.subr.gloc.of \x2E;- 2 "../stdlib/core/bytevectors.scm" . 125971)
       (call
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 2)
         (apply.gloc.of
           core.bytevectors\x27;bytevector-uint-ref
           "../stdlib/core/bytevectors.scm"
           .
           125988))
       (push)
       (iloc.0 . 1)
       (push.cons)
       (apply.iloc+ (1 . 0) "../stdlib/core/bytevectors.scm" . 125965))
     (push.iloc 2 . 2)
     (subr.gloc.of \x2E;- 1 "../stdlib/core/bytevectors.scm" . 126998)
     (=.iloc (0 . 0) "../stdlib/core/bytevectors.scm" . 126993)
     (if.true (ret.iloc 0 . 1))
     (push.const . bytevector->uint-list)
     (push.const . "expected appropriate element size as argument 3, but got ~r")
     (push.iloc 2 . 2)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/bytevectors.scm" . 130086)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc 2 . 2)
     (push.subr.gloc.of \x2E;list 3 "../stdlib/core/bytevectors.scm" . 131110)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/bytevectors.scm" . 129041))
   (push.iloc.1 . 0)
   (push.subr.gloc.of \x2E;bytevector-length 1 "../stdlib/core/bytevectors.scm" . 123928)
   (push.iloc.1 . 2)
   (push.subr.gloc.of \x2E;- 2 "../stdlib/core/bytevectors.scm" . 123925)
   (push.const)
   (apply.iloc+ (0 . 0) "../stdlib/core/bytevectors.scm" . 124937))
 (set.gloc.of core.bytevectors\x27;bytevector->uint-list)
 (close
   (3 0 . core.bytevectors\x27;bytevector->sint-list)
   (extend.enclose+
     (2 0 . loop)
     (>n.iloc (0 . 0) -1 "../stdlib/core/bytevectors.scm" . 136205)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc 2 . 2)
       (push.subr.gloc.of \x2E;- 2 "../stdlib/core/bytevectors.scm" . 137235)
       (call
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 2)
         (apply.gloc.of
           core.bytevectors\x27;bytevector-sint-ref
           "../stdlib/core/bytevectors.scm"
           .
           137252))
       (push)
       (iloc.0 . 1)
       (push.cons)
       (apply.iloc+ (1 . 0) "../stdlib/core/bytevectors.scm" . 137229))
     (push.iloc 2 . 2)
     (subr.gloc.of \x2E;- 1 "../stdlib/core/bytevectors.scm" . 138262)
     (=.iloc (0 . 0) "../stdlib/core/bytevectors.scm" . 138257)
     (if.true (ret.iloc 0 . 1))
     (push.const . bytevector->sint-list)
     (push.const . "expected appropriate element size as argument 3, but got ~r")
     (push.iloc 2 . 2)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/bytevectors.scm" . 141350)
     (push.iloc 2 . 0)
     (push.iloc 2 . 1)
     (push.iloc 2 . 2)
     (push.subr.gloc.of \x2E;list 3 "../stdlib/core/bytevectors.scm" . 142374)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/bytevectors.scm" . 140305))
   (push.iloc.1 . 0)
   (push.subr.gloc.of \x2E;bytevector-length 1 "../stdlib/core/bytevectors.scm" . 135192)
   (push.iloc.1 . 2)
   (push.subr.gloc.of \x2E;- 2 "../stdlib/core/bytevectors.scm" . 135189)
   (push.const)
   (apply.iloc+ (0 . 0) "../stdlib/core/bytevectors.scm" . 136201))
 (set.gloc.of core.bytevectors\x27;bytevector->sint-list)
 (close
   (3 0 . core.bytevectors\x27;uint-list->bytevector)
   (push.iloc.0 . 2)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;length 1 "../stdlib/core/bytevectors.scm" . 146474)
   (push.subr.gloc.of \x2E;* 2 "../stdlib/core/bytevectors.scm" . 146466)
   (push.subr.gloc.of \x2E;make-bytevector 1 "../stdlib/core/bytevectors.scm" . 146449)
   (extend . 1)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 1)
     (if.null? (ret.iloc 2 . 0))
     (call
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.car.iloc (0 . 1) "../stdlib/core/bytevectors.scm" . 150573)
       (push.iloc 3 . 1)
       (push.iloc 3 . 2)
       (apply.gloc.of
         core.bytevectors\x27;bytevector-uint-set!
         "../stdlib/core/bytevectors.scm"
         .
         150546))
     (push.iloc.0 . 0)
     (push.iloc 3 . 2)
     (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/bytevectors.scm" . 151576)
     (push.cdr.iloc (0 . 1) "../stdlib/core/bytevectors.scm" . 151587)
     (apply.iloc+ (1 . 0) "../stdlib/core/bytevectors.scm" . 151570))
   (push.const . 0)
   (push.iloc 2 . 0)
   (apply.iloc+ (0 . 0) "../stdlib/core/bytevectors.scm" . 148491))
 (set.gloc.of core.bytevectors\x27;uint-list->bytevector)
 (close
   (3 0 . core.bytevectors\x27;sint-list->bytevector)
   (push.iloc.0 . 2)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;length 1 "../stdlib/core/bytevectors.scm" . 155690)
   (push.subr.gloc.of \x2E;* 2 "../stdlib/core/bytevectors.scm" . 155682)
   (push.subr.gloc.of \x2E;make-bytevector 1 "../stdlib/core/bytevectors.scm" . 155665)
   (extend . 1)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 1)
     (if.null? (ret.iloc 2 . 0))
     (call
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.car.iloc (0 . 1) "../stdlib/core/bytevectors.scm" . 159789)
       (push.iloc 3 . 1)
       (push.iloc 3 . 2)
       (apply.gloc.of
         core.bytevectors\x27;bytevector-sint-set!
         "../stdlib/core/bytevectors.scm"
         .
         159762))
     (push.iloc.0 . 0)
     (push.iloc 3 . 2)
     (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/bytevectors.scm" . 160792)
     (push.cdr.iloc (0 . 1) "../stdlib/core/bytevectors.scm" . 160803)
     (apply.iloc+ (1 . 0) "../stdlib/core/bytevectors.scm" . 160786))
   (push.const . 0)
   (push.iloc 2 . 0)
   (apply.iloc+ (0 . 0) "../stdlib/core/bytevectors.scm" . 157707))
 (set.gloc.of core.bytevectors\x27;sint-list->bytevector)
 (call
   (push.const
     (x unbound)
     (little unbound)
     (endianness import . core.bytevectors\x27;endianness)
     (div256 import . core.bytevectors\x27;div256)
     (_ import . \x2E;_)
     (bitwise-arithmetic-shift import . \x2E;bitwise-arithmetic-shift)
     (bitwise-and import . \x2E;bitwise-and)
     (quote import . \x2E;quote)
     (native unbound)
     (mod256 import . core.bytevectors\x27;mod256)
     (native-endianness import . \x2E;native-endianness)
     (big unbound))
   (extend . 1)
   (call
     (push.const . syntax)
     (push.const . core.bytevectors\x27;div256)
     (push.const
       ()
       ("../stdlib/core/bytevectors.scm" . 30725)
       ((_ x) (bitwise-arithmetic-shift x -8) ((x . 0)) (bitwise-arithmetic-shift)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/bytevectors.scm" . 6145))
   (call
     (push.const . syntax)
     (push.const . core.bytevectors\x27;mod256)
     (push.const
       ()
       ("../stdlib/core/bytevectors.scm" . 34821)
       ((_ x) (bitwise-and x 255) ((x . 0)) (bitwise-and)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/bytevectors.scm" . 6145))
   (push.const . syntax)
   (push.const . core.bytevectors\x27;endianness)
   (push.const
     (big little native)
     ("../stdlib/core/bytevectors.scm" . 38917)
     ((_ big) 'big () (big quote))
     ((_ little) 'little () (little quote))
     ((_ native) (native-endianness) () (native-endianness)))
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/bytevectors.scm" . 6145))
 (push.const . core.bytevectors)
 (push.const . #f)
 (push.const
   (endianness import . core.bytevectors\x27;endianness)
   (native-endianness import . \x2E;native-endianness)
   (bytevector? import . \x2E;bytevector?)
   (make-bytevector import . \x2E;make-bytevector)
   (bytevector-length import . \x2E;bytevector-length)
   (bytevector=? import . \x2E;bytevector=?)
   (bytevector-fill! import . \x2E;bytevector-fill!)
   (bytevector-copy! import . \x2E;bytevector-copy!)
   (bytevector-copy import . \x2E;bytevector-copy)
   (bytevector-u8-ref import . \x2E;bytevector-u8-ref)
   (bytevector-s8-ref import . \x2E;bytevector-s8-ref)
   (bytevector-u8-set! import . \x2E;bytevector-u8-set!)
   (bytevector-s8-set! import . \x2E;bytevector-s8-set!)
   (bytevector->u8-list import . \x2E;bytevector->u8-list)
   (u8-list->bytevector import . \x2E;u8-list->bytevector)
   (bytevector-uint-ref import . core.bytevectors\x27;bytevector-uint-ref)
   (bytevector-sint-ref import . core.bytevectors\x27;bytevector-sint-ref)
   (bytevector-uint-set! import . core.bytevectors\x27;bytevector-uint-set!)
   (bytevector-sint-set! import . core.bytevectors\x27;bytevector-sint-set!)
   (bytevector->uint-list import . core.bytevectors\x27;bytevector->uint-list)
   (bytevector->sint-list import . core.bytevectors\x27;bytevector->sint-list)
   (uint-list->bytevector import . core.bytevectors\x27;uint-list->bytevector)
   (sint-list->bytevector import . core.bytevectors\x27;sint-list->bytevector)
   (bytevector-u16-ref import . \x2E;bytevector-u16-ref)
   (bytevector-s16-ref import . \x2E;bytevector-s16-ref)
   (bytevector-u16-native-ref import . \x2E;bytevector-u16-native-ref)
   (bytevector-s16-native-ref import . \x2E;bytevector-s16-native-ref)
   (bytevector-u16-set! import . \x2E;bytevector-u16-set!)
   (bytevector-s16-set! import . \x2E;bytevector-s16-set!)
   (bytevector-u16-native-set! import . \x2E;bytevector-u16-native-set!)
   (bytevector-s16-native-set! import . \x2E;bytevector-s16-native-set!)
   (bytevector-u32-ref import . \x2E;bytevector-u32-ref)
   (bytevector-s32-ref import . \x2E;bytevector-s32-ref)
   (bytevector-u32-native-ref import . \x2E;bytevector-u32-native-ref)
   (bytevector-s32-native-ref import . \x2E;bytevector-s32-native-ref)
   (bytevector-u32-set! import . \x2E;bytevector-u32-set!)
   (bytevector-s32-set! import . \x2E;bytevector-s32-set!)
   (bytevector-u32-native-set! import . \x2E;bytevector-u32-native-set!)
   (bytevector-s32-native-set! import . \x2E;bytevector-s32-native-set!)
   (bytevector-u64-ref import . \x2E;bytevector-u64-ref)
   (bytevector-s64-ref import . \x2E;bytevector-s64-ref)
   (bytevector-u64-native-ref import . \x2E;bytevector-u64-native-ref)
   (bytevector-s64-native-ref import . \x2E;bytevector-s64-native-ref)
   (bytevector-u64-set! import . \x2E;bytevector-u64-set!)
   (bytevector-s64-set! import . \x2E;bytevector-s64-set!)
   (bytevector-u64-native-set! import . \x2E;bytevector-u64-native-set!)
   (bytevector-s64-native-set! import . \x2E;bytevector-s64-native-set!)
   (bytevector-ieee-single-ref import . \x2E;bytevector-ieee-single-ref)
   (bytevector-ieee-single-native-ref import . \x2E;bytevector-ieee-single-native-ref)
   (bytevector-ieee-single-set! import . \x2E;bytevector-ieee-single-set!)
   (bytevector-ieee-single-native-set! import . \x2E;bytevector-ieee-single-native-set!)
   (bytevector-ieee-double-ref import . \x2E;bytevector-ieee-double-ref)
   (bytevector-ieee-double-native-ref import . \x2E;bytevector-ieee-double-native-ref)
   (bytevector-ieee-double-set! import . \x2E;bytevector-ieee-double-set!)
   (bytevector-ieee-double-native-set! import . \x2E;bytevector-ieee-double-native-set!))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/bytevectors.scm" . 6145))

((close
   (1 0)
   (push.iloc.0 . 0)
   (push.const unsyntax-splicing . d)
   (push.const (d . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 150557))
 (set.gloc.of \x2E;L126)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const ((b ...) b*) (x xnew))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 150557))
 (set.gloc.of \x2E;L104)
 (close
   (2 0 . same?)
   (iloc.0 . 0)
   (if.null? (iloc.0 . 1) (ret.null? "../stdlib/core/syntax-case.scm" . 151585))
   (iloc.0 . 1)
   (if.null?.ret.const . #f)
   (push.car.iloc (0 . 0) "../stdlib/core/syntax-case.scm" . 153643)
   (car.iloc (0 . 1) "../stdlib/core/syntax-case.scm" . 153652)
   (if.not.eq?.ret.const . #f)
   (touch.gloc.of same?\x60;472*)
   (push.cdr.iloc (0 . 0) "../stdlib/core/syntax-case.scm" . 154669)
   (push.cdr.iloc (0 . 1) "../stdlib/core/syntax-case.scm" . 154678)
   (apply.gloc.of same?\x60;472* "../stdlib/core/syntax-case.scm" . 154662))
 (set.gloc.of same?\x60;472*)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const (d dnew))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 124946))
 (set.gloc.of \x2E;L122)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const ((x ...) xnew*))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 150557))
 (set.gloc.of \x2E;L106)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const (((m ...) ...) (syntax ((t (... ...)) ...))))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 132114))
 (set.gloc.of \x2E;L103)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const unsyntax . d)
   (push.const (d . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 150557))
 (set.gloc.of \x2E;L128)
 (close
   (4 0 . qs)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const quasisyntax unsyntax unsyntax-splicing)
   (push.const quasisyntax . d)
   (push.const . #f)
   (push.close
     (1 0)
     (touch.gloc.of qs\x60;365*)
     (call
       (push.iloc.0 . 0)
       (push.const . d)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/syntax-case.scm" . 94220))
     (push)
     (push.n+.iloc (1 . 1) 1 "../stdlib/core/syntax-case.scm" . 94228)
     (push.iloc.1 . 2)
     (push.close
       (2 0)
       (push.iloc.0 . 0)
       (call
         (push.iloc.0 . 1)
         (call
           (push.iloc.1 . 0)
           (push.const . d)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/syntax-case.scm" . 97305))
         (if.eq? (ret.iloc 2 . 0))
         (push.iloc.1 . 0)
         (push.iloc.0 . 1)
         (push.subr.gloc.of \x2E;list 1 "../stdlib/core/syntax-case.scm" . 150557)
         (push.const)
         (push.const d)
         (push.const . #f)
         (push.gloc.of \x2E;L115)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 150557)
         (push.const . _)
         (push.const . #f)
         (push.gloc.of \x2E;L105)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 150557)
         (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 150557))
       (push)
       (apply.iloc (2 . 3) "../stdlib/core/syntax-case.scm" . 97305))
     (apply.gloc.of qs\x60;365* "../stdlib/core/syntax-case.scm" . 94220))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 92169)
   (push.const unsyntax . d)
   (push.close
     (1 0)
     (push.iloc.1 . 1)
     (push.const . 0)
     (push.subr.gloc.of \x2E;= 2 "../stdlib/core/syntax-case.scm" . 101393)
     (ret.subr.gloc.of \x2E;not "../stdlib/core/syntax-case.scm" . 101388))
   (push.close
     (1 0)
     (touch.gloc.of qs\x60;365*)
     (call
       (push.iloc.0 . 0)
       (push.const . d)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/syntax-case.scm" . 102412))
     (push)
     (push.n+.iloc (1 . 1) -1 "../stdlib/core/syntax-case.scm" . 102420)
     (push.iloc.1 . 2)
     (push.close
       (2 0)
       (push.iloc.0 . 0)
       (call
         (push.iloc.0 . 1)
         (call
           (push.iloc.1 . 0)
           (push.const . d)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/syntax-case.scm" . 105497))
         (if.eq? (ret.iloc 2 . 0))
         (push.iloc.1 . 0)
         (push.iloc.0 . 1)
         (push.subr.gloc.of \x2E;list 1 "../stdlib/core/syntax-case.scm" . 150557)
         (push.const)
         (push.const d)
         (push.const . #f)
         (push.gloc.of \x2E;L128)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 150557)
         (push.const . _)
         (push.const . #f)
         (push.gloc.of \x2E;L109)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 150557)
         (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 150557))
       (push)
       (apply.iloc (2 . 3) "../stdlib/core/syntax-case.scm" . 105497))
     (apply.gloc.of qs\x60;365* "../stdlib/core/syntax-case.scm" . 102412))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 92169)
   (push.const unsyntax-splicing . d)
   (push.close
     (1 0)
     (push.iloc.1 . 1)
     (push.const . 0)
     (push.subr.gloc.of \x2E;= 2 "../stdlib/core/syntax-case.scm" . 109585)
     (ret.subr.gloc.of \x2E;not "../stdlib/core/syntax-case.scm" . 109580))
   (push.close
     (1 0)
     (touch.gloc.of qs\x60;365*)
     (call
       (push.iloc.0 . 0)
       (push.const . d)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/syntax-case.scm" . 110604))
     (push)
     (push.n+.iloc (1 . 1) -1 "../stdlib/core/syntax-case.scm" . 110612)
     (push.iloc.1 . 2)
     (push.close
       (2 0)
       (push.iloc.0 . 0)
       (call
         (push.iloc.0 . 1)
         (call
           (push.iloc.1 . 0)
           (push.const . d)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/syntax-case.scm" . 113689))
         (if.eq? (ret.iloc 2 . 0))
         (push.iloc.1 . 0)
         (push.iloc.0 . 1)
         (push.subr.gloc.of \x2E;list 1 "../stdlib/core/syntax-case.scm" . 150557)
         (push.const)
         (push.const d)
         (push.const . #f)
         (push.gloc.of \x2E;L126)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 150557)
         (push.const . _)
         (push.const . #f)
         (push.gloc.of \x2E;L118)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 150557)
         (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 150557))
       (push)
       (apply.iloc (2 . 3) "../stdlib/core/syntax-case.scm" . 113689))
     (apply.gloc.of qs\x60;365* "../stdlib/core/syntax-case.scm" . 110604))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 92169)
   (push.const unsyntax q)
   (push.close
     (1 0)
     (push.iloc.1 . 1)
     (push.const . 0)
     (ret.subr.gloc.of \x2E;= "../stdlib/core/syntax-case.scm" . 117772))
   (push.close
     (1 0)
     (push.iloc.0 . 0)
     (call
       (call
         (push.iloc.0 . 0)
         (push.const q)
         (push.const (q . 0))
         (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 118796))
       (push)
       (apply.gloc.of \x2E;generate-temporaries "../stdlib/core/syntax-case.scm" . 118796))
     (push)
     (push.subr.gloc.of \x2E;list 1 "../stdlib/core/syntax-case.scm" . 118796)
     (push.const)
     (push.const (t))
     (push.const . #f)
     (push.close
       (1 0)
       (call
         (push.iloc.0 . 0)
         (push.const t q)
         (push.const (q . 0) (t . 0))
         (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 118796))
       (push)
       (iloc 2 . 2)
       (push.cons)
       (call
         (push.iloc.0 . 0)
         (push.const . t)
         (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/syntax-case.scm" . 118796))
       (push)
       (apply.iloc (2 . 3) "../stdlib/core/syntax-case.scm" . 118796))
     (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 118796)
     (push.const . _)
     (push.const . #f)
     (push.gloc.of \x2E;L137)
     (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 118796)
     (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 118796))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 92169)
   (push.const (unsyntax q ...) . d)
   (push.close
     (1 0)
     (push.iloc.1 . 1)
     (push.const . 0)
     (ret.subr.gloc.of \x2E;= "../stdlib/core/syntax-case.scm" . 121868))
   (push.close
     (1 0)
     (touch.gloc.of qs\x60;365*)
     (call
       (push.iloc.0 . 0)
       (push.const . d)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/syntax-case.scm" . 122892))
     (push)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.close
       (2 0)
       (push.iloc.1 . 0)
       (call
         (call
           (push.iloc.1 . 0)
           (push.const q ...)
           (push.const (q . 1))
           (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 124946))
         (push)
         (apply.gloc.of \x2E;generate-temporaries "../stdlib/core/syntax-case.scm" . 124946))
       (push)
       (push.subr.gloc.of \x2E;list 1 "../stdlib/core/syntax-case.scm" . 124946)
       (push.const)
       (push.const (t ...))
       (push.const . #f)
       (push.close
         (1 0)
         (call
           (push.iloc.0 . 0)
           (push.const (t q) ...)
           (push.const (q . 1) (t . 1))
           (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 124946))
         (push)
         (push.iloc.1 . 0)
         (push.subr.gloc.of \x2E;append 2 "../stdlib/core/syntax-case.scm" . 124946)
         (call
           (push.iloc.0 . 0)
           (push.iloc.1 . 1)
           (push.subr.gloc.of \x2E;list 1 "../stdlib/core/syntax-case.scm" . 124946)
           (push.const)
           (push.const d)
           (push.const . #f)
           (push.gloc.of \x2E;L132)
           (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 124946)
           (push.const . _)
           (push.const . #f)
           (push.gloc.of \x2E;L122)
           (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 124946)
           (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 124946))
         (push)
         (apply.iloc (3 . 3) "../stdlib/core/syntax-case.scm" . 124946))
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 124946)
       (push.const . _)
       (push.const . #f)
       (push.gloc.of \x2E;L129)
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 124946)
       (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 124946))
     (apply.gloc.of qs\x60;365* "../stdlib/core/syntax-case.scm" . 122892))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 92169)
   (push.const (unsyntax-splicing q ...) . d)
   (push.close
     (1 0)
     (push.iloc.1 . 1)
     (push.const . 0)
     (ret.subr.gloc.of \x2E;= "../stdlib/core/syntax-case.scm" . 129036))
   (push.close
     (1 0)
     (touch.gloc.of qs\x60;365*)
     (call
       (push.iloc.0 . 0)
       (push.const . d)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/syntax-case.scm" . 130060))
     (push)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.close
       (2 0)
       (push.iloc.1 . 0)
       (call
         (call
           (push.iloc.1 . 0)
           (push.const q ...)
           (push.const (q . 1))
           (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 132114))
         (push)
         (apply.gloc.of \x2E;generate-temporaries "../stdlib/core/syntax-case.scm" . 132114))
       (push)
       (push.subr.gloc.of \x2E;list 1 "../stdlib/core/syntax-case.scm" . 132114)
       (push.const)
       (push.const (t ...))
       (push.const . #f)
       (push.close
         (1 0)
         (call
           (push.iloc.0 . 0)
           (push.const ((t (... ...)) q) ...)
           (push.const (q . 1) (t . 1))
           (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 132114))
         (push)
         (push.iloc.1 . 0)
         (push.subr.gloc.of \x2E;append 2 "../stdlib/core/syntax-case.scm" . 132114)
         (call
           (push.iloc.0 . 0)
           (call
             (push.iloc.0 . 0)
             (push.const (t (... ...)) ...)
             (push.const (t . 1))
             (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 132114))
           (push)
           (push.subr.gloc.of \x2E;list 1 "../stdlib/core/syntax-case.scm" . 132114)
           (push.const)
           (push.const ((m ...) ...))
           (push.const . #f)
           (push.close
             (1 0)
             (push.iloc.0 . 0)
             (push.iloc 2 . 1)
             (push.subr.gloc.of \x2E;list 1 "../stdlib/core/syntax-case.scm" . 132114)
             (push.const)
             (push.const d)
             (push.const . #f)
             (push.gloc.of \x2E;L108)
             (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 132114)
             (push.const . _)
             (push.const . #f)
             (push.gloc.of \x2E;L116)
             (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 132114)
             (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 132114))
           (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 132114)
           (push.const . _)
           (push.const . #f)
           (push.gloc.of \x2E;L103)
           (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 132114)
           (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 132114))
         (push)
         (apply.iloc (3 . 3) "../stdlib/core/syntax-case.scm" . 132114))
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 132114)
       (push.const . _)
       (push.const . #f)
       (push.gloc.of \x2E;L111)
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 132114)
       (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 132114))
     (apply.gloc.of qs\x60;365* "../stdlib/core/syntax-case.scm" . 130060))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 92169)
   (push.const a . d)
   (push.const . #f)
   (push.close
     (1 0)
     (touch.gloc.of qs\x60;365*)
     (call
       (push.iloc.0 . 0)
       (push.const . a)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/syntax-case.scm" . 137228))
     (push)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.close
       (2 0)
       (touch.gloc.of qs\x60;365*)
       (call
         (push.iloc.1 . 0)
         (push.const . d)
         (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/syntax-case.scm" . 139282))
       (push)
       (push.iloc 2 . 1)
       (push.iloc.0 . 0)
       (push.close
         (2 0)
         (push.iloc.0 . 0)
         (call
           (call
             (push.iloc.1 . 1)
             (call
               (push.iloc 2 . 0)
               (push.const . a)
               (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/syntax-case.scm" . 142372))
             (if.not.eq?.ret.const . #f)
             (push.iloc.0 . 1)
             (call
               (push.iloc 2 . 0)
               (push.const . d)
               (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/syntax-case.scm" . 142387))
             (ret.eq? "../stdlib/core/syntax-case.scm" . 142387))
           (if.true (ret.iloc 3 . 0))
           (push.iloc 2 . 0)
           (push.iloc.1 . 1)
           (push.iloc.0 . 1)
           (push.subr.gloc.of \x2E;list 2 "../stdlib/core/syntax-case.scm" . 150557)
           (push.const)
           (push.const a d)
           (push.const . #f)
           (push.gloc.of \x2E;L133)
           (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 150557)
           (push.const . _)
           (push.const . #f)
           (push.gloc.of \x2E;L114)
           (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 150557)
           (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 150557))
         (push)
         (apply.iloc (3 . 3) "../stdlib/core/syntax-case.scm" . 142367))
       (apply.gloc.of qs\x60;365* "../stdlib/core/syntax-case.scm" . 139282))
     (apply.gloc.of qs\x60;365* "../stdlib/core/syntax-case.scm" . 137228))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 92169)
   (push.const . #(x ...))
   (push.const . #f)
   (push.close
     (1 0)
     (touch.gloc.of vqs\x60;365*)
     (call
       (push.iloc.0 . 0)
       (push.const x ...)
       (push.const (x . 1))
       (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 146445))
     (push)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.close
       (2 0)
       (push.iloc.0 . 0)
       (call
         (call
           (touch.gloc.of same?\x60;472*)
           (call
             (push.iloc.1 . 0)
             (push.const x ...)
             (push.const (x . 1))
             (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 149543))
           (push)
           (push.iloc.0 . 1)
           (apply.gloc.of same?\x60;472* "../stdlib/core/syntax-case.scm" . 150557))
         (if.true (ret.iloc 2 . 0))
         (push.iloc.1 . 0)
         (push.iloc.0 . 1)
         (push.subr.gloc.of \x2E;list 1 "../stdlib/core/syntax-case.scm" . 150557)
         (push.const)
         (push.const (x ...))
         (push.const . #f)
         (push.gloc.of \x2E;L131)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 150557)
         (push.const . _)
         (push.const . #f)
         (push.gloc.of \x2E;L106)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 150557)
         (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 150557))
       (push)
       (apply.iloc
         (2 . 3)
         (k\x60;366*
           b*\x60;468*
           (if (same?\x60;472*
                 (\x2E;syntax/c1n \x2E;vars\x60;466* '(x ...) '((x . 1)))
                 xnew*\x60;468*)
               q\x60;366*
               (\x2E;syntax-dispatch
                 \x2E;vars\x60;466*
                 (\x2E;list xnew*\x60;468*)
                 '()
                 (\x2E;list '((x ...)) #f \x2E;L131)
                 (\x2E;list '_ #f \x2E;L106))))))
     (apply.gloc.of
       vqs\x60;365*
       (vqs\x60;365*
         (\x2E;syntax/c1n \x2E;vars\x60;466* '(x ...) '((x . 1)))
         n\x60;366*
         b*\x60;366*
         (lambda (b*\x60;468* xnew*\x60;468*)
           (k\x60;366*
             b*\x60;468*
             (if (same?\x60;472*
                   (\x2E;syntax/c1n \x2E;vars\x60;466* '(x ...) '((x . 1)))
                   xnew*\x60;468*)
                 q\x60;366*
                 (\x2E;syntax-dispatch
                   \x2E;vars\x60;466*
                   (\x2E;list xnew*\x60;468*)
                   '()
                   (\x2E;list '((x ...)) #f \x2E;L131)
                   (\x2E;list '_ #f \x2E;L106))))))))
   (push.subr.gloc.of
     \x2E;list
     3
     (\x2E;list
       '#(x ...)
       #f
       (lambda (\x2E;vars\x60;466*)
         (vqs\x60;365*
           (\x2E;syntax/c1n \x2E;vars\x60;466* '(x ...) '((x . 1)))
           n\x60;366*
           b*\x60;366*
           (lambda (b*\x60;468* xnew*\x60;468*)
             (k\x60;366*
               b*\x60;468*
               (if (same?\x60;472*
                     (\x2E;syntax/c1n \x2E;vars\x60;466* '(x ...) '((x . 1)))
                     xnew*\x60;468*)
                   q\x60;366*
                   (\x2E;syntax-dispatch
                     \x2E;vars\x60;466*
                     (\x2E;list xnew*\x60;468*)
                     '()
                     (\x2E;list '((x ...)) #f \x2E;L131)
                     (\x2E;list '_ #f \x2E;L106)))))))))
   (push.const . _)
   (push.const . #f)
   (push.close
     (1 0)
     (push.iloc.1 . 2)
     (push.iloc.1 . 0)
     (apply.iloc (1 . 3) "../stdlib/core/syntax-case.scm" . 157710))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 92169)
   (apply.gloc.of
     \x2E;syntax-dispatch
     (\x2E;syntax-dispatch
       \x2E;vars
       q\x60;366*
       '(quasisyntax unsyntax unsyntax-splicing)
       (\x2E;list
         '(quasisyntax . d)
         #f
         (lambda (\x2E;vars\x60;368*)
           (qs\x60;365*
             (\x2E;syntax/i1n \x2E;vars\x60;368* 'd)
             (\x2E;+ n\x60;366* 1)
             b*\x60;366*
             (lambda (b*\x60;370* dnew\x60;370*)
               (k\x60;366*
                 b*\x60;370*
                 (if (\x2E;eq? dnew\x60;370* (\x2E;syntax/i1n \x2E;vars\x60;368* 'd))
                     q\x60;366*
                     (\x2E;syntax-dispatch
                       \x2E;vars\x60;368*
                       (\x2E;list dnew\x60;370*)
                       '()
                       (\x2E;list '(d) #f \x2E;L115)
                       (\x2E;list '_ #f \x2E;L105))))))))
       (\x2E;list
         '(unsyntax . d)
         (lambda (\x2E;vars\x60;378*) (\x2E;not (\x2E;= n\x60;366* 0)))
         (lambda (\x2E;vars\x60;380*)
           (qs\x60;365*
             (\x2E;syntax/i1n \x2E;vars\x60;380* 'd)
             (\x2E;- n\x60;366* 1)
             b*\x60;366*
             (lambda (b*\x60;382* dnew\x60;382*)
               (k\x60;366*
                 b*\x60;382*
                 (if (\x2E;eq? dnew\x60;382* (\x2E;syntax/i1n \x2E;vars\x60;380* 'd))
                     q\x60;366*
                     (\x2E;syntax-dispatch
                       \x2E;vars\x60;380*
                       (\x2E;list dnew\x60;382*)
                       '()
                       (\x2E;list '(d) #f \x2E;L128)
                       (\x2E;list '_ #f \x2E;L109))))))))
       (\x2E;list
         '(unsyntax-splicing . d)
         (lambda (\x2E;vars\x60;390*) (\x2E;not (\x2E;= n\x60;366* 0)))
         (lambda (\x2E;vars\x60;392*)
           (qs\x60;365*
             (\x2E;syntax/i1n \x2E;vars\x60;392* 'd)
             (\x2E;- n\x60;366* 1)
             b*\x60;366*
             (lambda (b*\x60;394* dnew\x60;394*)
               (k\x60;366*
                 b*\x60;394*
                 (if (\x2E;eq? dnew\x60;394* (\x2E;syntax/i1n \x2E;vars\x60;392* 'd))
                     q\x60;366*
                     (\x2E;syntax-dispatch
                       \x2E;vars\x60;392*
                       (\x2E;list dnew\x60;394*)
                       '()
                       (\x2E;list '(d) #f \x2E;L126)
                       (\x2E;list '_ #f \x2E;L118))))))))
       (\x2E;list
         '(unsyntax q)
         (lambda (\x2E;vars\x60;402*) (\x2E;= n\x60;366* 0))
         (lambda (\x2E;vars\x60;404*)
           (\x2E;syntax-dispatch
             \x2E;vars\x60;404*
             (\x2E;list
               (\x2E;generate-temporaries (\x2E;syntax/c1n \x2E;vars\x60;404* '(q) '((q . 0)))))
             '()
             (\x2E;list
               '((t))
               #f
               (lambda (\x2E;vars\x60;407*)
                 (k\x60;366*
                   (\x2E;cons
                     (\x2E;syntax/c1n \x2E;vars\x60;407* '(t q) '((q . 0) (t . 0)))
                     b*\x60;366*)
                   (\x2E;syntax/i1n \x2E;vars\x60;407* 't))))
             (\x2E;list '_ #f \x2E;L137))))
       (\x2E;list
         '((unsyntax q ...) . d)
         (lambda (\x2E;vars\x60;412*) (\x2E;= n\x60;366* 0))
         (lambda (\x2E;vars\x60;414*)
           (qs\x60;365*
             (\x2E;syntax/i1n \x2E;vars\x60;414* 'd)
             n\x60;366*
             b*\x60;366*
             (lambda (b*\x60;416* dnew\x60;416*)
               (\x2E;syntax-dispatch
                 \x2E;vars\x60;414*
                 (\x2E;list
                   (\x2E;generate-temporaries
                     (\x2E;syntax/c1n \x2E;vars\x60;414* '(q ...) '((q . 1)))))
                 '()
                 (\x2E;list
                   '((t ...))
                   #f
                   (lambda (\x2E;vars\x60;419*)
                     (k\x60;366*
                       (\x2E;append
                         (\x2E;syntax/c1n \x2E;vars\x60;419* '((t q) ...) '((q . 1) (t . 1)))
                         b*\x60;416*)
                       (\x2E;syntax-dispatch
                         \x2E;vars\x60;419*
                         (\x2E;list dnew\x60;416*)
                         '()
                         (\x2E;list '(d) #f \x2E;L132)
                         (\x2E;list '_ #f \x2E;L122)))))
                 (\x2E;list '_ #f \x2E;L129))))))
       (\x2E;list
         '((unsyntax-splicing q ...) . d)
         (lambda (\x2E;vars\x60;430*) (\x2E;= n\x60;366* 0))
         (lambda (\x2E;vars\x60;432*)
           (qs\x60;365*
             (\x2E;syntax/i1n \x2E;vars\x60;432* 'd)
             n\x60;366*
             b*\x60;366*
             (lambda (b*\x60;434* dnew\x60;434*)
               (\x2E;syntax-dispatch
                 \x2E;vars\x60;432*
                 (\x2E;list
                   (\x2E;generate-temporaries
                     (\x2E;syntax/c1n \x2E;vars\x60;432* '(q ...) '((q . 1)))))
                 '()
                 (\x2E;list
                   '((t ...))
                   #f
                   (lambda (\x2E;vars\x60;437*)
                     (k\x60;366*
                       (\x2E;append
                         (\x2E;syntax/c1n
                           \x2E;vars\x60;437*
                           '(((t (... ...)) q) ...)
                           '((q . 1) (t . 1)))
                         b*\x60;434*)
                       (\x2E;syntax-dispatch
                         \x2E;vars\x60;437*
                         (\x2E;list
                           (\x2E;syntax/c1n \x2E;vars\x60;437* '((t (... ...)) ...) '((t . 1))))
                         '()
                         (\x2E;list
                           '(((m ...) ...))
                           #f
                           (lambda (\x2E;vars\x60;441*)
                             (\x2E;syntax-dispatch
                               \x2E;vars\x60;441*
                               (\x2E;list dnew\x60;434*)
                               '()
                               (\x2E;list '(d) #f \x2E;L108)
                               (\x2E;list '_ #f \x2E;L116))))
                         (\x2E;list '_ #f \x2E;L103)))))
                 (\x2E;list '_ #f \x2E;L111))))))
       (\x2E;list
         '(a . d)
         #f
         (lambda (\x2E;vars\x60;454*)
           (qs\x60;365*
             (\x2E;syntax/i1n \x2E;vars\x60;454* 'a)
             n\x60;366*
             b*\x60;366*
             (lambda (b*\x60;456* anew\x60;456*)
               (qs\x60;365*
                 (\x2E;syntax/i1n \x2E;vars\x60;454* 'd)
                 n\x60;366*
                 b*\x60;456*
                 (lambda (b*\x60;458* dnew\x60;458*)
                   (k\x60;366*
                     b*\x60;458*
                     (if (and (\x2E;eq? anew\x60;456* (\x2E;syntax/i1n \x2E;vars\x60;454* 'a))
                              (\x2E;eq? dnew\x60;458* (\x2E;syntax/i1n \x2E;vars\x60;454* 'd)))
                         q\x60;366*
                         (\x2E;syntax-dispatch
                           \x2E;vars\x60;454*
                           (\x2E;list anew\x60;456* dnew\x60;458*)
                           '()
                           (\x2E;list '(a d) #f \x2E;L133)
                           (\x2E;list '_ #f \x2E;L114))))))))))
       (\x2E;list
         '#(x ...)
         #f
         (lambda (\x2E;vars\x60;466*)
           (vqs\x60;365*
             (\x2E;syntax/c1n \x2E;vars\x60;466* '(x ...) '((x . 1)))
             n\x60;366*
             b*\x60;366*
             (lambda (b*\x60;468* xnew*\x60;468*)
               (k\x60;366*
                 b*\x60;468*
                 (if (same?\x60;472*
                       (\x2E;syntax/c1n \x2E;vars\x60;466* '(x ...) '((x . 1)))
                       xnew*\x60;468*)
                     q\x60;366*
                     (\x2E;syntax-dispatch
                       \x2E;vars\x60;466*
                       (\x2E;list xnew*\x60;468*)
                       '()
                       (\x2E;list '((x ...)) #f \x2E;L131)
                       (\x2E;list '_ #f \x2E;L106))))))))
       (\x2E;list '_ #f (lambda (\x2E;vars\x60;482*) (k\x60;366* b*\x60;366* q\x60;366*))))))
 (set.gloc.of qs\x60;365*)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const t ... . d)
   (push.const (d . 0) (t . 1))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 124946))
 (set.gloc.of \x2E;L132)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const (d dnew))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 150557))
 (set.gloc.of \x2E;L109)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const quasisyntax . d)
   (push.const (d . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 150557))
 (set.gloc.of \x2E;L115)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const (d dnew))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 150557))
 (set.gloc.of \x2E;L105)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const (d dnew))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 132114))
 (set.gloc.of \x2E;L116)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const
     define-syntax
     name
     (let ((define-macro-transformer body))
       (lambda (x)
         (syntax-case x
           ()
           ((e0 . e1)
            (datum->syntax
              (syntax e0)
              (apply define-macro-transformer (syntax->datum (syntax e1)))))))))
   (push.const (body . 0) (name . 0))
   (push.const (x . x\x60;354*))
   (apply.gloc.of \x2E;syntax/c3n "../stdlib/core/syntax-case.scm" . 53257))
 (set.gloc.of \x2E;L110)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const (a anew) (d dnew))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 150557))
 (set.gloc.of \x2E;L114)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const with-syntax (b ...) (syntax x))
   (push.const (x . 0) (b . 1))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 150557))
 (set.gloc.of \x2E;L123)
 (close
   (1 0)
   (push.const . #f)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 70663))
 (set.gloc.of \x2E;L117)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const ((t) (generate-temporaries (syntax (q)))))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 118796))
 (set.gloc.of \x2E;L137)
 (close
   (1 0)
   (push.const . #f)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 66567))
 (set.gloc.of \x2E;L134)
 (close
   (1 0)
   (touch.gloc.of qs\x60;365*)
   (call
     (push.iloc.0 . 0)
     (push.const . x)
     (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/syntax-case.scm" . 181258))
   (push)
   (push.const . 0)
   (push.const)
   (push.close
     (2 0)
     (push.iloc.0 . 1)
     (call
       (push.iloc.1 . 0)
       (push.const . x)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/syntax-case.scm" . 183316))
     (if.eq?
       (push.iloc.1 . 0)
       (push.const syntax x)
       (push.const (x . 0))
       (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 183312))
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/syntax-case.scm" . 150557)
     (push.const)
     (push.const (b ...) x)
     (push.const . #f)
     (push.gloc.of \x2E;L123)
     (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 150557)
     (push.const . _)
     (push.const . #f)
     (push.gloc.of \x2E;L104)
     (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 150557)
     (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 150557))
   (apply.gloc.of qs\x60;365* "../stdlib/core/syntax-case.scm" . 181258))
 (set.gloc.of \x2E;L127)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const ((t ...) (generate-temporaries (syntax (q ...)))))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 124946))
 (set.gloc.of \x2E;L129)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const define-macro name (lambda args . body))
   (push.const (body . 0) (args . 0) (name . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 51209))
 (set.gloc.of \x2E;L136)
 (close
   (1 0)
   (subr.gloc.of \x2E;backtrace 0 "../stdlib/core/syntax-case.scm" . 37902)
   (if.true
     (push.iloc.0 . 0)
     (push.const
       syntax-case
       (list e0 ...)
       ()
       ((p ...) (let () e1 e2 ...))
       (_ (syntax-violation 'with-syntax "value does not match to pattern" '((p e0) ...))))
     (push.const (e2 . 1) (e1 . 0) (p . 1) (e0 . 1))
     (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 37898))
   (push.iloc.0 . 0)
   (push.const syntax-case (list e0 ...) () ((p ...) (let () e1 e2 ...)))
   (push.const (e2 . 1) (e1 . 0) (p . 1) (e0 . 1))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 37898))
 (set.gloc.of \x2E;L125)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const ((t ...) (generate-temporaries (syntax (q ...)))))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 172055))
 (set.gloc.of \x2E;L120)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const ((t ...) (generate-temporaries (syntax (q ...)))))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 132114))
 (set.gloc.of \x2E;L111)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const ((t ...) (generate-temporaries (syntax (q ...)))))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 166935))
 (set.gloc.of \x2E;L130)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . #(x ...))
   (push.const (x . 1))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 150557))
 (set.gloc.of \x2E;L131)
 (close
   (4 0 . vqs)
   (iloc.0 . 0)
   (if.null?
     (push.iloc.0 . 2)
     (push.const)
     (apply.iloc (0 . 3) "../stdlib/core/syntax-case.scm" . 160781))
   (touch.gloc.of vqs\x60;365*)
   (push.cdr.iloc (0 . 0) "../stdlib/core/syntax-case.scm" . 161810)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.close
     (2 0)
     (push.gloc.of \x2E;vars)
     (push.car.iloc (1 . 0) "../stdlib/core/syntax-case.scm" . 163873)
     (push.const unsyntax unsyntax-splicing)
     (push.const unsyntax q ...)
     (push.close
       (1 0)
       (push.iloc 2 . 1)
       (push.const . 0)
       (ret.subr.gloc.of \x2E;= "../stdlib/core/syntax-case.scm" . 165911))
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (call
         (call
           (push.iloc.0 . 0)
           (push.const q ...)
           (push.const (q . 1))
           (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 166935))
         (push)
         (apply.gloc.of \x2E;generate-temporaries "../stdlib/core/syntax-case.scm" . 166935))
       (push)
       (push.subr.gloc.of \x2E;list 1 "../stdlib/core/syntax-case.scm" . 166935)
       (push.const)
       (push.const (t ...))
       (push.const . #f)
       (push.close
         (1 0)
         (call
           (push.iloc.0 . 0)
           (push.const (t q) ...)
           (push.const (q . 1) (t . 1))
           (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 166935))
         (push)
         (push.iloc 2 . 0)
         (push.subr.gloc.of \x2E;append 2 "../stdlib/core/syntax-case.scm" . 166935)
         (call
           (push.iloc.0 . 0)
           (push.const t ...)
           (push.const (t . 1))
           (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 166935))
         (push)
         (push.iloc 2 . 1)
         (push.subr.gloc.of \x2E;append 2 "../stdlib/core/syntax-case.scm" . 166935)
         (apply.iloc (3 . 3) "../stdlib/core/syntax-case.scm" . 166935))
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 166935)
       (push.const . _)
       (push.const . #f)
       (push.gloc.of \x2E;L130)
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 166935)
       (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 166935))
     (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 164887)
     (push.const unsyntax-splicing q ...)
     (push.close
       (1 0)
       (push.iloc 2 . 1)
       (push.const . 0)
       (ret.subr.gloc.of \x2E;= "../stdlib/core/syntax-case.scm" . 171031))
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (call
         (call
           (push.iloc.0 . 0)
           (push.const q ...)
           (push.const (q . 1))
           (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 172055))
         (push)
         (apply.gloc.of \x2E;generate-temporaries "../stdlib/core/syntax-case.scm" . 172055))
       (push)
       (push.subr.gloc.of \x2E;list 1 "../stdlib/core/syntax-case.scm" . 172055)
       (push.const)
       (push.const (t ...))
       (push.const . #f)
       (push.close
         (1 0)
         (call
           (push.iloc.0 . 0)
           (push.const ((t (... ...)) q) ...)
           (push.const (q . 1) (t . 1))
           (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 172055))
         (push)
         (push.iloc 2 . 0)
         (push.subr.gloc.of \x2E;append 2 "../stdlib/core/syntax-case.scm" . 172055)
         (call
           (push.iloc.0 . 0)
           (call
             (push.iloc.0 . 0)
             (push.const (t (... ...)) ...)
             (push.const (t . 1))
             (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 172055))
           (push)
           (push.subr.gloc.of \x2E;list 1 "../stdlib/core/syntax-case.scm" . 172055)
           (push.const)
           (push.const ((m ...) ...))
           (push.const . #f)
           (push.close
             (1 0)
             (call
               (push.iloc.0 . 0)
               (push.const m ... ...)
               (push.const (m . 2))
               (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 172055))
             (push)
             (push.iloc 3 . 1)
             (ret.subr.gloc.of \x2E;append "../stdlib/core/syntax-case.scm" . 172055))
           (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 172055)
           (push.const . _)
           (push.const . #f)
           (push.gloc.of \x2E;L135)
           (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 172055)
           (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 172055))
         (push)
         (apply.iloc (3 . 3) "../stdlib/core/syntax-case.scm" . 172055))
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 172055)
       (push.const . _)
       (push.const . #f)
       (push.gloc.of \x2E;L120)
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 172055)
       (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 172055))
     (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 170007)
     (push.const . _)
     (push.const . #f)
     (push.close
       (1 0)
       (touch.gloc.of qs\x60;365*)
       (push.car.iloc (2 . 0) "../stdlib/core/syntax-case.scm" . 176157)
       (push.iloc 2 . 1)
       (push.iloc.1 . 0)
       (push.close
         (2 0)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (iloc 2 . 1)
         (push.cons)
         (apply.iloc (3 . 3) "../stdlib/core/syntax-case.scm" . 178207))
       (apply.gloc.of qs\x60;365* "../stdlib/core/syntax-case.scm" . 176153))
     (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 163873)
     (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 163873))
   (apply.gloc.of vqs\x60;365* "../stdlib/core/syntax-case.scm" . 161810))
 (set.gloc.of vqs\x60;365*)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const a . d)
   (push.const (d . 0) (a . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 150557))
 (set.gloc.of \x2E;L133)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const _ x)
   (push.const . #f)
   (push.gloc.of \x2E;L127)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 179207)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 179207))
 (set.gloc.of \x2E;L112)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const (d dnew))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 150557))
 (set.gloc.of \x2E;L118)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const (((m ...) ...) (syntax ((t (... ...)) ...))))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/syntax-case.scm" . 172055))
 (set.gloc.of \x2E;L135)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const m ... ... . d)
   (push.const (d . 0) (m . 2))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/syntax-case.scm" . 132114))
 (set.gloc.of \x2E;L108)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const _ ((p e0) ...) e1 e2 ...)
   (push.const . #f)
   (push.gloc.of \x2E;L125)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 35847)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 35847))
 (set.gloc.of \x2E;L113)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const _ (name . args) . body)
   (push.const . #f)
   (push.gloc.of \x2E;L136)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 50183)
   (push.const _ name body)
   (push.const . #f)
   (push.gloc.of \x2E;L110)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/syntax-case.scm" . 50183)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/syntax-case.scm" . 50183))
 (set.gloc.of \x2E;L124)
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/syntax-case.scm" . 150557))
 (call
   (push.const
     (syntax->datum import . \x2E;syntax->datum)
     (a unbound)
     (syntax import . \x2E;syntax)
     (quote import . \x2E;quote)
     (define-syntax import . \x2E;define-syntax)
     (define-macro import . core.syntax-case\x27;define-macro)
     (e2 unbound)
     (e1 unbound)
     (p unbound)
     (m unbound)
     (args unbound)
     (unsyntax-splicing import . core.syntax-case\x27;unsyntax-splicing)
     (t unbound)
     (generate-temporaries import . \x2E;generate-temporaries)
     (x unbound)
     (d unbound)
     (body unbound)
     (letrec* import . \x2E;letrec*)
     (dnew unbound)
     (xnew* unbound)
     (syntax-case import . \x2E;syntax-case)
     (_ import . \x2E;_)
     (unsyntax import . core.syntax-case\x27;unsyntax)
     (list import . \x2E;list)
     (... import . \x2E;...)
     (datum->syntax import . \x2E;datum->syntax)
     (and import . \x2E;and)
     (syntax-violation import . \x2E;syntax-violation)
     (datum import . core.syntax-case\x27;datum)
     (e0 unbound)
     (b unbound)
     (xnew unbound)
     (lambda import . \x2E;lambda)
     (name unbound)
     (apply import . \x2E;apply)
     (q unbound)
     (let import . \x2E;let)
     (if import . \x2E;if)
     (define-macro-transformer unbound)
     (quasisyntax import . core.syntax-case\x27;quasisyntax)
     (b* unbound)
     (anew unbound)
     (with-syntax import . core.syntax-case\x27;with-syntax))
   (extend . 1)
   (call
     (push.const . syntax)
     (push.const . core.syntax-case\x27;datum)
     (push.const
       ()
       ("../stdlib/core/syntax-case.scm" . 30725)
       ((_ x) (syntax->datum (syntax x)) ((x . 0)) (syntax syntax->datum)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/syntax-case.scm" . 31752))
   (call
     (push.const . syntax)
     (push.const . core.syntax-case\x27;with-syntax)
     (call
       (push.gloc.of \x2E;L113)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/syntax-case.scm" . 31752))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/syntax-case.scm" . 31752))
   (call
     (push.const . syntax)
     (push.const . core.syntax-case\x27;define-macro)
     (call
       (push.gloc.of \x2E;L124)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/syntax-case.scm" . 31752))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/syntax-case.scm" . 31752))
   (call
     (push.const . syntax)
     (push.const . core.syntax-case\x27;unsyntax)
     (call
       (push.gloc.of \x2E;L134)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/syntax-case.scm" . 31752))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/syntax-case.scm" . 31752))
   (call
     (push.const . syntax)
     (push.const . core.syntax-case\x27;unsyntax-splicing)
     (call
       (push.gloc.of \x2E;L117)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/syntax-case.scm" . 31752))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/syntax-case.scm" . 31752))
   (push.const . syntax)
   (push.const . core.syntax-case\x27;quasisyntax)
   (call
     (push.gloc.of \x2E;L112)
     (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/syntax-case.scm" . 90117))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/syntax-case.scm" . 31752))
 (push.const . core.syntax-case)
 (push.const . #f)
 (push.const
   (syntax-case import . \x2E;syntax-case)
   (syntax import . \x2E;syntax)
   (with-syntax import . core.syntax-case\x27;with-syntax)
   (_ import . \x2E;_)
   (... import . \x2E;...)
   (make-variable-transformer import . \x2E;make-variable-transformer)
   (identifier? import . \x2E;identifier?)
   (bound-identifier=? import . \x2E;bound-identifier=?)
   (free-identifier=? import . \x2E;free-identifier=?)
   (datum->syntax import . \x2E;datum->syntax)
   (syntax->datum import . \x2E;syntax->datum)
   (generate-temporaries import . \x2E;generate-temporaries)
   (quasisyntax import . core.syntax-case\x27;quasisyntax)
   (syntax-violation import . \x2E;syntax-violation)
   (datum import . core.syntax-case\x27;datum)
   (define-macro import . core.syntax-case\x27;define-macro)
   (unsyntax import . core.syntax-case\x27;unsyntax)
   (unsyntax-splicing import . core.syntax-case\x27;unsyntax-splicing))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/syntax-case.scm" . 150557))

((call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/r5rs.scm" . 6145))
 (close (1 0 . core.r5rs\x27;force) (apply.iloc (0 . 0) "../stdlib/core/r5rs.scm" . 19463))
 (set.gloc.of core.r5rs\x27;force)
 (close
   (1 0 . core.r5rs\x27;make-promise)
   (push.const . #f)
   (push.const . #f)
   (extend . 2)
   (ret.close
     (0 0)
     (iloc.1 . 0)
     (if.true (ret.iloc 1 . 1))
     (call (apply.iloc (2 . 0) "../stdlib/core/r5rs.scm" . 28696))
     (push)
     (extend . 1)
     (iloc 2 . 0)
     (if.true (ret.iloc 2 . 1))
     (const . #t)
     (set.iloc (2 . 0) "../stdlib/core/r5rs.scm" . 31772)
     (iloc.0 . 0)
     (set.iloc (2 . 1) "../stdlib/core/r5rs.scm" . 32791)
     (ret.iloc 2 . 1)))
 (set.gloc.of core.r5rs\x27;make-promise)
 (call
   (push.const . syntax)
   (push.const . core.r5rs\x27;delay)
   (push.const
     ()
     ("../stdlib/core/r5rs.scm" . 36869)
     ((delay expression)
      (make-promise (lambda () expression))
      ((expression . 0) (delay . 0))
      (lambda make-promise)))
   (push.const
     (lambda import . \x2E;lambda)
     (expression unbound)
     (make-promise import . core.r5rs\x27;make-promise)
     (delay import . core.r5rs\x27;delay))
   (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/r5rs.scm" . 6145))
 (push.const . core.r5rs)
 (push.const . #f)
 (push.const
   (inexact->exact import . \x2E;exact)
   (exact->inexact import . \x2E;inexact)
   (quotient import . \x2E;quotient)
   (remainder import . \x2E;remainder)
   (modulo import . \x2E;modulo)
   (delay import . core.r5rs\x27;delay)
   (force import . core.r5rs\x27;force))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/r5rs.scm" . 6145))

((close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (push.const . k)
     (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/control.scm" . 19480))
   (push)
   (call
     (push.iloc.0 . 0)
     (push.const lst ...)
     (push.const (lst . 1))
     (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/control.scm" . 19507))
   (push)
   (push.subr.gloc.of \x2E;length 1 "../stdlib/core/control.scm" . 19499)
   (apply.gloc.of \x2E;datum->syntax "../stdlib/core/control.scm" . 19480))
 (set.gloc.of \x2E;L179)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const _ (lst ...))
   (push.const . #f)
   (push.gloc.of \x2E;L179)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/control.scm" . 18439)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/control.scm" . 18439))
 (set.gloc.of \x2E;L180)
 (call
   (push.const core syntax-case)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/control.scm" . 19480))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/control.scm" . 19480))
 (call
   (push.const core intrinsics)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/control.scm" . 19480))
 (call
   (push.const
     (r unbound)
     (result2 unbound)
     (test unbound)
     (quote import . \x2E;quote)
     (_ import . \x2E;_)
     (lambda import . \x2E;lambda)
     (args unbound)
     (assertion-violation import . \x2E;assertion-violation)
     (x2 unbound)
     (b1 unbound)
     (x unbound)
     (begin import . \x2E;begin)
     (k unbound)
     (unless import . core.control\x27;unless)
     (when import . core.control\x27;when)
     (length import . \x2E;length)
     (x1 unbound)
     (syntax-length import . core.control\x27;syntax-length)
     (fmls unbound)
     (... import . \x2E;...)
     (case-lambda-help import . core.control\x27;case-lambda-help)
     (>= import . \x2E;>=)
     (n unbound)
     (b2 unbound)
     (result1 unbound)
     (= import . \x2E;=)
     (apply import . \x2E;apply)
     (let import . \x2E;let)
     (lst unbound)
     (if import . \x2E;if)
     (more unbound)
     (case-lambda import . core.control\x27;case-lambda)
     (not import . \x2E;not))
   (extend . 1)
   (call
     (push.const . syntax)
     (push.const . core.control\x27;syntax-length)
     (call
       (push.gloc.of \x2E;L180)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/control.scm" . 19480))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/control.scm" . 19480))
   (call
     (push.const . syntax)
     (push.const . core.control\x27;when)
     (push.const
       ()
       ("../stdlib/core/control.scm" . 22533)
       ((when test result1 result2 ...)
        (if test (begin result1 result2 ...))
        ((result2 . 1) (result1 . 0) (test . 0) (when . 0))
        (begin if)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/control.scm" . 19480))
   (call
     (push.const . syntax)
     (push.const . core.control\x27;unless)
     (push.const
       ()
       ("../stdlib/core/control.scm" . 28677)
       ((unless test result1 result2 ...)
        (if (not test) (begin result1 result2 ...))
        ((result2 . 1) (result1 . 0) (test . 0) (unless . 0))
        (begin not if)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/control.scm" . 19480))
   (call
     (push.const . syntax)
     (push.const . core.control\x27;case-lambda-help)
     (push.const
       ()
       ("../stdlib/core/control.scm" . 34821)
       ((_ args n)
        (assertion-violation #f "wrong number of arguments" args)
        ((n . 0) (args . 0))
        (assertion-violation))
       ((_ args n ((x ...) b1 b2 ...) more ...)
        (if (= n (syntax-length (x ...)))
            (apply (lambda (x ...) b1 b2 ...) args)
            (case-lambda-help args n more ...))
        ((more . 1) (b2 . 1) (b1 . 0) (x . 1) (n . 0) (args . 0))
        (case-lambda-help lambda apply syntax-length = if))
       ((_ args n ((x1 x2 ... . r) b1 b2 ...) more ...)
        (if (>= n (syntax-length (x1 x2 ...)))
            (apply (lambda (x1 x2 ... . r) b1 b2 ...) args)
            (case-lambda-help args n more ...))
        ((more . 1) (b2 . 1) (b1 . 0) (r . 0) (x2 . 1) (x1 . 0) (n . 0) (args . 0))
        (case-lambda-help lambda apply syntax-length >= if))
       ((_ args n (r b1 b2 ...) more ...)
        (apply (lambda r b1 b2 ...) args)
        ((more . 1) (b2 . 1) (b1 . 0) (r . 0) (n . 0) (args . 0))
        (lambda apply)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/control.scm" . 19480))
   (push.const . syntax)
   (push.const . core.control\x27;case-lambda)
   (push.const
     ()
     ("../stdlib/core/control.scm" . 50181)
     ((_ (fmls b1 b2 ...)) (lambda fmls b1 b2 ...) ((b2 . 1) (b1 . 0) (fmls . 0)) (lambda))
     ((_ (fmls b1 b2 ...) ...)
      (lambda args (let ((n (length args))) (case-lambda-help args n (fmls b1 b2 ...) ...)))
      ((b2 . 2) (b1 . 1) (fmls . 1))
      (case-lambda-help length n let args lambda)))
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/control.scm" . 19480))
 (push.const . core.control)
 (push.const . #f)
 (push.const
   (when import . core.control\x27;when)
   (unless import . core.control\x27;unless)
   (do import . \x2E;do)
   (case-lambda import . core.control\x27;case-lambda))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/control.scm" . 19480))

((close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const _ (lst ...))
   (push.const . #f)
   (push.gloc.of \x2E;L185)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/optargs.scm" . 14343)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/optargs.scm" . 14343))
 (set.gloc.of \x2E;L184)
 (close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (push.const . k)
     (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/optargs.scm" . 16394))
   (push)
   (call
     (push.iloc.0 . 0)
     (push.const lst ...)
     (push.const (lst . 1))
     (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/optargs.scm" . 16421))
   (push)
   (push.subr.gloc.of \x2E;length 1 "../stdlib/core/optargs.scm" . 16413)
   (apply.gloc.of \x2E;datum->syntax "../stdlib/core/optargs.scm" . 16394))
 (set.gloc.of \x2E;L185)
 (call
   (push.const core syntax-case)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/optargs.scm" . 13317))
 (call
   (push.const core intrinsics)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/optargs.scm" . 13317))
 (call
   (push.const
     (length import . \x2E;length)
     (quote import . \x2E;quote)
     (_ import . \x2E;_)
     (lambda import . \x2E;lambda)
     (let-optionals import . core.optargs\x27;let-optionals)
     (... import . \x2E;...)
     (args unbound)
     (var unbound)
     (var1 unbound)
     (value unbound)
     (body2 unbound)
     (pair? import . \x2E;pair?)
     (k unbound)
     (var2 unbound)
     (if import . \x2E;if)
     (append import . \x2E;append)
     (let-optionals-aux import . core.optargs\x27;let-optionals-aux)
     (syntax-length import . core.optargs\x27;syntax-length)
     (list import . \x2E;list)
     (car import . \x2E;car)
     (argc unbound)
     (= import . \x2E;=)
     (apply import . \x2E;apply)
     (temp unbound)
     (let import . \x2E;let)
     (lst unbound)
     (body1 unbound)
     (def2 unbound)
     (def unbound)
     (def1 unbound))
   (extend . 1)
   (call
     (push.const . syntax)
     (push.const . core.optargs\x27;syntax-length)
     (call
       (push.gloc.of \x2E;L184)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/optargs.scm" . 13317))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/optargs.scm" . 13317))
   (call
     (push.const . syntax)
     (push.const . core.optargs\x27;let-optionals-aux)
     (push.const
       ()
       ("../stdlib/core/optargs.scm" . 19461)
       ((_ _ _ (value ...) () ()) (list value ...) ((value . 1)) (list))
       ((_ argc args () (var1 ... var2) (def1 ... def2))
        (if (= argc (syntax-length (var1 ... var2)))
            args
            (let ((temp def2)) (let-optionals-aux argc args (temp) (var1 ...) (def1 ...))))
        ((def2 . 0) (def1 . 1) (var2 . 0) (var1 . 1) (args . 0) (argc . 0))
        (let-optionals-aux temp let syntax-length = if))
       ((_ argc args (value ...) (var) (def))
        (if (= argc 1) (append args (list value ...)) (list def value ...))
        ((def . 0) (var . 0) (value . 1) (args . 0) (argc . 0))
        (list append = if))
       ((_ argc args (value ...) (var1 ... var2) (def1 ... def2))
        (if (= argc (syntax-length (var1 ... var2)))
            (append args (list value ...))
            (let ((temp def2))
              (let-optionals-aux argc args (temp value ...) (var1 ...) (def1 ...))))
        ((def2 . 0) (def1 . 1) (var2 . 0) (var1 . 1) (value . 1) (args . 0) (argc . 0))
        (let-optionals-aux temp let list append syntax-length = if)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/optargs.scm" . 13317))
   (push.const . syntax)
   (push.const . core.optargs\x27;let-optionals)
   (push.const
     ()
     ("../stdlib/core/optargs.scm" . 38917)
     ((_ args ((var def)) body1 body2 ...)
      (let ((var (if (pair? args) (car args) def))) body1 body2 ...)
      ((body2 . 1) (body1 . 0) (def . 0) (var . 0) (args . 0))
      (car pair? if let))
     ((_ args ((var def) ...) body1 body2 ...)
      (apply
        (lambda (var ...) body1 body2 ...)
        (let ((argc (length args))) (let-optionals-aux argc args () (var ...) (def ...))))
      ((body2 . 1) (body1 . 0) (def . 1) (var . 1) (args . 0))
      (let-optionals-aux length argc let lambda apply)))
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/optargs.scm" . 13317))
 (push.const . core.optargs)
 (push.const . #f)
 (push.const (let-optionals import . core.optargs\x27;let-optionals))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/optargs.scm" . 13317))

((close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.null? (push.iloc.0 . 1) (ret.subr.gloc.of \x2E;reverse "../stdlib/core/lists.scm" . 306189))
   (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 307223)
   (push.iloc.0 . 1)
   (subr.gloc.of \x2E;memq 2 "../stdlib/core/lists.scm" . 307217)
   (if.true
     (touch.gloc.of loop\x60;755*)
     (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 308247)
     (push.iloc.0 . 1)
     (apply.gloc.of loop\x60;755* "../stdlib/core/lists.scm" . 308241))
   (touch.gloc.of loop\x60;755*)
   (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 309271)
   (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 309287)
   (iloc.0 . 1)
   (push.cons)
   (apply.gloc.of loop\x60;755* "../stdlib/core/lists.scm" . 309265))
 (set.gloc.of loop\x60;755*)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;cdar 1 "../stdlib/core/lists.scm" . 30743)
   (if.null?
     (touch.gloc.of loop\x60;550*)
     (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 30761)
     (apply.gloc.of loop\x60;550* "../stdlib/core/lists.scm" . 30755))
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;cdar 1 "../stdlib/core/lists.scm" . 31771)
   (call
     (touch.gloc.of loop\x60;550*)
     (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 31788)
     (apply.gloc.of loop\x60;550* "../stdlib/core/lists.scm" . 31782))
   (ret.cons "../stdlib/core/lists.scm" . 31765))
 (set.gloc.of loop\x60;550*)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (car.iloc (0 . 0) "../stdlib/core/lists.scm" . 298026)
   (if.not.symbol?.ret.const . #t)
   (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 299042)
   (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 299052)
   (subr.gloc.of \x2E;memq 2 "../stdlib/core/lists.scm" . 299036)
   (if.true.ret)
   (touch.gloc.of loop\x60;747*)
   (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 300066)
   (apply.gloc.of loop\x60;747* "../stdlib/core/lists.scm" . 300060))
 (set.gloc.of loop\x60;747*)
 (call
   (push.const core optargs)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/lists.scm" . 305161))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/lists.scm" . 305161))
 (close
   (1 0 . core.lists\x27;collect-cdr)
   (touch.gloc.of loop\x60;550*)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;550* "../stdlib/core/lists.scm" . 29705))
 (set.gloc.of core.lists\x27;collect-cdr)
 (close
   (2 0 . core.lists\x27;find)
   (iloc.0 . 1)
   (if.null?.ret.const . #f)
   (iloc.0 . 1)
   (if.pair?
     (extend.enclose+
       (2 0 . loop)
       (call (push.iloc.0 . 0) (apply.iloc (2 . 0) "../stdlib/core/lists.scm" . 38935))
       (if.true (ret.iloc 0 . 0))
       (iloc.0 . 1)
       (if.null?.ret.const . #f)
       (iloc.0 . 1)
       (if.pair?
         (push.car.iloc (0 . 1) "../stdlib/core/lists.scm" . 41002)
         (push.cdr.iloc (0 . 1) "../stdlib/core/lists.scm" . 41013)
         (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 40996))
       (push.const . find)
       (push.const . "traversal reached to non-pair element ~s")
       (push.iloc.0 . 1)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/lists.scm" . 43058)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.subr.gloc.of \x2E;list 2 "../stdlib/core/lists.scm" . 43115)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 43031))
     (push.car.iloc (1 . 1) "../stdlib/core/lists.scm" . 37919)
     (push.cdr.iloc (1 . 1) "../stdlib/core/lists.scm" . 37936)
     (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 38928))
   (push.const . find)
   (push.const . "expected chain of pairs, but got ~r, as argument 2")
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;format 2 "../stdlib/core/lists.scm" . 45097)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;list 2 "../stdlib/core/lists.scm" . 45163)
   (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 45070))
 (set.gloc.of core.lists\x27;find)
 (close
   (2 0 . core.lists\x27;for-all-n)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;length 1 "../stdlib/core/lists.scm" . 49171)
   (extend . 1)
   (extend.enclose+
     (1 0 . collect-car)
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null?.ret.const)
       (car.iloc (0 . 0) "../stdlib/core/lists.scm" . 55325)
       (if.pair?
         (push.iloc.0 . 0)
         (push.subr.gloc.of \x2E;caar 1 "../stdlib/core/lists.scm" . 56348)
         (call
           (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 56365)
           (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 56359))
         (ret.cons "../stdlib/core/lists.scm" . 56342))
       (push.const . for-all)
       (push.const . "traversal reached to non-pair element ~s")
       (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 58471)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/lists.scm" . 58420)
       (push.iloc 5 . 1)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 58390))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 54287))
   (extend.enclose+
     (2 0 . loop)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;length 1 "../stdlib/core/lists.scm" . 61458)
     (=.iloc (3 . 0) "../stdlib/core/lists.scm" . 61455)
     (if.false.call
       (push.const . for-all)
       (push.const . "expected same length chains of pairs")
       (push.iloc 4 . 1)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 62479))
     (iloc.0 . 1)
     (if.null?
       (push.iloc 4 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of \x2E;apply "../stdlib/core/lists.scm" . 64527))
     (call
       (push.iloc 4 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of \x2E;apply "../stdlib/core/lists.scm" . 65556))
     (if.false.ret)
     (call (push.iloc.0 . 1) (apply.iloc+ (2 . 0) "../stdlib/core/lists.scm" . 66586))
     (push)
     (call
       (push.iloc.0 . 1)
       (apply.gloc.of core.lists\x27;collect-cdr "../stdlib/core/lists.scm" . 66605))
     (push)
     (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 66580))
   (call (push.iloc 3 . 1) (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 60442))
   (push)
   (call
     (push.iloc 3 . 1)
     (apply.gloc.of core.lists\x27;collect-cdr "../stdlib/core/lists.scm" . 60477))
   (push)
   (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 61451))
 (set.gloc.of core.lists\x27;for-all-n)
 (close
   (2 0 . core.lists\x27;exists-n)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;length 1 "../stdlib/core/lists.scm" . 70675)
   (extend . 1)
   (extend.enclose+
     (1 0 . collect-car)
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null?.ret.const)
       (car.iloc (0 . 0) "../stdlib/core/lists.scm" . 76829)
       (if.pair?
         (push.iloc.0 . 0)
         (push.subr.gloc.of \x2E;caar 1 "../stdlib/core/lists.scm" . 77852)
         (call
           (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 77869)
           (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 77863))
         (ret.cons "../stdlib/core/lists.scm" . 77846))
       (push.const . exists)
       (push.const . "traversal reached to non-pair element ~s")
       (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 79974)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/lists.scm" . 79923)
       (push.iloc 5 . 1)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 79894))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 75791))
   (extend.enclose+
     (2 0 . loop)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;length 1 "../stdlib/core/lists.scm" . 82962)
     (=.iloc (3 . 0) "../stdlib/core/lists.scm" . 82959)
     (if.false.call
       (push.const . exists)
       (push.const . "expected same length chains of pairs")
       (push.iloc 4 . 1)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 83983))
     (iloc.0 . 1)
     (if.null?
       (push.iloc 4 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of \x2E;apply "../stdlib/core/lists.scm" . 86031))
     (call
       (push.iloc 4 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of \x2E;apply "../stdlib/core/lists.scm" . 87059))
     (if.true.ret)
     (call (push.iloc.0 . 1) (apply.iloc+ (2 . 0) "../stdlib/core/lists.scm" . 88089))
     (push)
     (call
       (push.iloc.0 . 1)
       (apply.gloc.of core.lists\x27;collect-cdr "../stdlib/core/lists.scm" . 88108))
     (push)
     (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 88083))
   (call (push.iloc 3 . 1) (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 81946))
   (push)
   (call
     (push.iloc 3 . 1)
     (apply.gloc.of core.lists\x27;collect-cdr "../stdlib/core/lists.scm" . 81981))
   (push)
   (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 82955))
 (set.gloc.of core.lists\x27;exists-n)
 (close
   (2 0 . core.lists\x27;for-all-n-quick)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 1)
     (if.null?
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of \x2E;apply "../stdlib/core/lists.scm" . 95249))
     (call
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of \x2E;apply "../stdlib/core/lists.scm" . 96278))
     (if.false.ret)
     (push.car.iloc (0 . 1) "../stdlib/core/lists.scm" . 97308)
     (push.cdr.iloc (0 . 1) "../stdlib/core/lists.scm" . 97319)
     (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 97302))
   (push.car.iloc (1 . 1) "../stdlib/core/lists.scm" . 93212)
   (push.cdr.iloc (1 . 1) "../stdlib/core/lists.scm" . 93229)
   (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 94221))
 (set.gloc.of core.lists\x27;for-all-n-quick)
 (close
   (2 0 . core.lists\x27;exists-n-quick)
   (iloc.0 . 1)
   (if.not.pair?.ret.const . #f)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 1)
     (if.null?
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of \x2E;apply "../stdlib/core/lists.scm" . 104466))
     (call
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of \x2E;apply "../stdlib/core/lists.scm" . 105494))
     (if.true.ret)
     (push.car.iloc (0 . 1) "../stdlib/core/lists.scm" . 106524)
     (push.cdr.iloc (0 . 1) "../stdlib/core/lists.scm" . 106535)
     (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 106518))
   (push.car.iloc (1 . 1) "../stdlib/core/lists.scm" . 102429)
   (push.cdr.iloc (1 . 1) "../stdlib/core/lists.scm" . 102446)
   (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 103438))
 (set.gloc.of core.lists\x27;exists-n-quick)
 (close
   (2 0 . core.lists\x27;for-all-1)
   (iloc.0 . 1)
   (if.null?.ret.const . #t)
   (iloc.0 . 1)
   (if.pair?
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 1)
       (if.null? (push.iloc.0 . 0) (apply.iloc (2 . 0) "../stdlib/core/lists.scm" . 113700))
       (iloc.0 . 1)
       (if.pair?
         (call (push.iloc.0 . 0) (apply.iloc (2 . 0) "../stdlib/core/lists.scm" . 115740))
         (if.false.ret)
         (push.car.iloc (0 . 1) "../stdlib/core/lists.scm" . 116770)
         (push.cdr.iloc (0 . 1) "../stdlib/core/lists.scm" . 116781)
         (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 116764))
       (call (push.iloc.0 . 0) (apply.iloc (2 . 0) "../stdlib/core/lists.scm" . 118812))
       (if.false.ret)
       (push.const . for-all)
       (push.const . "traversal reached to non-pair element ~s")
       (push.iloc.0 . 1)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/lists.scm" . 119866)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.subr.gloc.of \x2E;list 2 "../stdlib/core/lists.scm" . 119923)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 119836))
     (push.car.iloc (1 . 1) "../stdlib/core/lists.scm" . 112671)
     (push.cdr.iloc (1 . 1) "../stdlib/core/lists.scm" . 112688)
     (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 113680))
   (push.const . for-all)
   (push.const . "expected chain of pairs, but got ~r, as argument 2")
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;format 2 "../stdlib/core/lists.scm" . 121900)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;list 2 "../stdlib/core/lists.scm" . 121966)
   (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 121870))
 (set.gloc.of core.lists\x27;for-all-1)
 (close
   (2 0 . core.lists\x27;exists-1)
   (iloc.0 . 1)
   (if.null?.ret.const . #f)
   (iloc.0 . 1)
   (if.pair?
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 1)
       (if.null? (push.iloc.0 . 0) (apply.iloc (2 . 0) "../stdlib/core/lists.scm" . 129060))
       (call (push.iloc.0 . 0) (apply.iloc (2 . 0) "../stdlib/core/lists.scm" . 130071))
       (if.true.ret)
       (iloc.0 . 1)
       (if.pair?
         (push.car.iloc (0 . 1) "../stdlib/core/lists.scm" . 131114)
         (push.cdr.iloc (0 . 1) "../stdlib/core/lists.scm" . 131125)
         (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 131108))
       (push.const . exists)
       (push.const . "traversal reached to non-pair element ~s")
       (push.iloc.0 . 1)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/lists.scm" . 133172)
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.subr.gloc.of \x2E;list 2 "../stdlib/core/lists.scm" . 133229)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 133143))
     (push.car.iloc (1 . 1) "../stdlib/core/lists.scm" . 128031)
     (push.cdr.iloc (1 . 1) "../stdlib/core/lists.scm" . 128048)
     (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 129040))
   (push.const . exists)
   (push.const . "expected chain of pairs, but got ~r, as argument 2")
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;format 2 "../stdlib/core/lists.scm" . 135211)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;list 2 "../stdlib/core/lists.scm" . 135277)
   (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 135182))
 (set.gloc.of core.lists\x27;exists-1)
 (close
   (2 1 . core.lists\x27;for-all)
   (iloc.0 . 2)
   (if.null?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of core.lists\x27;for-all-1 "../stdlib/core/lists.scm" . 140302))
   (call
     (push.gloc.of \x2E;list-transpose+)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of \x2E;apply "../stdlib/core/lists.scm" . 141326))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of core.lists\x27;for-all-n-quick "../stdlib/core/lists.scm" . 142367))
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (iloc.1 . 2)
   (push.cons)
   (apply.gloc.of core.lists\x27;for-all-n "../stdlib/core/lists.scm" . 144398))
 (set.gloc.of core.lists\x27;for-all)
 (close
   (2 1 . core.lists\x27;exists)
   (iloc.0 . 2)
   (if.null?
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of core.lists\x27;exists-1 "../stdlib/core/lists.scm" . 149518))
   (call
     (push.gloc.of \x2E;list-transpose+)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (apply.gloc.of \x2E;apply "../stdlib/core/lists.scm" . 150542))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of core.lists\x27;exists-n-quick "../stdlib/core/lists.scm" . 151583))
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (iloc.1 . 2)
   (push.cons)
   (apply.gloc.of core.lists\x27;exists-n "../stdlib/core/lists.scm" . 153614))
 (set.gloc.of core.lists\x27;exists)
 (close
   (2 0 . core.lists\x27;filter)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 159766)
       (apply.iloc (2 . 0) "../stdlib/core/lists.scm" . 159760))
     (if.true
       (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 159783)
       (call
         (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 159799)
         (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 159793))
       (ret.cons "../stdlib/core/lists.scm" . 159777))
     (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 160795)
     (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 160789))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 158729))
 (set.gloc.of core.lists\x27;filter)
 (close
   (2 0 . core.lists\x27;partition)
   (extend.enclose+
     (3 0 . loop)
     (iloc.0 . 0)
     (if.null?
       (push.iloc.0 . 1)
       (push.subr.gloc.of \x2E;reverse 1 "../stdlib/core/lists.scm" . 165924)
       (push.iloc.0 . 2)
       (push.subr.gloc.of \x2E;reverse 1 "../stdlib/core/lists.scm" . 165939)
       (ret.subr.gloc.of \x2E;values "../stdlib/core/lists.scm" . 165916))
     (call
       (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 166934)
       (apply.iloc (2 . 0) "../stdlib/core/lists.scm" . 166928))
     (if.true
       (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 166951)
       (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 166967)
       (iloc.0 . 1)
       (push.cons)
       (push.iloc.0 . 2)
       (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 166945))
     (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 167963)
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 167984)
     (iloc.0 . 2)
     (push.cons)
     (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 167957))
   (push.iloc.1 . 1)
   (push.const)
   (push.const)
   (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 165897))
 (set.gloc.of core.lists\x27;partition)
 (close
   (3 0 . core.lists\x27;fold-left-1)
   (iloc.0 . 2)
   (if.null? (ret.iloc 0 . 1))
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 1)
     (push.car.iloc (0 . 2) "../stdlib/core/lists.scm" . 174123)
     (apply.iloc (0 . 0) "../stdlib/core/lists.scm" . 174112))
   (push)
   (push.cdr.iloc (0 . 2) "../stdlib/core/lists.scm" . 174134)
   (apply.gloc.of core.lists\x27;fold-left-1 "../stdlib/core/lists.scm" . 174094))
 (set.gloc.of core.lists\x27;fold-left-1)
 (close
   (3 0 . core.lists\x27;fold-left-n)
   (iloc.0 . 2)
   (if.null? (ret.iloc 0 . 1))
   (push.iloc.0 . 0)
   (call
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 1 "../stdlib/core/lists.scm" . 180276)
     (push.car.iloc (0 . 2) "../stdlib/core/lists.scm" . 180288)
     (push.subr.gloc.of \x2E;append 2 "../stdlib/core/lists.scm" . 180268)
     (apply.gloc.of \x2E;apply "../stdlib/core/lists.scm" . 180256))
   (push)
   (push.cdr.iloc (0 . 2) "../stdlib/core/lists.scm" . 180300)
   (apply.gloc.of core.lists\x27;fold-left-n "../stdlib/core/lists.scm" . 180238))
 (set.gloc.of core.lists\x27;fold-left-n)
 (close
   (3 1 . core.lists\x27;fold-left)
   (iloc.0 . 3)
   (if.null?
     (push.iloc.0 . 2)
     (subr.gloc.of \x2E;list? 1 "../stdlib/core/lists.scm" . 185359)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (apply.gloc.of core.lists\x27;fold-left-1 "../stdlib/core/lists.scm" . 186383))
     (push.const . fold-left)
     (push.const . "expected proper list, but got ~r, as argument 3")
     (push.iloc.0 . 2)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/lists.scm" . 187439)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.subr.gloc.of \x2E;cons* 4 "../stdlib/core/lists.scm" . 187503)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 187407))
   (call
     (push.gloc.of \x2E;list-transpose+)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of \x2E;apply "../stdlib/core/lists.scm" . 188434))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of core.lists\x27;fold-left-n "../stdlib/core/lists.scm" . 189475))
   (push.const . fold-left)
   (push.const . "expected same length proper lists")
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.iloc.1 . 3)
   (push.subr.gloc.of \x2E;cons* 4 "../stdlib/core/lists.scm" . 191574)
   (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 191506))
 (set.gloc.of core.lists\x27;fold-left)
 (close
   (3 0 . core.lists\x27;fold-right-1)
   (iloc.0 . 2)
   (if.null? (ret.iloc 0 . 1))
   (push.car.iloc (0 . 2) "../stdlib/core/lists.scm" . 197652)
   (call
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.cdr.iloc (0 . 2) "../stdlib/core/lists.scm" . 197686)
     (apply.gloc.of core.lists\x27;fold-right-1 "../stdlib/core/lists.scm" . 197662))
   (push)
   (apply.iloc (0 . 0) "../stdlib/core/lists.scm" . 197646))
 (set.gloc.of core.lists\x27;fold-right-1)
 (close
   (3 0 . core.lists\x27;fold-right-n)
   (iloc.0 . 2)
   (if.null? (ret.iloc 0 . 1))
   (push.iloc.0 . 0)
   (push.car.iloc (0 . 2) "../stdlib/core/lists.scm" . 203810)
   (call
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.cdr.iloc (0 . 2) "../stdlib/core/lists.scm" . 203850)
     (apply.gloc.of core.lists\x27;fold-right-n "../stdlib/core/lists.scm" . 203826))
   (push)
   (push.subr.gloc.of \x2E;list 1 "../stdlib/core/lists.scm" . 203820)
   (push.subr.gloc.of \x2E;append 2 "../stdlib/core/lists.scm" . 203802)
   (apply.gloc.of \x2E;apply "../stdlib/core/lists.scm" . 203790))
 (set.gloc.of core.lists\x27;fold-right-n)
 (close
   (3 1 . core.lists\x27;fold-right)
   (iloc.0 . 3)
   (if.null?
     (push.iloc.0 . 2)
     (subr.gloc.of \x2E;list? 1 "../stdlib/core/lists.scm" . 208911)
     (if.true
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (apply.gloc.of core.lists\x27;fold-right-1 "../stdlib/core/lists.scm" . 209935))
     (push.const . fold-right)
     (push.const . "expected proper list, but got ~r, as argument 3")
     (push.iloc.0 . 2)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/lists.scm" . 210992)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.subr.gloc.of \x2E;cons* 4 "../stdlib/core/lists.scm" . 211056)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 210959))
   (call
     (push.gloc.of \x2E;list-transpose+)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (apply.gloc.of \x2E;apply "../stdlib/core/lists.scm" . 211986))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of core.lists\x27;fold-right-n "../stdlib/core/lists.scm" . 213027))
   (push.const . fold-right)
   (push.const . "expected same length proper lists")
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.1 . 2)
   (push.iloc.1 . 3)
   (push.subr.gloc.of \x2E;cons* 4 "../stdlib/core/lists.scm" . 215127)
   (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 215058))
 (set.gloc.of core.lists\x27;fold-right)
 (close
   (2 0 . core.lists\x27;remp)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 221206)
       (apply.iloc (2 . 0) "../stdlib/core/lists.scm" . 221200))
     (if.true
       (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 222230)
       (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 222224))
     (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 224278)
     (call
       (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 225308)
       (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 225302))
     (ret.cons "../stdlib/core/lists.scm" . 224272))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 220169))
 (set.gloc.of core.lists\x27;remp)
 (close
   (2 0 . core.lists\x27;remove)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 231448)
     (push.iloc 2 . 0)
     (subr.gloc.of \x2E;equal? 2 "../stdlib/core/lists.scm" . 231440)
     (if.true
       (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 232470)
       (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 232464))
     (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 234518)
     (call
       (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 235548)
       (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 235542))
     (ret.cons "../stdlib/core/lists.scm" . 234512))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 230409))
 (set.gloc.of core.lists\x27;remove)
 (close
   (2 0 . core.lists\x27;remv)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 241686)
     (push.iloc 2 . 0)
     (subr.gloc.of \x2E;eqv? 2 "../stdlib/core/lists.scm" . 241680)
     (if.true
       (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 242710)
       (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 242704))
     (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 244758)
     (call
       (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 245788)
       (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 245782))
     (ret.cons "../stdlib/core/lists.scm" . 244752))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 240649))
 (set.gloc.of core.lists\x27;remv)
 (close
   (2 0 . core.lists\x27;remq)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 251925)
     (iloc 2 . 0)
     (if.eq?
       (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 252950)
       (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 252944))
     (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 254998)
     (call
       (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 256028)
       (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 256022))
     (ret.cons "../stdlib/core/lists.scm" . 254992))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 250889))
 (set.gloc.of core.lists\x27;remq)
 (close
   (2 0 . core.lists\x27;memp)
   (iloc.0 . 1)
   (if.null?.ret.const . #f)
   (call
     (push.car.iloc (0 . 1) "../stdlib/core/lists.scm" . 262159)
     (apply.iloc (0 . 0) "../stdlib/core/lists.scm" . 262153))
   (if.true (ret.iloc 0 . 1))
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "../stdlib/core/lists.scm" . 264212)
   (apply.gloc.of core.lists\x27;memp "../stdlib/core/lists.scm" . 264201))
 (set.gloc.of core.lists\x27;memp)
 (close
   (2 0 . core.lists\x27;assp)
   (iloc.0 . 1)
   (if.null?.ret.const . #f)
   (call
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;caar 1 "../stdlib/core/lists.scm" . 270351)
     (apply.iloc (0 . 0) "../stdlib/core/lists.scm" . 270345))
   (if.true (push.iloc.0 . 1) (ret.subr.gloc.of \x2E;car "../stdlib/core/lists.scm" . 270363))
   (push.iloc.0 . 0)
   (push.cdr.iloc (0 . 1) "../stdlib/core/lists.scm" . 272404)
   (apply.gloc.of core.lists\x27;assp "../stdlib/core/lists.scm" . 272393))
 (set.gloc.of core.lists\x27;assp)
 (close
   (1 1 . core.lists\x27;iota)
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;number? 1 "../stdlib/core/lists.scm" . 276496)
     (if.false.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;exact? 1 "../stdlib/core/lists.scm" . 276508)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const . 0)
     (ret.subr.gloc.of \x2E;>= "../stdlib/core/lists.scm" . 276519))
   (if.false.call
     (push.const . iota)
     (push.const . "expected non-negative exact integer, but got ~u as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/lists.scm" . 277542)
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (push.cons)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 277515))
   (push.close
     (2 0)
     (extend.enclose+
       (2 0 . loop)
       (<n.iloc (0 . 0) 0 "../stdlib/core/lists.scm" . 280594)
       (if.true (ret.iloc 0 . 1))
       (push.n+.iloc (0 . 0) -1 "../stdlib/core/lists.scm" . 281629)
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.iloc 2 . 1)
       (push.subr.gloc.of \x2E;* 2 "../stdlib/core/lists.scm" . 281652)
       (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/lists.scm" . 281643)
       (iloc.0 . 1)
       (push.cons)
       (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 281623))
     (push.n+.iloc (2 . 0) -1 "../stdlib/core/lists.scm" . 279575)
     (push.const)
     (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 280587))
   (call
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;length 1 "../stdlib/core/lists.scm" . 279561)
     (extend . 1)
     (=n.iloc (0 . 0) 2 "../stdlib/core/lists.scm" . 279561)
     (if.true (ret.iloc 1 . 1))
     (=n.iloc (0 . 0) 1 "../stdlib/core/lists.scm" . 279561)
     (if.true
       (push.iloc.1 . 1)
       (push.const . 1)
       (push.subr.gloc.of \x2E;list 1 "../stdlib/core/lists.scm" . 279561)
       (ret.subr.gloc.of \x2E;append "../stdlib/core/lists.scm" . 279561))
     (push.const . 0)
     (push.const . 1)
     (ret.subr.gloc.of \x2E;list "../stdlib/core/lists.scm" . 279561))
   (push)
   (apply.gloc.of
     \x2E;apply
     (\x2E;apply
       (lambda (start\x60;717* step\x60;717*)
         (letrec* ((loop\x60;721*
                     (lambda (n\x60;722* lst\x60;722*)
                       (if (\x2E;< n\x60;722* 0)
                           lst\x60;722*
                           (loop\x60;721*
                             (\x2E;- n\x60;722* 1)
                             (\x2E;cons
                               (\x2E;+ start\x60;717* (\x2E;* n\x60;722* step\x60;717*))
                               lst\x60;722*))))))
           (loop\x60;721* (\x2E;- n\x60;714* 1) '())))
       (let ((argc\x60;716\x60;725* (\x2E;length opt\x60;714*)))
         (if (\x2E;= argc\x60;716\x60;725* 2)
             opt\x60;714*
             (if (\x2E;= argc\x60;716\x60;725* 1)
                 (\x2E;append opt\x60;714* (\x2E;list 1))
                 (\x2E;list 0 1)))))))
 (set.gloc.of core.lists\x27;iota)
 (close
   (1 1 . core.lists\x27;make-list)
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;number? 1 "../stdlib/core/lists.scm" . 285712)
     (if.false.ret)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;exact? 1 "../stdlib/core/lists.scm" . 285724)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const . 0)
     (ret.subr.gloc.of \x2E;>= "../stdlib/core/lists.scm" . 285735))
   (if.false.call
     (push.const . make-list)
     (push.const . "expected non-negative exact integer, but got ~u as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/lists.scm" . 286763)
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (push.cons)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/lists.scm" . 286731))
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of \x2E;car (\x2E;car opt\x60;732*)))
   (push)
   (extend . 1)
   (extend.enclose+
     (2 0 . loop)
     (<=n.iloc (0 . 1) 0 "../stdlib/core/lists.scm" . 289810)
     (if.true (ret.iloc 0 . 0))
     (push.iloc 2 . 0)
     (iloc.0 . 0)
     (push.cons)
     (push.n+.iloc (0 . 1) -1 "../stdlib/core/lists.scm" . 290861)
     (apply.iloc+ (1 . 0) "../stdlib/core/lists.scm" . 290839))
   (push.const)
   (push.iloc 2 . 0)
   (apply.iloc+ (0 . 0) "../stdlib/core/lists.scm" . 289803))
 (set.gloc.of core.lists\x27;make-list)
 (close
   (1 0 . core.lists\x27;list-of-unique-symbols?)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;list? 1 "../stdlib/core/lists.scm" . 294924)
   (if.false.ret)
   (call
     (touch.gloc.of loop\x60;747*)
     (push.iloc.0 . 0)
     (apply.gloc.of loop\x60;747* "../stdlib/core/lists.scm" . 296979))
   (push)
   (ret.subr.gloc.of \x2E;not (\x2E;not (loop\x60;747* lst\x60;743*))))
 (set.gloc.of core.lists\x27;list-of-unique-symbols?)
 (close
   (1 0 . core.lists\x27;remove-duplicate-symbols)
   (touch.gloc.of loop\x60;755*)
   (push.iloc.0 . 0)
   (push.const)
   (apply.gloc.of loop\x60;755* "../stdlib/core/lists.scm" . 305161))
 (set.gloc.of core.lists\x27;remove-duplicate-symbols)
 (close
   (2 0 . core.lists\x27;break)
   (push.const)
   (extend . 1)
   (call
     (extend.enclose
       (1 0 . loop)
       (iloc.0 . 0)
       (if.null?.ret.const)
       (call
         (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 317471)
         (apply.iloc (3 . 0) "../stdlib/core/lists.scm" . 317465))
       (if.true (iloc.0 . 0) (set.iloc (2 . 0) "../stdlib/core/lists.scm" . 318496) (ret.const))
       (push.car.iloc (0 . 0) "../stdlib/core/lists.scm" . 320543)
       (call
         (push.cdr.iloc (0 . 0) "../stdlib/core/lists.scm" . 320559)
         (apply.iloc (1 . 0) "../stdlib/core/lists.scm" . 320553))
       (ret.cons "../stdlib/core/lists.scm" . 320537))
     (push.iloc 2 . 1)
     (apply.iloc (0 . 0) "../stdlib/core/lists.scm" . 316434))
   (push)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of
     \x2E;values
     (\x2E;values
       (letrec* ((loop\x60;765*
                   (lambda (lst\x60;766*)
                     (if (\x2E;null? lst\x60;766*)
                         '()
                         (if (pred\x60;759* (\x2E;car lst\x60;766*))
                             (begin (set! tail\x60;761* lst\x60;766*) '())
                             (\x2E;cons
                               (\x2E;car lst\x60;766*)
                               (loop\x60;765* (\x2E;cdr lst\x60;766*))))))))
         (loop\x60;765* lst\x60;759*))
       tail\x60;761*)))
 (set.gloc.of core.lists\x27;break)
 (gloc.of \x2E;list-head)
 (set.gloc.of core.lists\x27;take)
 (gloc.of \x2E;list-tail)
 (set.gloc.of core.lists\x27;drop)
 (push.const . core.lists)
 (push.const . #f)
 (push.const
   (find import . core.lists\x27;find)
   (for-all import . core.lists\x27;for-all)
   (exists import . core.lists\x27;exists)
   (filter import . core.lists\x27;filter)
   (partition import . core.lists\x27;partition)
   (fold-left import . core.lists\x27;fold-left)
   (fold-right import . core.lists\x27;fold-right)
   (remp import . core.lists\x27;remp)
   (remove import . core.lists\x27;remove)
   (remv import . core.lists\x27;remv)
   (remq import . core.lists\x27;remq)
   (memp import . core.lists\x27;memp)
   (member import . \x2E;member)
   (memv import . \x2E;memv)
   (memq import . \x2E;memq)
   (assp import . core.lists\x27;assp)
   (assoc import . \x2E;assoc)
   (assv import . \x2E;assv)
   (assq import . \x2E;assq)
   (cons* import . \x2E;cons*)
   (iota import . core.lists\x27;iota)
   (make-list import . core.lists\x27;make-list)
   (list-of-unique-symbols? import . core.lists\x27;list-of-unique-symbols?)
   (remove-duplicate-symbols import . core.lists\x27;remove-duplicate-symbols)
   (take import . core.lists\x27;take)
   (drop import . core.lists\x27;drop)
   (break import . core.lists\x27;break))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/lists.scm" . 305161))

((close
   (1 0 . loop)
   (cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 75806)
   (if.pair?
     (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 75823)
     (call
       (touch.gloc.of loop\x60;889*)
       (push.cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 75839)
       (apply.gloc.of loop\x60;889* "../stdlib/core/destructuring.scm" . 75833))
     (ret.cons "../stdlib/core/destructuring.scm" . 75817))
   (ret.const))
 (set.gloc.of loop\x60;889*)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 84009)
     (call
       (touch.gloc.of loop\x60;897*)
       (push.cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 84025)
       (apply.gloc.of loop\x60;897* "../stdlib/core/destructuring.scm" . 84019))
     (ret.cons "../stdlib/core/destructuring.scm" . 84003))
   (ret.const))
 (set.gloc.of loop\x60;897*)
 (close
   (2 0 . loop)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (subr.gloc.of \x2E;memq 2 "../stdlib/core/destructuring.scm" . 39954)
   (if.true.ret)
   (iloc.0 . 1)
   (if.not.pair?.ret.const . #f)
   (touch.gloc.of loop\x60;873*)
   (push.car.iloc (0 . 1) "../stdlib/core/destructuring.scm" . 42013)
   (push.cdr.iloc (0 . 1) "../stdlib/core/destructuring.scm" . 42024)
   (apply.gloc.of loop\x60;873* "../stdlib/core/destructuring.scm" . 42007))
 (set.gloc.of loop\x60;873*)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const . 2)
   (ret.subr.gloc.of \x2E;>= "../stdlib/core/destructuring.scm" . 239662))
 (set.gloc.of \x2E;L302)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const
     let
     ((?datum ?expr) (?pred-lhs ?pred-rhs) ... (?mem #f) ...)
     (let* (?subexprs ...) (cond ?dispatch ... (else #f))))
   (push.const
     (?dispatch . 1)
     (?subexprs . 1)
     (?mem . 1)
     (?pred-rhs . 1)
     (?pred-lhs . 1)
     (?expr . 0)
     (?datum . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/destructuring.scm" . 329746))
 (set.gloc.of \x2E;L286)
 (close
   (1 0)
   (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 222225)
   (call
     (push.cadr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 222254)
     (push.const (pair? and) (null?) (list?))
     (apply.gloc.of
       core.destructuring\x27;reorder-tests
       "../stdlib/core/destructuring.scm"
       .
       222239))
   (push)
   (push.cddr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 222302)
   (ret.subr.gloc.of \x2E;cons* "../stdlib/core/destructuring.scm" . 221196))
 (set.gloc.of \x2E;L297)
 (close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of loop\x60;921*)
     (push.cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 106530)
     (push.n+.iloc (0 . 1) 1 "../stdlib/core/destructuring.scm" . 106540)
     (apply.gloc.of loop\x60;921* "../stdlib/core/destructuring.scm" . 106524))
   (ret.iloc 0 . 1))
 (set.gloc.of loop\x60;921*)
 (close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.pair?
     (call
       (push.iloc.0 . 0)
       (apply.gloc.of
         core.destructuring\x27;predicate-pair?
         "../stdlib/core/destructuring.scm"
         .
         129047))
     (if.true (ret.iloc 0 . 1))
     (touch.gloc.of loop\x60;941*)
     (push.cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 130082)
     (push.n+.iloc (0 . 1) 1 "../stdlib/core/destructuring.scm" . 130092)
     (apply.gloc.of loop\x60;941* "../stdlib/core/destructuring.scm" . 130076))
   (ret.iloc 0 . 1))
 (set.gloc.of loop\x60;941*)
 (close
   (1 0)
   (call
     (call
       (push.iloc.0 . 0)
       (push.const . ?fender)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/destructuring.scm" . 329746))
     (push)
     (apply.gloc.of \x2E;syntax->datum "../stdlib/core/destructuring.scm" . 329746))
   (push)
   (const . #t)
   (if.eq?
     (push.iloc.0 . 0)
     (push.const (and ?tests ...) (let ((?vars ?inits) ...) ?body))
     (push.const (?body . 0) (?inits . 1) (?vars . 1) (?tests . 1))
     (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/destructuring.scm" . 329746))
   (push.iloc.0 . 0)
   (push.const (and ?tests ... (let ((?vars ?inits) ...) ?fender)) (let ((?vars ?inits) ...) ?body))
   (push.const (?body . 0) (?fender . 0) (?inits . 1) (?vars . 1) (?tests . 1))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/destructuring.scm" . 329746))
 (set.gloc.of \x2E;L292)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const
     (?datum (datum->syntax (syntax k) datum))
     ((?vars ...) (map (lambda (e) (datum->syntax (syntax ?_) e)) vars))
     ((?inits ...) (map (lambda (e) (datum->syntax (syntax k) e)) inits)))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/destructuring.scm" . 279573))
 (set.gloc.of \x2E;L300)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const let ((?datum ?expr)) (let ((?vars ?inits) ...) ?body ...))
   (push.const (?body . 1) (?inits . 1) (?vars . 1) (?expr . 0) (?datum . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/destructuring.scm" . 279573))
 (set.gloc.of \x2E;L296)
 (close
   (3 0 . loop)
   (iloc.0 . 1)
   (if.null?
     (push.iloc.0 . 2)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of \x2E;append "../stdlib/core/destructuring.scm" . 215053))
   (push.close
     (0 0)
     (push.close
       (1 0)
       (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 216132)
       (push.car.iloc (2 . 1) "../stdlib/core/destructuring.scm" . 216140)
       (ret.subr.gloc.of \x2E;memq "../stdlib/core/destructuring.scm" . 216126))
     (push.iloc.1 . 0)
     (apply.gloc.of core.lists\x27;partition "../stdlib/core/destructuring.scm" . 216103))
   (push.close
     (2 0)
     (touch.gloc.of loop\x60;969*)
     (push.iloc.0 . 1)
     (push.cdr.iloc (1 . 1) "../stdlib/core/destructuring.scm" . 217114)
     (push.iloc.1 . 2)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;append 2 "../stdlib/core/destructuring.scm" . 217126)
     (apply.gloc.of loop\x60;969* "../stdlib/core/destructuring.scm" . 217103))
   (apply.gloc.of
     \x2E;call-with-values
     (\x2E;call-with-values
       (lambda ()
         (core.lists\x27;partition
           (lambda (e\x60;973*) (\x2E;memq (\x2E;car e\x60;973*) (\x2E;car preds\x60;970*)))
           lst\x60;970*))
       (lambda (hits\x60;972* rest\x60;972*)
         (loop\x60;969*
           rest\x60;972*
           (\x2E;cdr preds\x60;970*)
           (\x2E;append acc\x60;970* hits\x60;972*))))))
 (set.gloc.of loop\x60;969*)
 (close
   (1 0)
   (push.gloc.of core.destructuring\x27;ca---r)
   (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 362549)
   (push.cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 362557)
   (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/destructuring.scm" . 362521))
 (set.gloc.of \x2E;L299)
 (close
   (1 0 . loop)
   (cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 99358)
   (if.pair?
     (touch.gloc.of loop\x60;913*)
     (push.cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 99375)
     (apply.gloc.of loop\x60;913* "../stdlib/core/destructuring.scm" . 99369))
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;cdr "../stdlib/core/destructuring.scm" . 100380))
 (set.gloc.of loop\x60;913*)
 (close
   (2 0 . loop)
   (<=n.iloc (0 . 1) 0 "../stdlib/core/destructuring.scm" . 120855)
   (if.true.ret.const)
   (cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 121886)
   (if.pair?
     (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 121903)
     (call
       (touch.gloc.of loop\x60;933*)
       (push.cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 121919)
       (push.n+.iloc (0 . 1) -1 "../stdlib/core/destructuring.scm" . 121929)
       (apply.gloc.of loop\x60;933* "../stdlib/core/destructuring.scm" . 121913))
     (ret.cons "../stdlib/core/destructuring.scm" . 121897))
   (ret.const))
 (set.gloc.of loop\x60;933*)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const
     ((?vars ...) (map (lambda (e) (datum->syntax (syntax ?_) e)) vars))
     ((?inits ...) (map (lambda (e) (datum->syntax (syntax k) e)) inits))
     ((?tests ...) (map (lambda (e) (datum->syntax (syntax k) e)) tests))
     (?fender fender)
     (?body body))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/destructuring.scm" . 329746))
 (set.gloc.of \x2E;L275)
 (close
   (1 0)
   (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 327732)
   (push.const . and)
   (cadr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 327747)
   (push.cons)
   (ret.subr.gloc.of \x2E;list "../stdlib/core/destructuring.scm" . 327717))
 (set.gloc.of \x2E;L277)
 (close
   (1 0)
   (push.gloc.of core.destructuring\x27;cd---r)
   (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 366645)
   (push.cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 366653)
   (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/destructuring.scm" . 366617))
 (set.gloc.of \x2E;L261)
 (close
   (3 0 . loop)
   (call
     (iloc.0 . 1)
     (if.null?.ret.const . #t)
     (iloc.0 . 2)
     (if.null?.ret.const . #t)
     (push.car.iloc (0 . 1) "../stdlib/core/destructuring.scm" . 228407)
     (push.car.iloc (0 . 2) "../stdlib/core/destructuring.scm" . 228416)
     (push.subr.gloc.of \x2E;equal? 2 "../stdlib/core/destructuring.scm" . 228399)
     (ret.subr.gloc.of \x2E;not "../stdlib/core/destructuring.scm" . 228394))
   (if.true (ret.iloc 0 . 0))
   (touch.gloc.of loop\x60;985*)
   (push.n+.iloc (0 . 0) 1 "../stdlib/core/destructuring.scm" . 229403)
   (push.cdr.iloc (0 . 1) "../stdlib/core/destructuring.scm" . 229411)
   (push.cdr.iloc (0 . 2) "../stdlib/core/destructuring.scm" . 229420)
   (apply.gloc.of loop\x60;985* "../stdlib/core/destructuring.scm" . 229397))
 (set.gloc.of loop\x60;985*)
 (close
   (1 0 . loop)
   (cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 92190)
   (if.pair?
     (touch.gloc.of loop\x60;905*)
     (push.cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 92207)
     (apply.gloc.of loop\x60;905* "../stdlib/core/destructuring.scm" . 92201))
   (ret.iloc 0 . 0))
 (set.gloc.of loop\x60;905*)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const ?_ ?pat ?expr ?body ...)
   (push.const . #f)
   (push.close
     (1 0)
     (call
       (call
         (push.iloc.0 . 0)
         (push.const . ?pat)
         (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/destructuring.scm" . 268309))
       (push)
       (apply.gloc.of \x2E;syntax->datum "../stdlib/core/destructuring.scm" . 268309))
     (push)
     (call
       (apply.gloc.of \x2E;generate-temporary-symbol "../stdlib/core/destructuring.scm" . 269335))
     (push)
     (subr.gloc.of \x2E;make-core-hashtable 0)
     (push)
     (push.const)
     (push.subr.gloc.of \x2E;vector 1 "../stdlib/core/destructuring.scm" . 271381)
     (extend . 4)
     (push.close
       (0 0)
       (push.iloc.1 . 2)
       (push.iloc.1 . 3)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.const)
       (push.const)
       (push.const)
       (apply.gloc.of
         core.destructuring\x27;compile-match
         "../stdlib/core/destructuring.scm"
         .
         273434))
     (push.close
       (3 0)
       (push.const . 0)
       (push.vector-ref.iloc (1 . 3) "../stdlib/core/destructuring.scm" . 274465)
       (push.subr.gloc.of \x2E;null? 1 "../stdlib/core/destructuring.scm" . 274458)
       (subr.gloc.of \x2E;not 1 "../stdlib/core/destructuring.scm" . 274453)
       (if.true
         (push.const . destructuring-bind)
         (push.const . "tail match not supported")
         (push.iloc 3 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of \x2E;syntax-violation "../stdlib/core/destructuring.scm" . 275477))
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of
           core.destructuring\x27;duplicates?
           "../stdlib/core/destructuring.scm"
           .
           276501))
       (if.true
         (push.const . destructuring-bind)
         (push.const . "duplicate variables")
         (push.iloc 3 . 0)
         (push.iloc.1 . 0)
         (apply.gloc.of \x2E;syntax-violation "../stdlib/core/destructuring.scm" . 277525))
       (iloc.0 . 0)
       (if.true
         (push.iloc 2 . 0)
         (call
           (call
             (push.iloc 2 . 0)
             (push.const . k)
             (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/destructuring.scm" . 279573))
           (push)
           (push.iloc.1 . 1)
           (apply.gloc.of \x2E;datum->syntax "../stdlib/core/destructuring.scm" . 279573))
         (push)
         (call
           (push.close
             (1 0)
             (call
               (push.iloc 3 . 0)
               (push.const . ?_)
               (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/destructuring.scm" . 279573))
             (push)
             (push.iloc.0 . 0)
             (apply.gloc.of \x2E;datum->syntax "../stdlib/core/destructuring.scm" . 279573))
           (push.iloc.0 . 2)
           (apply.gloc.of \x2E;map "../stdlib/core/destructuring.scm" . 279573))
         (push)
         (call
           (push.close
             (1 0)
             (call
               (push.iloc 3 . 0)
               (push.const . k)
               (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/destructuring.scm" . 279573))
             (push)
             (push.iloc.0 . 0)
             (apply.gloc.of \x2E;datum->syntax "../stdlib/core/destructuring.scm" . 279573))
           (push.iloc.0 . 1)
           (apply.gloc.of \x2E;map "../stdlib/core/destructuring.scm" . 279573))
         (push)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 279573)
         (push.const)
         (push.const ?datum (?vars ...) (?inits ...))
         (push.const . #f)
         (push.gloc.of \x2E;L296)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 279573)
         (push.const . _)
         (push.const . #f)
         (push.gloc.of \x2E;L300)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 279573)
         (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/destructuring.scm" . 279573))
       (push.const . destructuring-bind)
       (push.const . "malformed pattern")
       (push.iloc 3 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of \x2E;syntax-violation "../stdlib/core/destructuring.scm" . 288789))
     (apply.gloc.of \x2E;call-with-values "../stdlib/core/destructuring.scm" . 273434))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 266247)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/destructuring.scm" . 266247))
 (set.gloc.of \x2E;L287)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const
     (?datum (datum->syntax (syntax k) datum))
     (((?pred-lhs ?pred-rhs) ...)
      (map (lambda (a)
             (list (datum->syntax (syntax k) (cdr a)) (datum->syntax (syntax ?_) (car a))))
           (core-hashtable->alist ren)))
     ((?mem ...) (map (lambda (e) (datum->syntax (syntax k) (cdr e))) (vector-ref mem 0)))
     ((?subexprs ...) (map (lambda (e) (datum->syntax (syntax k) e)) subexprs))
     ((?dispatch ...)
      (map (lambda (clause)
             (let-values (((tests vars inits body fender) (apply values clause)))
               (with-syntax (((?vars ...) (map (lambda (e) (datum->syntax (syntax ?_) e)) vars))
                             ((?inits ...) (map (lambda (e) (datum->syntax (syntax k) e)) inits))
                             ((?tests ...) (map (lambda (e) (datum->syntax (syntax k) e)) tests))
                             (?fender fender)
                             (?body body))
                 (if (eq? (syntax->datum (syntax ?fender)) #t)
                     (syntax ((and ?tests ...) (let ((?vars ?inits) ...) ?body)))
                     (syntax
                       ((and ?tests ... (let ((?vars ?inits) ...) ?fender))
                        (let ((?vars ?inits) ...) ?body)))))))
           clauses)))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/destructuring.scm" . 329746))
 (set.gloc.of \x2E;L265)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const ?_ ?expr ?clauses ...)
   (push.const . #f)
   (push.close
     (1 0)
     (call
       (apply.gloc.of \x2E;generate-temporary-symbol "../stdlib/core/destructuring.scm" . 294935))
     (push)
     (subr.gloc.of \x2E;make-core-hashtable 0)
     (push)
     (push.const)
     (push.subr.gloc.of \x2E;vector 1 "../stdlib/core/destructuring.scm" . 296981)
     (extend . 3)
     (call
       (call
         (call
           (push.close
             (1 0)
             (push.iloc 2 . 0)
             (push.iloc.0 . 0)
             (push.const)
             (push.const ?pat)
             (push.const . #f)
             (push.close
               (1 0)
               (call
                 (call
                   (push.iloc.0 . 0)
                   (push.const . ?pat)
                   (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/destructuring.scm" . 305194))
                 (push)
                 (apply.gloc.of \x2E;syntax->datum "../stdlib/core/destructuring.scm" . 305194))
               (push)
               (extend . 1)
               (push.close
                 (0 0)
                 (push.iloc 4 . 1)
                 (push.iloc 4 . 2)
                 (push.iloc.1 . 0)
                 (push.iloc 4 . 0)
                 (push.const)
                 (push.const)
                 (push.const)
                 (apply.gloc.of
                   core.destructuring\x27;compile-match
                   "../stdlib/core/destructuring.scm"
                   .
                   306242))
               (push.close
                 (3 0)
                 (call
                   (push.iloc.0 . 2)
                   (apply.gloc.of
                     core.destructuring\x27;duplicates?
                     "../stdlib/core/destructuring.scm"
                     .
                     307242))
                 (if.true
                   (push.const . destructuring-match)
                   (push.const . "duplicate variables")
                   (push.iloc 6 . 0)
                   (push.iloc.1 . 0)
                   (apply.gloc.of
                     \x2E;syntax-violation
                     "../stdlib/core/destructuring.scm"
                     .
                     307261))
                 (iloc.0 . 0)
                 (if.true
                   (push.const . #f)
                   (push.iloc.0 . 0)
                   (push.subr.gloc.of \x2E;reverse 1 "../stdlib/core/destructuring.scm" . 308281)
                   (push.const)
                   (push.const)
                   (call
                     (push.iloc 2 . 0)
                     (push.const . #t)
                     (apply.gloc.of \x2E;syntax/c0n (\x2E;syntax/c0n \x2E;vars\x60;797* #t)))
                   (push)
                   (call
                     (push.iloc 2 . 0)
                     (push.const . #t)
                     (apply.gloc.of \x2E;syntax/c0n (\x2E;syntax/c0n \x2E;vars\x60;797* #t)))
                   (push)
                   (ret.subr.gloc.of
                     \x2E;list
                     (\x2E;list
                       #f
                       (\x2E;reverse match\x60;801*)
                       '()
                       '()
                       (\x2E;syntax/c0n \x2E;vars\x60;797* #t)
                       (\x2E;syntax/c0n \x2E;vars\x60;797* #t))))
                 (push.const . destructuring-match)
                 (push.const . "malformed pattern")
                 (push.iloc 6 . 0)
                 (push.iloc.1 . 0)
                 (apply.gloc.of \x2E;syntax-violation "../stdlib/core/destructuring.scm" . 309295))
               (apply.gloc.of
                 \x2E;call-with-values
                 (\x2E;call-with-values
                   (lambda ()
                     (core.destructuring\x27;compile-match
                       ren\x60;793*
                       mem\x60;793*
                       pat\x60;799*
                       datum\x60;793*
                       '()
                       '()
                       '()))
                   (lambda (match\x60;801* inits\x60;801* vars\x60;801*)
                     (if (core.destructuring\x27;duplicates? vars\x60;801*)
                         (\x2E;syntax-violation
                           'destructuring-match
                           "duplicate variables"
                           x\x60;789*
                           pat\x60;799*)
                         (if match\x60;801*
                             (\x2E;list
                               #f
                               (\x2E;reverse match\x60;801*)
                               '()
                               '()
                               (\x2E;syntax/c0n \x2E;vars\x60;797* #t)
                               (\x2E;syntax/c0n \x2E;vars\x60;797* #t))
                             (\x2E;syntax-violation
                               'destructuring-match
                               "malformed pattern"
                               x\x60;789*
                               pat\x60;799*)))))))
             (push.subr.gloc.of
               \x2E;list
               3
               (\x2E;list
                 '(?pat)
                 #f
                 (lambda (\x2E;vars\x60;797*)
                   (let ((pat\x60;799*
                           (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;797* '?pat))))
                     (\x2E;call-with-values
                       (lambda ()
                         (core.destructuring\x27;compile-match
                           ren\x60;793*
                           mem\x60;793*
                           pat\x60;799*
                           datum\x60;793*
                           '()
                           '()
                           '()))
                       (lambda (match\x60;801* inits\x60;801* vars\x60;801*)
                         (if (core.destructuring\x27;duplicates? vars\x60;801*)
                             (\x2E;syntax-violation
                               'destructuring-match
                               "duplicate variables"
                               x\x60;789*
                               pat\x60;799*)
                             (if match\x60;801*
                                 (\x2E;list
                                   #f
                                   (\x2E;reverse match\x60;801*)
                                   '()
                                   '()
                                   (\x2E;syntax/c0n \x2E;vars\x60;797* #t)
                                   (\x2E;syntax/c0n \x2E;vars\x60;797* #t))
                                 (\x2E;syntax-violation
                                   'destructuring-match
                                   "malformed pattern"
                                   x\x60;789*
                                   pat\x60;799*)))))))))
             (push.const ?pat ?body)
             (push.const . #f)
             (push.close
               (1 0)
               (call
                 (call
                   (push.iloc.0 . 0)
                   (push.const . ?pat)
                   (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/destructuring.scm" . 311338))
                 (push)
                 (apply.gloc.of \x2E;syntax->datum "../stdlib/core/destructuring.scm" . 311338))
               (push)
               (extend . 1)
               (push.close
                 (0 0)
                 (push.iloc 4 . 1)
                 (push.iloc 4 . 2)
                 (push.iloc.1 . 0)
                 (push.iloc 4 . 0)
                 (push.const)
                 (push.const)
                 (push.const)
                 (apply.gloc.of
                   core.destructuring\x27;compile-match
                   "../stdlib/core/destructuring.scm"
                   .
                   312386))
               (push.close
                 (3 0)
                 (call
                   (push.iloc.0 . 2)
                   (apply.gloc.of
                     core.destructuring\x27;duplicates?
                     "../stdlib/core/destructuring.scm"
                     .
                     313386))
                 (if.true
                   (push.const . destructuring-match)
                   (push.const . "duplicate variables")
                   (push.iloc 6 . 0)
                   (push.iloc.1 . 0)
                   (apply.gloc.of
                     \x2E;syntax-violation
                     "../stdlib/core/destructuring.scm"
                     .
                     313405))
                 (iloc.0 . 0)
                 (if.true
                   (push.const . #f)
                   (push.iloc.0 . 0)
                   (push.subr.gloc.of \x2E;reverse 1 "../stdlib/core/destructuring.scm" . 314425)
                   (push.iloc.0 . 2)
                   (push.iloc.0 . 1)
                   (call
                     (push.iloc 2 . 0)
                     (push.const . ?body)
                     (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/destructuring.scm" . 314452))
                   (push)
                   (call
                     (push.iloc 2 . 0)
                     (push.const . #t)
                     (apply.gloc.of \x2E;syntax/c0n (\x2E;syntax/c0n \x2E;vars\x60;803* #t)))
                   (push)
                   (ret.subr.gloc.of
                     \x2E;list
                     (\x2E;list
                       #f
                       (\x2E;reverse match\x60;807*)
                       vars\x60;807*
                       inits\x60;807*
                       (\x2E;syntax/i1n \x2E;vars\x60;803* '?body)
                       (\x2E;syntax/c0n \x2E;vars\x60;803* #t))))
                 (push.const . destructuring-match)
                 (push.const . "malformed pattern")
                 (push.iloc 6 . 0)
                 (push.iloc.1 . 0)
                 (apply.gloc.of \x2E;syntax-violation "../stdlib/core/destructuring.scm" . 315439))
               (apply.gloc.of
                 \x2E;call-with-values
                 (\x2E;call-with-values
                   (lambda ()
                     (core.destructuring\x27;compile-match
                       ren\x60;793*
                       mem\x60;793*
                       pat\x60;805*
                       datum\x60;793*
                       '()
                       '()
                       '()))
                   (lambda (match\x60;807* inits\x60;807* vars\x60;807*)
                     (if (core.destructuring\x27;duplicates? vars\x60;807*)
                         (\x2E;syntax-violation
                           'destructuring-match
                           "duplicate variables"
                           x\x60;789*
                           pat\x60;805*)
                         (if match\x60;807*
                             (\x2E;list
                               #f
                               (\x2E;reverse match\x60;807*)
                               vars\x60;807*
                               inits\x60;807*
                               (\x2E;syntax/i1n \x2E;vars\x60;803* '?body)
                               (\x2E;syntax/c0n \x2E;vars\x60;803* #t))
                             (\x2E;syntax-violation
                               'destructuring-match
                               "malformed pattern"
                               x\x60;789*
                               pat\x60;805*)))))))
             (push.subr.gloc.of
               \x2E;list
               3
               (\x2E;list
                 '(?pat ?body)
                 #f
                 (lambda (\x2E;vars\x60;803*)
                   (let ((pat\x60;805*
                           (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;803* '?pat))))
                     (\x2E;call-with-values
                       (lambda ()
                         (core.destructuring\x27;compile-match
                           ren\x60;793*
                           mem\x60;793*
                           pat\x60;805*
                           datum\x60;793*
                           '()
                           '()
                           '()))
                       (lambda (match\x60;807* inits\x60;807* vars\x60;807*)
                         (if (core.destructuring\x27;duplicates? vars\x60;807*)
                             (\x2E;syntax-violation
                               'destructuring-match
                               "duplicate variables"
                               x\x60;789*
                               pat\x60;805*)
                             (if match\x60;807*
                                 (\x2E;list
                                   #f
                                   (\x2E;reverse match\x60;807*)
                                   vars\x60;807*
                                   inits\x60;807*
                                   (\x2E;syntax/i1n \x2E;vars\x60;803* '?body)
                                   (\x2E;syntax/c0n \x2E;vars\x60;803* #t))
                                 (\x2E;syntax-violation
                                   'destructuring-match
                                   "malformed pattern"
                                   x\x60;789*
                                   pat\x60;805*)))))))))
             (push.const ?pat ?fender ?body)
             (push.const . #f)
             (push.close
               (1 0)
               (call
                 (call
                   (push.iloc.0 . 0)
                   (push.const . ?pat)
                   (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/destructuring.scm" . 317482))
                 (push)
                 (apply.gloc.of \x2E;syntax->datum "../stdlib/core/destructuring.scm" . 317482))
               (push)
               (extend . 1)
               (push.close
                 (0 0)
                 (push.iloc 4 . 1)
                 (push.iloc 4 . 2)
                 (push.iloc.1 . 0)
                 (push.iloc 4 . 0)
                 (push.const)
                 (push.const)
                 (push.const)
                 (apply.gloc.of
                   core.destructuring\x27;compile-match
                   "../stdlib/core/destructuring.scm"
                   .
                   318530))
               (push.close
                 (3 0)
                 (call
                   (push.iloc.0 . 2)
                   (apply.gloc.of
                     core.destructuring\x27;duplicates?
                     "../stdlib/core/destructuring.scm"
                     .
                     319530))
                 (if.true
                   (push.const . destructuring-match)
                   (push.const . "duplicate variables")
                   (push.iloc 6 . 0)
                   (push.iloc.1 . 0)
                   (apply.gloc.of
                     \x2E;syntax-violation
                     "../stdlib/core/destructuring.scm"
                     .
                     319549))
                 (iloc.0 . 0)
                 (if.true
                   (push.const . #f)
                   (push.iloc.0 . 0)
                   (push.subr.gloc.of \x2E;reverse 1 "../stdlib/core/destructuring.scm" . 320569)
                   (push.iloc.0 . 2)
                   (push.iloc.0 . 1)
                   (call
                     (push.iloc 2 . 0)
                     (push.const . ?body)
                     (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/destructuring.scm" . 320596))
                   (push)
                   (call
                     (push.iloc 2 . 0)
                     (push.const . ?fender)
                     (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/destructuring.scm" . 320611))
                   (push)
                   (ret.subr.gloc.of \x2E;list "../stdlib/core/destructuring.scm" . 320560))
                 (push.const . destructuring-match)
                 (push.const . "malformed pattern")
                 (push.iloc 6 . 0)
                 (push.iloc.1 . 0)
                 (apply.gloc.of \x2E;syntax-violation "../stdlib/core/destructuring.scm" . 321583))
               (apply.gloc.of
                 \x2E;call-with-values
                 (\x2E;call-with-values
                   (lambda ()
                     (core.destructuring\x27;compile-match
                       ren\x60;793*
                       mem\x60;793*
                       pat\x60;811*
                       datum\x60;793*
                       '()
                       '()
                       '()))
                   (lambda (match\x60;813* inits\x60;813* vars\x60;813*)
                     (if (core.destructuring\x27;duplicates? vars\x60;813*)
                         (\x2E;syntax-violation
                           'destructuring-match
                           "duplicate variables"
                           x\x60;789*
                           pat\x60;811*)
                         (if match\x60;813*
                             (\x2E;list
                               #f
                               (\x2E;reverse match\x60;813*)
                               vars\x60;813*
                               inits\x60;813*
                               (\x2E;syntax/i1n \x2E;vars\x60;809* '?body)
                               (\x2E;syntax/i1n \x2E;vars\x60;809* '?fender))
                             (\x2E;syntax-violation
                               'destructuring-match
                               "malformed pattern"
                               x\x60;789*
                               pat\x60;811*)))))))
             (push.subr.gloc.of
               \x2E;list
               3
               (\x2E;list
                 '(?pat ?fender ?body)
                 #f
                 (lambda (\x2E;vars\x60;809*)
                   (let ((pat\x60;811*
                           (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;809* '?pat))))
                     (\x2E;call-with-values
                       (lambda ()
                         (core.destructuring\x27;compile-match
                           ren\x60;793*
                           mem\x60;793*
                           pat\x60;811*
                           datum\x60;793*
                           '()
                           '()
                           '()))
                       (lambda (match\x60;813* inits\x60;813* vars\x60;813*)
                         (if (core.destructuring\x27;duplicates? vars\x60;813*)
                             (\x2E;syntax-violation
                               'destructuring-match
                               "duplicate variables"
                               x\x60;789*
                               pat\x60;811*)
                             (if match\x60;813*
                                 (\x2E;list
                                   #f
                                   (\x2E;reverse match\x60;813*)
                                   vars\x60;813*
                                   inits\x60;813*
                                   (\x2E;syntax/i1n \x2E;vars\x60;809* '?body)
                                   (\x2E;syntax/i1n \x2E;vars\x60;809* '?fender))
                                 (\x2E;syntax-violation
                                   'destructuring-match
                                   "malformed pattern"
                                   x\x60;789*
                                   pat\x60;811*)))))))))
             (push.const . _)
             (push.const . #f)
             (push.close
               (1 0)
               (push.const . destructuring-match)
               (push.const . "malformed clause")
               (push.iloc 4 . 0)
               (push.iloc.1 . 0)
               (apply.gloc.of \x2E;syntax-violation "../stdlib/core/destructuring.scm" . 323615))
             (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 303132)
             (apply.gloc.of
               \x2E;syntax-dispatch
               (\x2E;syntax-dispatch
                 \x2E;vars\x60;791*
                 clause\x60;795*
                 '()
                 (\x2E;list
                   '(?pat)
                   #f
                   (lambda (\x2E;vars\x60;797*)
                     (let ((pat\x60;799*
                             (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;797* '?pat))))
                       (\x2E;call-with-values
                         (lambda ()
                           (core.destructuring\x27;compile-match
                             ren\x60;793*
                             mem\x60;793*
                             pat\x60;799*
                             datum\x60;793*
                             '()
                             '()
                             '()))
                         (lambda (match\x60;801* inits\x60;801* vars\x60;801*)
                           (if (core.destructuring\x27;duplicates? vars\x60;801*)
                               (\x2E;syntax-violation
                                 'destructuring-match
                                 "duplicate variables"
                                 x\x60;789*
                                 pat\x60;799*)
                               (if match\x60;801*
                                   (\x2E;list
                                     #f
                                     (\x2E;reverse match\x60;801*)
                                     '()
                                     '()
                                     (\x2E;syntax/c0n \x2E;vars\x60;797* #t)
                                     (\x2E;syntax/c0n \x2E;vars\x60;797* #t))
                                   (\x2E;syntax-violation
                                     'destructuring-match
                                     "malformed pattern"
                                     x\x60;789*
                                     pat\x60;799*))))))))
                 (\x2E;list
                   '(?pat ?body)
                   #f
                   (lambda (\x2E;vars\x60;803*)
                     (let ((pat\x60;805*
                             (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;803* '?pat))))
                       (\x2E;call-with-values
                         (lambda ()
                           (core.destructuring\x27;compile-match
                             ren\x60;793*
                             mem\x60;793*
                             pat\x60;805*
                             datum\x60;793*
                             '()
                             '()
                             '()))
                         (lambda (match\x60;807* inits\x60;807* vars\x60;807*)
                           (if (core.destructuring\x27;duplicates? vars\x60;807*)
                               (\x2E;syntax-violation
                                 'destructuring-match
                                 "duplicate variables"
                                 x\x60;789*
                                 pat\x60;805*)
                               (if match\x60;807*
                                   (\x2E;list
                                     #f
                                     (\x2E;reverse match\x60;807*)
                                     vars\x60;807*
                                     inits\x60;807*
                                     (\x2E;syntax/i1n \x2E;vars\x60;803* '?body)
                                     (\x2E;syntax/c0n \x2E;vars\x60;803* #t))
                                   (\x2E;syntax-violation
                                     'destructuring-match
                                     "malformed pattern"
                                     x\x60;789*
                                     pat\x60;805*))))))))
                 (\x2E;list
                   '(?pat ?fender ?body)
                   #f
                   (lambda (\x2E;vars\x60;809*)
                     (let ((pat\x60;811*
                             (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;809* '?pat))))
                       (\x2E;call-with-values
                         (lambda ()
                           (core.destructuring\x27;compile-match
                             ren\x60;793*
                             mem\x60;793*
                             pat\x60;811*
                             datum\x60;793*
                             '()
                             '()
                             '()))
                         (lambda (match\x60;813* inits\x60;813* vars\x60;813*)
                           (if (core.destructuring\x27;duplicates? vars\x60;813*)
                               (\x2E;syntax-violation
                                 'destructuring-match
                                 "duplicate variables"
                                 x\x60;789*
                                 pat\x60;811*)
                               (if match\x60;813*
                                   (\x2E;list
                                     #f
                                     (\x2E;reverse match\x60;813*)
                                     vars\x60;813*
                                     inits\x60;813*
                                     (\x2E;syntax/i1n \x2E;vars\x60;809* '?body)
                                     (\x2E;syntax/i1n \x2E;vars\x60;809* '?fender))
                                   (\x2E;syntax-violation
                                     'destructuring-match
                                     "malformed pattern"
                                     x\x60;789*
                                     pat\x60;811*))))))))
                 (\x2E;list
                   '_
                   #f
                   (lambda (\x2E;vars\x60;815*)
                     (\x2E;syntax-violation
                       'destructuring-match
                       "malformed clause"
                       x\x60;789*
                       clause\x60;795*))))))
           (call
             (push.iloc.1 . 0)
             (push.const ?clauses ...)
             (push.const (?clauses . 1))
             (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/destructuring.scm" . 324634))
           (push)
           (apply.gloc.of
             \x2E;map
             (\x2E;map
               (lambda (clause\x60;795*)
                 (\x2E;syntax-dispatch
                   \x2E;vars\x60;791*
                   clause\x60;795*
                   '()
                   (\x2E;list
                     '(?pat)
                     #f
                     (lambda (\x2E;vars\x60;797*)
                       (let ((pat\x60;799*
                               (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;797* '?pat))))
                         (\x2E;call-with-values
                           (lambda ()
                             (core.destructuring\x27;compile-match
                               ren\x60;793*
                               mem\x60;793*
                               pat\x60;799*
                               datum\x60;793*
                               '()
                               '()
                               '()))
                           (lambda (match\x60;801* inits\x60;801* vars\x60;801*)
                             (if (core.destructuring\x27;duplicates? vars\x60;801*)
                                 (\x2E;syntax-violation
                                   'destructuring-match
                                   "duplicate variables"
                                   x\x60;789*
                                   pat\x60;799*)
                                 (if match\x60;801*
                                     (\x2E;list
                                       #f
                                       (\x2E;reverse match\x60;801*)
                                       '()
                                       '()
                                       (\x2E;syntax/c0n \x2E;vars\x60;797* #t)
                                       (\x2E;syntax/c0n \x2E;vars\x60;797* #t))
                                     (\x2E;syntax-violation
                                       'destructuring-match
                                       "malformed pattern"
                                       x\x60;789*
                                       pat\x60;799*))))))))
                   (\x2E;list
                     '(?pat ?body)
                     #f
                     (lambda (\x2E;vars\x60;803*)
                       (let ((pat\x60;805*
                               (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;803* '?pat))))
                         (\x2E;call-with-values
                           (lambda ()
                             (core.destructuring\x27;compile-match
                               ren\x60;793*
                               mem\x60;793*
                               pat\x60;805*
                               datum\x60;793*
                               '()
                               '()
                               '()))
                           (lambda (match\x60;807* inits\x60;807* vars\x60;807*)
                             (if (core.destructuring\x27;duplicates? vars\x60;807*)
                                 (\x2E;syntax-violation
                                   'destructuring-match
                                   "duplicate variables"
                                   x\x60;789*
                                   pat\x60;805*)
                                 (if match\x60;807*
                                     (\x2E;list
                                       #f
                                       (\x2E;reverse match\x60;807*)
                                       vars\x60;807*
                                       inits\x60;807*
                                       (\x2E;syntax/i1n \x2E;vars\x60;803* '?body)
                                       (\x2E;syntax/c0n \x2E;vars\x60;803* #t))
                                     (\x2E;syntax-violation
                                       'destructuring-match
                                       "malformed pattern"
                                       x\x60;789*
                                       pat\x60;805*))))))))
                   (\x2E;list
                     '(?pat ?fender ?body)
                     #f
                     (lambda (\x2E;vars\x60;809*)
                       (let ((pat\x60;811*
                               (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;809* '?pat))))
                         (\x2E;call-with-values
                           (lambda ()
                             (core.destructuring\x27;compile-match
                               ren\x60;793*
                               mem\x60;793*
                               pat\x60;811*
                               datum\x60;793*
                               '()
                               '()
                               '()))
                           (lambda (match\x60;813* inits\x60;813* vars\x60;813*)
                             (if (core.destructuring\x27;duplicates? vars\x60;813*)
                                 (\x2E;syntax-violation
                                   'destructuring-match
                                   "duplicate variables"
                                   x\x60;789*
                                   pat\x60;811*)
                                 (if match\x60;813*
                                     (\x2E;list
                                       #f
                                       (\x2E;reverse match\x60;813*)
                                       vars\x60;813*
                                       inits\x60;813*
                                       (\x2E;syntax/i1n \x2E;vars\x60;809* '?body)
                                       (\x2E;syntax/i1n \x2E;vars\x60;809* '?fender))
                                     (\x2E;syntax-violation
                                       'destructuring-match
                                       "malformed pattern"
                                       x\x60;789*
                                       pat\x60;811*))))))))
                   (\x2E;list
                     '_
                     #f
                     (lambda (\x2E;vars\x60;815*)
                       (\x2E;syntax-violation
                         'destructuring-match
                         "malformed clause"
                         x\x60;789*
                         clause\x60;795*)))))
               (\x2E;syntax/c1n \x2E;vars\x60;791* '(?clauses ...) '((?clauses . 1))))))
         (push)
         (apply.gloc.of
           core.destructuring\x27;reorder
           (core.destructuring\x27;reorder
             (\x2E;map
               (lambda (clause\x60;795*)
                 (\x2E;syntax-dispatch
                   \x2E;vars\x60;791*
                   clause\x60;795*
                   '()
                   (\x2E;list
                     '(?pat)
                     #f
                     (lambda (\x2E;vars\x60;797*)
                       (let ((pat\x60;799*
                               (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;797* '?pat))))
                         (\x2E;call-with-values
                           (lambda ()
                             (core.destructuring\x27;compile-match
                               ren\x60;793*
                               mem\x60;793*
                               pat\x60;799*
                               datum\x60;793*
                               '()
                               '()
                               '()))
                           (lambda (match\x60;801* inits\x60;801* vars\x60;801*)
                             (if (core.destructuring\x27;duplicates? vars\x60;801*)
                                 (\x2E;syntax-violation
                                   'destructuring-match
                                   "duplicate variables"
                                   x\x60;789*
                                   pat\x60;799*)
                                 (if match\x60;801*
                                     (\x2E;list
                                       #f
                                       (\x2E;reverse match\x60;801*)
                                       '()
                                       '()
                                       (\x2E;syntax/c0n \x2E;vars\x60;797* #t)
                                       (\x2E;syntax/c0n \x2E;vars\x60;797* #t))
                                     (\x2E;syntax-violation
                                       'destructuring-match
                                       "malformed pattern"
                                       x\x60;789*
                                       pat\x60;799*))))))))
                   (\x2E;list
                     '(?pat ?body)
                     #f
                     (lambda (\x2E;vars\x60;803*)
                       (let ((pat\x60;805*
                               (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;803* '?pat))))
                         (\x2E;call-with-values
                           (lambda ()
                             (core.destructuring\x27;compile-match
                               ren\x60;793*
                               mem\x60;793*
                               pat\x60;805*
                               datum\x60;793*
                               '()
                               '()
                               '()))
                           (lambda (match\x60;807* inits\x60;807* vars\x60;807*)
                             (if (core.destructuring\x27;duplicates? vars\x60;807*)
                                 (\x2E;syntax-violation
                                   'destructuring-match
                                   "duplicate variables"
                                   x\x60;789*
                                   pat\x60;805*)
                                 (if match\x60;807*
                                     (\x2E;list
                                       #f
                                       (\x2E;reverse match\x60;807*)
                                       vars\x60;807*
                                       inits\x60;807*
                                       (\x2E;syntax/i1n \x2E;vars\x60;803* '?body)
                                       (\x2E;syntax/c0n \x2E;vars\x60;803* #t))
                                     (\x2E;syntax-violation
                                       'destructuring-match
                                       "malformed pattern"
                                       x\x60;789*
                                       pat\x60;805*))))))))
                   (\x2E;list
                     '(?pat ?fender ?body)
                     #f
                     (lambda (\x2E;vars\x60;809*)
                       (let ((pat\x60;811*
                               (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;809* '?pat))))
                         (\x2E;call-with-values
                           (lambda ()
                             (core.destructuring\x27;compile-match
                               ren\x60;793*
                               mem\x60;793*
                               pat\x60;811*
                               datum\x60;793*
                               '()
                               '()
                               '()))
                           (lambda (match\x60;813* inits\x60;813* vars\x60;813*)
                             (if (core.destructuring\x27;duplicates? vars\x60;813*)
                                 (\x2E;syntax-violation
                                   'destructuring-match
                                   "duplicate variables"
                                   x\x60;789*
                                   pat\x60;811*)
                                 (if match\x60;813*
                                     (\x2E;list
                                       #f
                                       (\x2E;reverse match\x60;813*)
                                       vars\x60;813*
                                       inits\x60;813*
                                       (\x2E;syntax/i1n \x2E;vars\x60;809* '?body)
                                       (\x2E;syntax/i1n \x2E;vars\x60;809* '?fender))
                                     (\x2E;syntax-violation
                                       'destructuring-match
                                       "malformed pattern"
                                       x\x60;789*
                                       pat\x60;811*))))))))
                   (\x2E;list
                     '_
                     #f
                     (lambda (\x2E;vars\x60;815*)
                       (\x2E;syntax-violation
                         'destructuring-match
                         "malformed clause"
                         x\x60;789*
                         clause\x60;795*)))))
               (\x2E;syntax/c1n \x2E;vars\x60;791* '(?clauses ...) '((?clauses . 1)))))))
       (push)
       (apply.gloc.of
         core.destructuring\x27;cse
         (core.destructuring\x27;cse
           (core.destructuring\x27;reorder
             (\x2E;map
               (lambda (clause\x60;795*)
                 (\x2E;syntax-dispatch
                   \x2E;vars\x60;791*
                   clause\x60;795*
                   '()
                   (\x2E;list
                     '(?pat)
                     #f
                     (lambda (\x2E;vars\x60;797*)
                       (let ((pat\x60;799*
                               (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;797* '?pat))))
                         (\x2E;call-with-values
                           (lambda ()
                             (core.destructuring\x27;compile-match
                               ren\x60;793*
                               mem\x60;793*
                               pat\x60;799*
                               datum\x60;793*
                               '()
                               '()
                               '()))
                           (lambda (match\x60;801* inits\x60;801* vars\x60;801*)
                             (if (core.destructuring\x27;duplicates? vars\x60;801*)
                                 (\x2E;syntax-violation
                                   'destructuring-match
                                   "duplicate variables"
                                   x\x60;789*
                                   pat\x60;799*)
                                 (if match\x60;801*
                                     (\x2E;list
                                       #f
                                       (\x2E;reverse match\x60;801*)
                                       '()
                                       '()
                                       (\x2E;syntax/c0n \x2E;vars\x60;797* #t)
                                       (\x2E;syntax/c0n \x2E;vars\x60;797* #t))
                                     (\x2E;syntax-violation
                                       'destructuring-match
                                       "malformed pattern"
                                       x\x60;789*
                                       pat\x60;799*))))))))
                   (\x2E;list
                     '(?pat ?body)
                     #f
                     (lambda (\x2E;vars\x60;803*)
                       (let ((pat\x60;805*
                               (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;803* '?pat))))
                         (\x2E;call-with-values
                           (lambda ()
                             (core.destructuring\x27;compile-match
                               ren\x60;793*
                               mem\x60;793*
                               pat\x60;805*
                               datum\x60;793*
                               '()
                               '()
                               '()))
                           (lambda (match\x60;807* inits\x60;807* vars\x60;807*)
                             (if (core.destructuring\x27;duplicates? vars\x60;807*)
                                 (\x2E;syntax-violation
                                   'destructuring-match
                                   "duplicate variables"
                                   x\x60;789*
                                   pat\x60;805*)
                                 (if match\x60;807*
                                     (\x2E;list
                                       #f
                                       (\x2E;reverse match\x60;807*)
                                       vars\x60;807*
                                       inits\x60;807*
                                       (\x2E;syntax/i1n \x2E;vars\x60;803* '?body)
                                       (\x2E;syntax/c0n \x2E;vars\x60;803* #t))
                                     (\x2E;syntax-violation
                                       'destructuring-match
                                       "malformed pattern"
                                       x\x60;789*
                                       pat\x60;805*))))))))
                   (\x2E;list
                     '(?pat ?fender ?body)
                     #f
                     (lambda (\x2E;vars\x60;809*)
                       (let ((pat\x60;811*
                               (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;809* '?pat))))
                         (\x2E;call-with-values
                           (lambda ()
                             (core.destructuring\x27;compile-match
                               ren\x60;793*
                               mem\x60;793*
                               pat\x60;811*
                               datum\x60;793*
                               '()
                               '()
                               '()))
                           (lambda (match\x60;813* inits\x60;813* vars\x60;813*)
                             (if (core.destructuring\x27;duplicates? vars\x60;813*)
                                 (\x2E;syntax-violation
                                   'destructuring-match
                                   "duplicate variables"
                                   x\x60;789*
                                   pat\x60;811*)
                                 (if match\x60;813*
                                     (\x2E;list
                                       #f
                                       (\x2E;reverse match\x60;813*)
                                       vars\x60;813*
                                       inits\x60;813*
                                       (\x2E;syntax/i1n \x2E;vars\x60;809* '?body)
                                       (\x2E;syntax/i1n \x2E;vars\x60;809* '?fender))
                                     (\x2E;syntax-violation
                                       'destructuring-match
                                       "malformed pattern"
                                       x\x60;789*
                                       pat\x60;811*))))))))
                   (\x2E;list
                     '_
                     #f
                     (lambda (\x2E;vars\x60;815*)
                       (\x2E;syntax-violation
                         'destructuring-match
                         "malformed clause"
                         x\x60;789*
                         clause\x60;795*)))))
               (\x2E;syntax/c1n \x2E;vars\x60;791* '(?clauses ...) '((?clauses . 1))))))))
     (push)
     (extend . 1)
     (push.close
       (0 0)
       (push.gloc.of \x2E;car)
       (push.iloc.1 . 0)
       (apply.gloc.of core.lists\x27;partition "../stdlib/core/destructuring.scm" . 326700))
     (push.close
       (2 0)
       (call
         (push.gloc.of \x2E;L277)
         (push.iloc.0 . 0)
         (apply.gloc.of \x2E;map "../stdlib/core/destructuring.scm" . 327712))
       (push)
       (call
         (push.gloc.of \x2E;cdr)
         (push.iloc.0 . 1)
         (apply.gloc.of \x2E;map "../stdlib/core/destructuring.scm" . 328735))
       (push)
       (extend . 2)
       (push.iloc 4 . 0)
       (call
         (call
           (push.iloc 4 . 0)
           (push.const . k)
           (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/destructuring.scm" . 329746))
         (push)
         (push.iloc 3 . 0)
         (apply.gloc.of \x2E;datum->syntax "../stdlib/core/destructuring.scm" . 329746))
       (push)
       (call
         (push.close
           (1 0)
           (call
             (call
               (push.iloc 5 . 0)
               (push.const . k)
               (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/destructuring.scm" . 329746))
             (push)
             (push.cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 329746)
             (apply.gloc.of \x2E;datum->syntax "../stdlib/core/destructuring.scm" . 329746))
           (push)
           (call
             (call
               (push.iloc 5 . 0)
               (push.const . ?_)
               (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/destructuring.scm" . 329746))
             (push)
             (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 329746)
             (apply.gloc.of \x2E;datum->syntax "../stdlib/core/destructuring.scm" . 329746))
           (push)
           (ret.subr.gloc.of \x2E;list "../stdlib/core/destructuring.scm" . 329746))
         (push.iloc 3 . 1)
         (push.subr.gloc.of
           \x2E;core-hashtable->alist
           1
           "../stdlib/core/destructuring.scm"
           .
           329746)
         (apply.gloc.of \x2E;map "../stdlib/core/destructuring.scm" . 329746))
       (push)
       (call
         (push.close
           (1 0)
           (call
             (push.iloc 5 . 0)
             (push.const . k)
             (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/destructuring.scm" . 329746))
           (push)
           (push.cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 329746)
           (apply.gloc.of \x2E;datum->syntax "../stdlib/core/destructuring.scm" . 329746))
         (push.const . 0)
         (push.vector-ref.iloc (3 . 2) "../stdlib/core/destructuring.scm" . 329746)
         (apply.gloc.of \x2E;map "../stdlib/core/destructuring.scm" . 329746))
       (push)
       (call
         (push.close
           (1 0)
           (call
             (push.iloc 5 . 0)
             (push.const . k)
             (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/destructuring.scm" . 329746))
           (push)
           (push.iloc.0 . 0)
           (apply.gloc.of \x2E;datum->syntax "../stdlib/core/destructuring.scm" . 329746))
         (push.iloc.0 . 0)
         (apply.gloc.of \x2E;map "../stdlib/core/destructuring.scm" . 329746))
       (push)
       (call
         (push.close
           (1 0)
           (push.close
             (0 0)
             (push.gloc.of \x2E;values)
             (push.iloc.1 . 0)
             (apply.gloc.of \x2E;apply "../stdlib/core/destructuring.scm" . 329746))
           (push.close
             (5 0)
             (push.iloc 6 . 0)
             (call
               (push.close
                 (1 0)
                 (call
                   (push.iloc 7 . 0)
                   (push.const . ?_)
                   (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/destructuring.scm" . 329746))
                 (push)
                 (push.iloc.0 . 0)
                 (apply.gloc.of \x2E;datum->syntax "../stdlib/core/destructuring.scm" . 329746))
               (push.iloc.0 . 1)
               (apply.gloc.of \x2E;map "../stdlib/core/destructuring.scm" . 329746))
             (push)
             (call
               (push.close
                 (1 0)
                 (call
                   (push.iloc 7 . 0)
                   (push.const . k)
                   (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/destructuring.scm" . 329746))
                 (push)
                 (push.iloc.0 . 0)
                 (apply.gloc.of \x2E;datum->syntax "../stdlib/core/destructuring.scm" . 329746))
               (push.iloc.0 . 2)
               (apply.gloc.of \x2E;map "../stdlib/core/destructuring.scm" . 329746))
             (push)
             (call
               (push.close
                 (1 0)
                 (call
                   (push.iloc 7 . 0)
                   (push.const . k)
                   (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/destructuring.scm" . 329746))
                 (push)
                 (push.iloc.0 . 0)
                 (apply.gloc.of \x2E;datum->syntax "../stdlib/core/destructuring.scm" . 329746))
               (push.iloc.0 . 0)
               (apply.gloc.of \x2E;map "../stdlib/core/destructuring.scm" . 329746))
             (push)
             (push.iloc.0 . 4)
             (push.iloc.0 . 3)
             (push.subr.gloc.of \x2E;list 5 "../stdlib/core/destructuring.scm" . 329746)
             (push.const)
             (push.const (?vars ...) (?inits ...) (?tests ...) ?fender ?body)
             (push.const . #f)
             (push.gloc.of \x2E;L292)
             (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 329746)
             (push.const . _)
             (push.const . #f)
             (push.gloc.of \x2E;L275)
             (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 329746)
             (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/destructuring.scm" . 329746))
           (apply.gloc.of \x2E;call-with-values "../stdlib/core/destructuring.scm" . 329746))
         (push.iloc.0 . 1)
         (apply.gloc.of \x2E;map "../stdlib/core/destructuring.scm" . 329746))
       (push)
       (push.subr.gloc.of \x2E;list 5 "../stdlib/core/destructuring.scm" . 329746)
       (push.const)
       (push.const ?datum ((?pred-lhs ?pred-rhs) ...) (?mem ...) (?subexprs ...) (?dispatch ...))
       (push.const . #f)
       (push.gloc.of \x2E;L286)
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 329746)
       (push.const . _)
       (push.const . #f)
       (push.gloc.of \x2E;L265)
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 329746)
       (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/destructuring.scm" . 329746))
     (apply.gloc.of \x2E;call-with-values "../stdlib/core/destructuring.scm" . 326700))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 292871)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/destructuring.scm" . 292871))
 (set.gloc.of \x2E;L305)
 (call
   (push.const core syntax-case)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/destructuring.scm" . 75792))
 (call
   (push.const core lists)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/destructuring.scm" . 75792))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/destructuring.scm" . 75792))
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/destructuring.scm" . 15378)
 (set.gloc.of core.destructuring\x27;ca---r)
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/destructuring.scm" . 17426)
 (set.gloc.of core.destructuring\x27;cd---r)
 (close
   (1 0 . core.destructuring\x27;car+)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.gloc.of core.destructuring\x27;ca---r)
     (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 21563)
     (push.const . #f)
     (ret.subr.gloc.of \x2E;core-hashtable-ref "../stdlib/core/destructuring.scm" . 21536))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (cdr.iloc (1 . 0) "../stdlib/core/destructuring.scm" . 23579)
     (ret.cons "../stdlib/core/destructuring.scm" . 23571))
   (push.const . car)
   (push.iloc.1 . 0)
   (ret.subr.gloc.of \x2E;list "../stdlib/core/destructuring.scm" . 25614))
 (set.gloc.of core.destructuring\x27;car+)
 (close
   (1 0 . core.destructuring\x27;cdr+)
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.gloc.of core.destructuring\x27;cd---r)
     (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 29755)
     (push.const . #f)
     (ret.subr.gloc.of \x2E;core-hashtable-ref "../stdlib/core/destructuring.scm" . 29728))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (cdr.iloc (1 . 0) "../stdlib/core/destructuring.scm" . 31771)
     (ret.cons "../stdlib/core/destructuring.scm" . 31763))
   (push.const . cdr)
   (push.iloc.1 . 0)
   (ret.subr.gloc.of \x2E;list "../stdlib/core/destructuring.scm" . 33806))
 (set.gloc.of core.destructuring\x27;cdr+)
 (close
   (1 0 . core.destructuring\x27;duplicates?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (touch.gloc.of loop\x60;873*)
   (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 38941)
   (push.cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 38958)
   (apply.gloc.of loop\x60;873* "../stdlib/core/destructuring.scm" . 39950))
 (set.gloc.of core.destructuring\x27;duplicates?)
 (close
   (1 0 . core.destructuring\x27;ellipsis-pair?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 47125)
   (if.not.symbol?.ret.const . #f)
   (cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 48147)
   (if.not.pair?.ret.const . #f)
   (push.cadr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 49169)
   (const . ...)
   (ret.eq? "../stdlib/core/destructuring.scm" . 49164))
 (set.gloc.of core.destructuring\x27;ellipsis-pair?)
 (close
   (1 0 . core.destructuring\x27;quoted-pair?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 54289)
   (const . quote)
   (if.not.eq?.ret.const . #f)
   (cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 55315)
   (if.not.pair?.ret.const . #f)
   (cddr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 56339)
   (ret.null? "../stdlib/core/destructuring.scm" . 56332))
 (set.gloc.of core.destructuring\x27;quoted-pair?)
 (close
   (1 0 . core.destructuring\x27;predicate-pair?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 61457)
   (const . ?)
   (if.not.eq?.ret.const . #f)
   (cdr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 62483)
   (ret.pair? "../stdlib/core/destructuring.scm" . 62476))
 (set.gloc.of core.destructuring\x27;predicate-pair?)
 (close
   (1 0 . core.destructuring\x27;choose-pred)
   (call
     (iloc.0 . 0)
     (if.symbol?.ret.const . #t)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;boolean? 1 "../stdlib/core/destructuring.scm" . 66592)
     (if.true.ret)
     (iloc.0 . 0)
     (if.null?.ret.const . #t)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;char? 1 "../stdlib/core/destructuring.scm" . 66619)
     (if.true.ret)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of \x2E;fixnum? "../stdlib/core/destructuring.scm" . 66631))
   (if.true.ret.const . eq?)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;number? 1 "../stdlib/core/destructuring.scm" . 67598)
   (if.true.ret.const . eqv?)
   (ret.const . equal?))
 (set.gloc.of core.destructuring\x27;choose-pred)
 (close
   (1 0 . core.destructuring\x27;drop-last-pair)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (touch.gloc.of loop\x60;889*)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;889* "../stdlib/core/destructuring.scm" . 75792))
 (set.gloc.of core.destructuring\x27;drop-last-pair)
 (close
   (1 0 . core.destructuring\x27;drop-last-cdr)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (touch.gloc.of loop\x60;897*)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;897* "../stdlib/core/destructuring.scm" . 83984))
 (set.gloc.of core.destructuring\x27;drop-last-cdr)
 (close
   (1 0 . core.destructuring\x27;last-pair)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (touch.gloc.of loop\x60;905*)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;905* "../stdlib/core/destructuring.scm" . 92176))
 (set.gloc.of core.destructuring\x27;last-pair)
 (close
   (1 0 . core.destructuring\x27;last-cdr)
   (iloc.0 . 0)
   (if.pair?
     (touch.gloc.of loop\x60;913*)
     (push.iloc.0 . 0)
     (apply.gloc.of loop\x60;913* "../stdlib/core/destructuring.scm" . 99344))
   (ret.iloc 0 . 0))
 (set.gloc.of core.destructuring\x27;last-cdr)
 (close
   (1 0 . core.destructuring\x27;count-pair)
   (touch.gloc.of loop\x60;921*)
   (push.iloc.0 . 0)
   (push.const . 0)
   (apply.gloc.of loop\x60;921* "../stdlib/core/destructuring.scm" . 106505))
 (set.gloc.of core.destructuring\x27;count-pair)
 (close
   (2 0 . core.destructuring\x27;last-n-pair)
   (call
     (push.iloc.0 . 1)
     (apply.gloc.of core.destructuring\x27;count-pair "../stdlib/core/destructuring.scm" . 111632))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (<.iloc (1 . 0) "../stdlib/core/destructuring.scm" . 112656)
   (if.true.ret.const)
   (push.iloc.1 . 1)
   (push.iloc.0 . 0)
   (push.iloc.1 . 0)
   (push.subr.gloc.of \x2E;- 2 "../stdlib/core/destructuring.scm" . 113700)
   (ret.subr.gloc.of \x2E;list-tail "../stdlib/core/destructuring.scm" . 113685))
 (set.gloc.of core.destructuring\x27;last-n-pair)
 (close
   (2 0 . core.destructuring\x27;drop-last-n-pair)
   (iloc.0 . 1)
   (if.null?.ret.const)
   (touch.gloc.of loop\x60;933*)
   (push.iloc.0 . 1)
   (call
     (push.iloc.0 . 1)
     (apply.gloc.of core.destructuring\x27;count-pair "../stdlib/core/destructuring.scm" . 119849))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;- 2 "../stdlib/core/destructuring.scm" . 119846)
   (apply.gloc.of loop\x60;933* "../stdlib/core/destructuring.scm" . 120848))
 (set.gloc.of core.destructuring\x27;drop-last-n-pair)
 (close
   (1 0 . core.destructuring\x27;count-non-dotted-pattern)
   (touch.gloc.of loop\x60;941*)
   (push.iloc.0 . 0)
   (push.const . 0)
   (apply.gloc.of loop\x60;941* "../stdlib/core/destructuring.scm" . 128009))
 (set.gloc.of core.destructuring\x27;count-non-dotted-pattern)
 (close
   (2 0 . core.destructuring\x27;memoize-ref)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.vector-ref.iloc (0 . 1) "../stdlib/core/destructuring.scm" . 135191)
   (push.subr.gloc.of \x2E;assoc 2 "../stdlib/core/destructuring.scm" . 135182)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (ret.subr.gloc.of \x2E;cdr "../stdlib/core/destructuring.scm" . 137230))
   (call (apply.gloc.of \x2E;generate-temporary-symbol "../stdlib/core/destructuring.scm" . 137242))
   (push)
   (extend . 1)
   (push.iloc 2 . 1)
   (push.const . 0)
   (push.iloc 2 . 0)
   (iloc.0 . 0)
   (push.cons)
   (const . 0)
   (vector-ref.iloc (2 . 1) "../stdlib/core/destructuring.scm" . 138302)
   (push.cons)
   (subr.gloc.of \x2E;vector-set! 3 "../stdlib/core/destructuring.scm" . 138263)
   (ret.iloc 0 . 0))
 (set.gloc.of core.destructuring\x27;memoize-ref)
 (close
   (7 0 . core.destructuring\x27;compile-match)
   (call
     (push.iloc.0 . 2)
     (apply.gloc.of
       core.destructuring\x27;quoted-pair?
       "../stdlib/core/destructuring.scm"
       .
       142350))
   (if.true
     (call
       (push.cadr.iloc (0 . 2) "../stdlib/core/destructuring.scm" . 143404)
       (apply.gloc.of
         core.destructuring\x27;choose-pred
         "../stdlib/core/destructuring.scm"
         .
         143391))
     (push)
     (push.iloc.0 . 3)
     (push.const . quote)
     (push.cadr.iloc (0 . 2) "../stdlib/core/destructuring.scm" . 143423)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/destructuring.scm" . 143423)
     (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 143382)
     (iloc.0 . 4)
     (push.cons)
     (push.iloc.0 . 5)
     (push.iloc.0 . 6)
     (ret.subr.gloc.of \x2E;values "../stdlib/core/destructuring.scm" . 143374))
   (call
     (push.iloc.0 . 2)
     (apply.gloc.of
       core.destructuring\x27;ellipsis-pair?
       "../stdlib/core/destructuring.scm"
       .
       144398))
   (if.true
     (cddr.iloc (0 . 2) "../stdlib/core/destructuring.scm" . 145436)
     (if.null?
       (push.car.iloc (0 . 2) "../stdlib/core/destructuring.scm" . 146462)
       (const . _)
       (if.eq?
         (push.const . list?)
         (push.iloc.0 . 3)
         (push.subr.gloc.of \x2E;list 2 "../stdlib/core/destructuring.scm" . 147489)
         (iloc.0 . 4)
         (push.cons)
         (push.iloc.0 . 5)
         (push.iloc.0 . 6)
         (ret.subr.gloc.of \x2E;values "../stdlib/core/destructuring.scm" . 147481))
       (push.const . list?)
       (push.iloc.0 . 3)
       (push.subr.gloc.of \x2E;list 2 "../stdlib/core/destructuring.scm" . 148513)
       (iloc.0 . 4)
       (push.cons)
       (push.iloc.0 . 3)
       (iloc.0 . 5)
       (push.cons)
       (push.car.iloc (0 . 2) "../stdlib/core/destructuring.scm" . 148562)
       (iloc.0 . 6)
       (push.cons)
       (ret.subr.gloc.of \x2E;values "../stdlib/core/destructuring.scm" . 148505))
     (call
       (cddr.iloc (0 . 2) "../stdlib/core/destructuring.scm" . 149541)
       (if.not.pair?.ret.const . #t)
       (push.cddr.iloc (0 . 2) "../stdlib/core/destructuring.scm" . 149571)
       (apply.gloc.of
         core.destructuring\x27;predicate-pair?
         "../stdlib/core/destructuring.scm"
         .
         149554))
     (if.true
       (push.car.iloc (0 . 2) "../stdlib/core/destructuring.scm" . 150558)
       (const . _)
       (if.eq?
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.cddr.iloc (0 . 2) "../stdlib/core/destructuring.scm" . 151600)
         (push.const . last-cdr)
         (push.iloc.0 . 3)
         (push.subr.gloc.of \x2E;list 2 "../stdlib/core/destructuring.scm" . 151577)
         (push.iloc.0 . 4)
         (push.iloc.0 . 5)
         (push.iloc.0 . 6)
         (apply.gloc.of
           core.destructuring\x27;compile-match
           "../stdlib/core/destructuring.scm"
           .
           151577))
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.cddr.iloc (0 . 2) "../stdlib/core/destructuring.scm" . 155696)
       (push.const . last-cdr)
       (push.iloc.0 . 3)
       (push.subr.gloc.of \x2E;list 2 "../stdlib/core/destructuring.scm" . 155673)
       (push.iloc.0 . 4)
       (push.const . drop-last-cdr)
       (push.iloc.0 . 3)
       (push.subr.gloc.of \x2E;list 2 "../stdlib/core/destructuring.scm" . 157736)
       (iloc.0 . 5)
       (push.cons)
       (push.car.iloc (0 . 2) "../stdlib/core/destructuring.scm" . 158766)
       (iloc.0 . 6)
       (push.cons)
       (apply.gloc.of
         core.destructuring\x27;compile-match
         "../stdlib/core/destructuring.scm"
         .
         155673))
     (cddr.iloc (0 . 2) "../stdlib/core/destructuring.scm" . 159772)
     (if.pair?
       (call
         (apply.gloc.of \x2E;generate-temporary-symbol "../stdlib/core/destructuring.scm" . 160804))
       (push.iloc.0 . 2)
       (subr.gloc.of \x2E;cdddr 1 "../stdlib/core/destructuring.scm" . 161829)
       (if.null?
         (call
           (push.const . last-pair)
           (push.iloc.0 . 3)
           (push.subr.gloc.of \x2E;list 2 "../stdlib/core/destructuring.scm" . 162861)
           (push.iloc.0 . 1)
           (apply.gloc.of
             core.destructuring\x27;memoize-ref
             "../stdlib/core/destructuring.scm"
             .
             162861))
         (push)
         (extend . 1)
         (push.car.iloc (1 . 2) "../stdlib/core/destructuring.scm" . 163881)
         (const . _)
         (if.eq?
           (push.iloc.1 . 0)
           (push.iloc.1 . 1)
           (push.cddr.iloc (1 . 2) "../stdlib/core/destructuring.scm" . 164923)
           (push.iloc.0 . 0)
           (push.const . and)
           (push.const . pair?)
           (push.iloc.1 . 3)
           (push.subr.gloc.of \x2E;list 2 (\x2E;list 'pair? ref\x60;951*))
           (push.const . set!)
           (push.iloc.0 . 0)
           (push.const . last-pair)
           (push.iloc.1 . 3)
           (push.subr.gloc.of \x2E;list 2 (\x2E;list 'last-pair ref\x60;951*))
           (push.subr.gloc.of
             \x2E;list
             3
             (\x2E;list 'set! memoize\x60;955* (\x2E;list 'last-pair ref\x60;951*)))
           (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 165939)
           (iloc.1 . 4)
           (push.cons)
           (push.iloc.1 . 5)
           (push.iloc.1 . 6)
           (apply.gloc.of
             core.destructuring\x27;compile-match
             "../stdlib/core/destructuring.scm"
             .
             164900))
         (push.iloc.1 . 0)
         (push.iloc.1 . 1)
         (push.cddr.iloc (1 . 2) "../stdlib/core/destructuring.scm" . 169019)
         (push.iloc.0 . 0)
         (push.const . and)
         (push.const . pair?)
         (push.iloc.1 . 3)
         (push.subr.gloc.of \x2E;list 2 (\x2E;list 'pair? ref\x60;951*))
         (push.const . set!)
         (push.iloc.0 . 0)
         (push.const . last-pair)
         (push.iloc.1 . 3)
         (push.subr.gloc.of \x2E;list 2 (\x2E;list 'last-pair ref\x60;951*))
         (push.subr.gloc.of
           \x2E;list
           3
           (\x2E;list 'set! memoize\x60;955* (\x2E;list 'last-pair ref\x60;951*)))
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 170035)
         (iloc.1 . 4)
         (push.cons)
         (push.const . drop-last-pair)
         (push.iloc.1 . 3)
         (push.subr.gloc.of \x2E;list 2 "../stdlib/core/destructuring.scm" . 171059)
         (iloc.1 . 5)
         (push.cons)
         (push.car.iloc (1 . 2) "../stdlib/core/destructuring.scm" . 172089)
         (iloc.1 . 6)
         (push.cons)
         (apply.gloc.of
           core.destructuring\x27;compile-match
           "../stdlib/core/destructuring.scm"
           .
           168996))
       (call
         (push.iloc.0 . 2)
         (apply.gloc.of
           core.destructuring\x27;count-non-dotted-pattern
           "../stdlib/core/destructuring.scm"
           .
           174122))
       (push)
       (push.const . 2)
       (push.subr.gloc.of \x2E;- 2 "../stdlib/core/destructuring.scm" . 174119)
       (extend . 1)
       (call
         (push.const . last-n-pair)
         (push.iloc.0 . 0)
         (push.iloc.1 . 3)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 175151)
         (push.iloc.1 . 1)
         (apply.gloc.of
           core.destructuring\x27;memoize-ref
           "../stdlib/core/destructuring.scm"
           .
           175151))
       (push)
       (extend . 1)
       (push.car.iloc (2 . 2) "../stdlib/core/destructuring.scm" . 176171)
       (const . _)
       (if.eq?
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.cddr.iloc (2 . 2) "../stdlib/core/destructuring.scm" . 177213)
         (push.iloc.0 . 0)
         (push.const . and)
         (push.const . pair?)
         (push.iloc 2 . 3)
         (push.subr.gloc.of \x2E;list 2 (\x2E;list 'pair? ref\x60;951*))
         (push.const . set!)
         (push.iloc.0 . 0)
         (push.const . last-n-pair)
         (push.iloc.1 . 0)
         (push.iloc 2 . 3)
         (push.subr.gloc.of \x2E;list 3 (\x2E;list 'last-n-pair n\x60;957* ref\x60;951*))
         (push.subr.gloc.of
           \x2E;list
           3
           (\x2E;list 'set! memoize\x60;959* (\x2E;list 'last-n-pair n\x60;957* ref\x60;951*)))
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 178229)
         (iloc 2 . 4)
         (push.cons)
         (push.iloc 2 . 5)
         (push.iloc 2 . 6)
         (apply.gloc.of
           core.destructuring\x27;compile-match
           "../stdlib/core/destructuring.scm"
           .
           177190))
       (push.iloc 2 . 0)
       (push.iloc 2 . 1)
       (push.cddr.iloc (2 . 2) "../stdlib/core/destructuring.scm" . 181309)
       (push.iloc.0 . 0)
       (push.const . and)
       (push.const . pair?)
       (push.iloc 2 . 3)
       (push.subr.gloc.of \x2E;list 2 (\x2E;list 'pair? ref\x60;951*))
       (push.const . set!)
       (push.iloc.0 . 0)
       (push.const . last-n-pair)
       (push.iloc.1 . 0)
       (push.iloc 2 . 3)
       (push.subr.gloc.of \x2E;list 3 (\x2E;list 'last-n-pair n\x60;957* ref\x60;951*))
       (push.subr.gloc.of
         \x2E;list
         3
         (\x2E;list 'set! memoize\x60;959* (\x2E;list 'last-n-pair n\x60;957* ref\x60;951*)))
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 182325)
       (iloc 2 . 4)
       (push.cons)
       (push.const . drop-last-n-pair)
       (push.iloc.1 . 0)
       (push.iloc 2 . 3)
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 183349)
       (iloc 2 . 5)
       (push.cons)
       (push.car.iloc (2 . 2) "../stdlib/core/destructuring.scm" . 184379)
       (iloc 2 . 6)
       (push.cons)
       (apply.gloc.of
         core.destructuring\x27;compile-match
         "../stdlib/core/destructuring.scm"
         .
         181286))
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (ret.subr.gloc.of \x2E;values "../stdlib/core/destructuring.scm" . 186389))
   (call
     (push.iloc.0 . 2)
     (apply.gloc.of
       core.destructuring\x27;predicate-pair?
       "../stdlib/core/destructuring.scm"
       .
       187406))
   (if.true
     (call
       (push.iloc.0 . 0)
       (push.cadr.iloc (0 . 2) "../stdlib/core/destructuring.scm" . 188473)
       (push.const . #f)
       (subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/destructuring.scm" . 188449)
       (if.true.ret)
       (apply.gloc.of \x2E;generate-temporary-symbol "../stdlib/core/destructuring.scm" . 188488))
     (push)
     (extend . 1)
     (push.iloc.1 . 0)
     (push.cadr.iloc (1 . 2) "../stdlib/core/destructuring.scm" . 189481)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/destructuring.scm" . 189456)
     (cddr.iloc (1 . 2) "../stdlib/core/destructuring.scm" . 190491)
     (if.null?
       (push.iloc.0 . 0)
       (push.iloc.1 . 3)
       (push.subr.gloc.of \x2E;list 2 "../stdlib/core/destructuring.scm" . 191516)
       (iloc.1 . 4)
       (push.cons)
       (push.iloc.1 . 5)
       (push.iloc.1 . 6)
       (ret.subr.gloc.of \x2E;values "../stdlib/core/destructuring.scm" . 191508))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (push.subr.gloc.of \x2E;caddr 1 "../stdlib/core/destructuring.scm" . 192555)
     (push.iloc.1 . 3)
     (push.iloc.0 . 0)
     (push.iloc.1 . 3)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/destructuring.scm" . 192571)
     (iloc.1 . 4)
     (push.cons)
     (push.iloc.1 . 5)
     (push.iloc.1 . 6)
     (apply.gloc.of
       core.destructuring\x27;compile-match
       "../stdlib/core/destructuring.scm"
       .
       192532))
   (iloc.0 . 2)
   (if.pair?
     (push.close
       (0 0)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.car.iloc (1 . 2) "../stdlib/core/destructuring.scm" . 196651)
       (call
         (push.iloc.1 . 3)
         (apply.gloc.of core.destructuring\x27;car+ "../stdlib/core/destructuring.scm" . 196661))
       (push)
       (push.const . pair?)
       (push.iloc.1 . 3)
       (push.subr.gloc.of \x2E;list 2 "../stdlib/core/destructuring.scm" . 196672)
       (iloc.1 . 4)
       (push.cons)
       (push.iloc.1 . 5)
       (push.iloc.1 . 6)
       (apply.gloc.of
         core.destructuring\x27;compile-match
         "../stdlib/core/destructuring.scm"
         .
         196628))
     (push.close
       (3 0)
       (iloc.0 . 0)
       (if.true
         (push.iloc.1 . 0)
         (push.iloc.1 . 1)
         (push.cdr.iloc (1 . 2) "../stdlib/core/destructuring.scm" . 197685)
         (call
           (push.iloc.1 . 3)
           (apply.gloc.of core.destructuring\x27;cdr+ "../stdlib/core/destructuring.scm" . 197695))
         (push)
         (push.iloc.0 . 0)
         (push.iloc.0 . 1)
         (push.iloc.0 . 2)
         (apply.gloc.of
           core.destructuring\x27;compile-match
           "../stdlib/core/destructuring.scm"
           .
           197662))
       (push.const . #f)
       (push.const . #f)
       (push.const . #f)
       (ret.subr.gloc.of \x2E;values "../stdlib/core/destructuring.scm" . 198684))
     (apply.gloc.of \x2E;call-with-values "../stdlib/core/destructuring.scm" . 144398))
   (push.iloc.0 . 2)
   (const . ...)
   (if.eq?
     (push.const . #f)
     (push.const . #f)
     (push.const . #f)
     (ret.subr.gloc.of \x2E;values "../stdlib/core/destructuring.scm" . 200718))
   (push.iloc.0 . 2)
   (const . _)
   (if.eq?
     (push.iloc.0 . 4)
     (push.iloc.0 . 5)
     (push.iloc.0 . 6)
     (ret.subr.gloc.of \x2E;values "../stdlib/core/destructuring.scm" . 202766))
   (iloc.0 . 2)
   (if.symbol?
     (push.iloc.0 . 4)
     (push.iloc.0 . 3)
     (iloc.0 . 5)
     (push.cons)
     (push.iloc.0 . 2)
     (iloc.0 . 6)
     (push.cons)
     (ret.subr.gloc.of \x2E;values "../stdlib/core/destructuring.scm" . 204814))
   (iloc.0 . 2)
   (if.null?
     (push.const . null?)
     (push.iloc.0 . 3)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/destructuring.scm" . 206870)
     (iloc.0 . 4)
     (push.cons)
     (push.iloc.0 . 5)
     (push.iloc.0 . 6)
     (ret.subr.gloc.of \x2E;values "../stdlib/core/destructuring.scm" . 206862))
   (call
     (push.iloc.0 . 2)
     (apply.gloc.of core.destructuring\x27;choose-pred "../stdlib/core/destructuring.scm" . 208927))
   (push)
   (push.iloc.0 . 3)
   (push.iloc.0 . 2)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/destructuring.scm" . 208918)
   (iloc.0 . 4)
   (push.cons)
   (push.iloc.0 . 5)
   (push.iloc.0 . 6)
   (ret.subr.gloc.of \x2E;values "../stdlib/core/destructuring.scm" . 208910))
 (set.gloc.of core.destructuring\x27;compile-match)
 (close
   (2 0 . core.destructuring\x27;reorder-tests)
   (touch.gloc.of loop\x60;969*)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const)
   (apply.gloc.of loop\x60;969* "../stdlib/core/destructuring.scm" . 214025))
 (set.gloc.of core.destructuring\x27;reorder-tests)
 (close
   (1 0 . core.destructuring\x27;reorder)
   (push.gloc.of \x2E;L297)
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;map "../stdlib/core/destructuring.scm" . 221191))
 (set.gloc.of core.destructuring\x27;reorder)
 (close
   (2 0 . core.destructuring\x27;cse-length)
   (touch.gloc.of loop\x60;985*)
   (push.const . 0)
   (push.cadr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 227356)
   (push.cadr.iloc (0 . 1) "../stdlib/core/destructuring.scm" . 227376)
   (apply.gloc.of loop\x60;985* "../stdlib/core/destructuring.scm" . 228361))
 (set.gloc.of core.destructuring\x27;cse-length)
 (close
   (2 0 . core.destructuring\x27;cse-1)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (iloc.1 . 1)
       (if.eq?.ret.const . -1)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of
         core.destructuring\x27;cse-length
         "../stdlib/core/destructuring.scm"
         .
         236578))
     (push.iloc.0 . 0)
     (apply.gloc.of
       \x2E;map
       (\x2E;map
         (lambda (clause\x60;991*)
           (if (\x2E;eq? clause\x60;991* current\x60;989*)
               -1
               (core.destructuring\x27;cse-length clause\x60;991* current\x60;989*)))
         clauses\x60;989*)))
   (push)
   (extend . 1)
   (call
     (call
       (push.gloc.of \x2E;L302)
       (push.iloc.0 . 0)
       (apply.gloc.of core.lists\x27;filter "../stdlib/core/destructuring.scm" . 239642))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.null?.ret.const . 0)
     (push.gloc.of \x2E;min)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;apply "../stdlib/core/destructuring.scm" . 241693))
   (push)
   (extend . 1)
   (>=n.iloc (0 . 0) 2 "../stdlib/core/destructuring.scm" . 242702)
   (if.false.ret)
   (call (apply.gloc.of \x2E;generate-temporary-symbol "../stdlib/core/destructuring.scm" . 243741))
   (push)
   (extend . 1)
   (push.cadr.iloc (3 . 1) "../stdlib/core/destructuring.scm" . 244777)
   (push.iloc.1 . 0)
   (push.subr.gloc.of \x2E;list-head 2 "../stdlib/core/destructuring.scm" . 244766)
   (extend . 1)
   (call
     (push.close
       (2 0)
       (call
         (=n.iloc (0 . 1) -1 "../stdlib/core/destructuring.scm" . 247848)
         (if.true.ret)
         (push.iloc.0 . 1)
         (push.iloc 3 . 0)
         (ret.subr.gloc.of \x2E;>= "../stdlib/core/destructuring.scm" . 247859))
       (if.true
         (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 248871)
         (push.iloc 2 . 0)
         (push.cadr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 248909)
         (push.iloc 3 . 0)
         (subr.gloc.of \x2E;list-tail 2 "../stdlib/core/destructuring.scm" . 248898)
         (push.cons)
         (push.cddr.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 248934)
         (ret.subr.gloc.of \x2E;cons* "../stdlib/core/destructuring.scm" . 247843))
       (ret.iloc 0 . 0))
     (push.iloc 4 . 0)
     (push.iloc 3 . 0)
     (apply.gloc.of
       \x2E;map
       (\x2E;map
         (lambda (clause\x60;1006* len\x60;1006*)
           (if (or (\x2E;= len\x60;1006* -1) (\x2E;>= len\x60;1006* cs-max\x60;999*))
               (\x2E;cons*
                 (\x2E;car clause\x60;1006*)
                 (\x2E;cons
                   cs-tag\x60;1002*
                   (\x2E;list-tail (\x2E;cadr clause\x60;1006*) cs-max\x60;999*))
                 (\x2E;cddr clause\x60;1006*))
               clause\x60;1006*))
         clauses\x60;989*
         cs-lst\x60;993*)))
   (push)
   (extend . 1)
   (car.iloc (1 . 0) "../stdlib/core/destructuring.scm" . 251933)
   (if.symbol?
     (push.iloc.0 . 0)
     (push.iloc 2 . 0)
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/destructuring.scm" . 252970)
     (push.subr.gloc.of \x2E;list 1 "../stdlib/core/destructuring.scm" . 252964)
     (ret.subr.gloc.of \x2E;append "../stdlib/core/destructuring.scm" . 252948))
   (push.iloc 2 . 0)
   (push.iloc.1 . 0)
   (push.subr.gloc.of \x2E;list 2 "../stdlib/core/destructuring.scm" . 253978)
   (iloc.0 . 0)
   (ret.cons "../stdlib/core/destructuring.scm" . 253972))
 (set.gloc.of core.destructuring\x27;cse-1)
 (close
   (1 0 . core.destructuring\x27;cse)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null? (ret.iloc 2 . 0))
     (call
       (push.iloc 2 . 0)
       (push.car.iloc (0 . 0) "../stdlib/core/destructuring.scm" . 261155)
       (apply.gloc.of core.destructuring\x27;cse-1 "../stdlib/core/destructuring.scm" . 261140))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc.0 . 0)
       (apply.gloc.of core.destructuring\x27;cse "../stdlib/core/destructuring.scm" . 262169))
     (push.cdr.iloc (1 . 0) "../stdlib/core/destructuring.scm" . 262175)
     (apply.iloc+ (2 . 0) "../stdlib/core/destructuring.scm" . 262169))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "../stdlib/core/destructuring.scm" . 259081))
 (set.gloc.of core.destructuring\x27;cse)
 (call
   (push.gloc.of \x2E;L299)
   (push.const
     (car . caar)
     (cdr . cadr)
     (caar . caaar)
     (cadr . caadr)
     (cdar . cadar)
     (cddr . caddr)
     (caaar . caaaar)
     (caadr . caaadr)
     (cadar . caadar)
     (caddr . caaddr)
     (cdaar . cadaar)
     (cdadr . cadadr)
     (cddar . caddar)
     (cdddr . cadddr))
   (apply.gloc.of \x2E;for-each "../stdlib/core/destructuring.scm" . 362499))
 (call
   (push.gloc.of \x2E;L261)
   (push.const
     (car . cdar)
     (cdr . cddr)
     (caar . cdaar)
     (cadr . cdadr)
     (cdar . cddar)
     (cddr . cdddr)
     (caaar . cdaaar)
     (caadr . cdaadr)
     (cadar . cdadar)
     (caddr . cdaddr)
     (cdaar . cddaar)
     (cdadr . cddadr)
     (cddar . cdddar)
     (cdddr . cddddr))
   (apply.gloc.of \x2E;for-each "../stdlib/core/destructuring.scm" . 366595))
 (call
   (push.const
     (core.destructuring\x27;duplicates? unbound)
     (apply import . \x2E;apply)
     (core.destructuring\x27;reorder unbound)
     (e unbound)
     (vector-ref import . \x2E;vector-ref)
     (subexprs unbound)
     (clauses unbound)
     (... import . \x2E;...)
     (syntax import . \x2E;syntax)
     (list import . \x2E;list)
     (core-hashtable->alist import . \x2E;core-hashtable->alist)
     (k unbound)
     (else import . \x2E;else)
     (core.destructuring\x27;cse unbound)
     (?clauses unbound)
     (with-syntax import . core.syntax-case\x27;with-syntax)
     (?fender unbound)
     (core.lists\x27;partition unbound)
     (let-values import . \x2E;let-values)
     (cond import . \x2E;cond)
     (?pat unbound)
     (if import . \x2E;if)
     (car import . \x2E;car)
     (destructuring-bind import . core.destructuring\x27;destructuring-bind)
     (vars unbound)
     (a unbound)
     (?tests unbound)
     (datum import . core.syntax-case\x27;datum)
     (?vars unbound)
     (?pred-rhs unbound)
     (?dispatch unbound)
     (?mem unbound)
     (eq? import . \x2E;eq?)
     (begin import . \x2E;begin)
     (core.destructuring\x27;compile-match unbound)
     (_ import . \x2E;_)
     (lambda import . \x2E;lambda)
     (?subexprs unbound)
     (body unbound)
     (destructuring-match import . core.destructuring\x27;destructuring-match)
     (syntax->datum import . \x2E;syntax->datum)
     (clause unbound)
     (?inits unbound)
     (and import . \x2E;and)
     (?datum unbound)
     (map import . \x2E;map)
     (fender unbound)
     (let import . \x2E;let)
     (?pred-lhs unbound)
     (quote import . \x2E;quote)
     (ren unbound)
     (inits unbound)
     (datum->syntax import . \x2E;datum->syntax)
     (values import . \x2E;values)
     (?body unbound)
     (?_ unbound)
     (?expr unbound)
     (cdr import . \x2E;cdr)
     (tests unbound)
     (mem unbound)
     (let* import . \x2E;let*))
   (extend . 1)
   (call
     (push.const . syntax)
     (push.const . core.destructuring\x27;destructuring-bind)
     (call
       (push.gloc.of \x2E;L287)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/destructuring.scm" . 265221))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/destructuring.scm" . 265221))
   (push.const . syntax)
   (push.const . core.destructuring\x27;destructuring-match)
   (call
     (push.gloc.of \x2E;L305)
     (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/destructuring.scm" . 291845))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/destructuring.scm" . 265221))
 (push.const . core.destructuring)
 (push.const . #f)
 (push.const
   (destructuring-match import . core.destructuring\x27;destructuring-match)
   (destructuring-bind import . core.destructuring\x27;destructuring-bind))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/destructuring.scm" . 75792))

((close
   (1 0)
   (push.const . #f)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 199687))
 (set.gloc.of \x2E;L364)
 (close
   (1 0)
   (push.const . #f)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 207879))
 (set.gloc.of \x2E;L371)
 (close
   (1 0)
   (call
     (call
       (push.iloc.0 . 0)
       (push.const . e1)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 77853))
     (push)
     (apply.gloc.of \x2E;syntax->datum "../stdlib/core/records.scm" . 77853))
   (push)
   (ret.subr.gloc.of \x2E;boolean? "../stdlib/core/records.scm" . 77843))
 (set.gloc.of \x2E;L399)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const record-type-rcd name)
   (push.const (name . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 187401))
 (set.gloc.of \x2E;L391)
 (close
   (1 0)
   (push.const . #f)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 216071))
 (set.gloc.of \x2E;L392)
 (close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (push.const . e1)
     (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 83987))
   (push)
   (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 83987))
 (set.gloc.of \x2E;L366)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const (immutable name) proc #f)
   (push.const (proc . 0) (name . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 111646))
 (set.gloc.of \x2E;L386)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const (immutable name) accessor #f)
   (push.const (accessor . 0) (name . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 93213))
 (set.gloc.of \x2E;L374)
 (close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (push.const . name)
     (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 182291))
   (push)
   (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 182291))
 (set.gloc.of \x2E;L360)
 (close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (push.const . name)
     (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 187411))
   (push)
   (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 187411))
 (set.gloc.of \x2E;L368)
 (close
   (1 0)
   (call
     (call
       (push.iloc.0 . 0)
       (push.const . record-name)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 173101))
     (push)
     (apply.gloc.of \x2E;syntax->datum "../stdlib/core/records.scm" . 173101))
   (push)
   (push.subr.gloc.of \x2E;symbol->string 1 "../stdlib/core/records.scm" . 173085)
   (extend . 1)
   (push.iloc.1 . 0)
   (call
     (call
       (push.iloc.1 . 0)
       (push.const . record-name)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 174094))
     (push)
     (push.const . "make-")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;string-append 2 "../stdlib/core/records.scm" . 174094)
     (push.subr.gloc.of \x2E;string->symbol 1 "../stdlib/core/records.scm" . 174094)
     (apply.gloc.of \x2E;datum->syntax "../stdlib/core/records.scm" . 174094))
   (push)
   (call
     (call
       (push.iloc.1 . 0)
       (push.const . record-name)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 174094))
     (push)
     (push.iloc.0 . 0)
     (push.const . "?")
     (push.subr.gloc.of \x2E;string-append 2 "../stdlib/core/records.scm" . 174094)
     (push.subr.gloc.of \x2E;string->symbol 1 "../stdlib/core/records.scm" . 174094)
     (apply.gloc.of \x2E;datum->syntax "../stdlib/core/records.scm" . 174094))
   (push)
   (push.subr.gloc.of \x2E;list 2 "../stdlib/core/records.scm" . 174094)
   (push.const)
   (push.const constructor-name predicate-name)
   (push.const . #f)
   (push.gloc.of \x2E;L355)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 174094)
   (push.const . _)
   (push.const . #f)
   (push.gloc.of \x2E;L385)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 174094)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/records.scm" . 174094))
 (set.gloc.of \x2E;L397)
 (close
   (1 0)
   (push.const . #f)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 220167))
 (set.gloc.of \x2E;L388)
 (close
   (1 0)
   (push.const . #f)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 195591))
 (set.gloc.of \x2E;L395)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const record-type-rtd name)
   (push.const (name . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 182281))
 (set.gloc.of \x2E;L390)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const (proc (method-name "~a-~a" (syntax name))))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 101406))
 (set.gloc.of \x2E;L393)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const define-record-type (record-name constructor-name predicate-name) record-clauses ...)
   (push.const (record-clauses . 1) (predicate-name . 0) (constructor-name . 0) (record-name . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 174094))
 (set.gloc.of \x2E;L355)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const ((_ name _) spec) (n index))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 123916))
 (set.gloc.of \x2E;L400)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const (immutable name) proc #f)
   (push.const (proc . 0) (name . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 101406))
 (set.gloc.of \x2E;L359)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const
     define
     record-name
     (let* ((rtd
              (make-record-type-descriptor
                'record-name
                rtd-parent
                'uid
                sealed
                opaque
                '#(fields ...)))
            (rcd (make-record-constructor-descriptor rtd rcd-parent protocol)))
       (make-record-type 'record-name rtd rcd)))
   (push.const
     (protocol . 0)
     (rcd-parent . 0)
     (fields . 1)
     (opaque . 0)
     (sealed . 0)
     (uid . 0)
     (rtd-parent . 0)
     (record-name . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 123916))
 (set.gloc.of \x2E;L394)
 (close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (push.const . e1)
     (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 70675))
   (push)
   (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 70675))
 (set.gloc.of \x2E;L383)
 (close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (push.const . record-name)
     (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 172044))
   (push)
   (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 172044))
 (set.gloc.of \x2E;L375)
 (close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (push.const . name)
     (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 100382))
   (push)
   (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 100382))
 (set.gloc.of \x2E;L363)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const begin record-type constructor predicate accessors ... mutators ...)
   (push.const (mutators . 1) (accessors . 1) (predicate . 0) (constructor . 0) (record-type . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 123916))
 (set.gloc.of \x2E;L401)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const
     (proc1 (method-name "~a-~a" (syntax name)))
     (proc2 (method-name "~a-~a-set!" (syntax name))))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 105502))
 (set.gloc.of \x2E;L361)
 (close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (push.const . name)
     (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 110622))
   (push)
   (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 110622))
 (set.gloc.of \x2E;L380)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const (proc (method-name "~a-~a" (syntax name))))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 111646))
 (set.gloc.of \x2E;L365)
 (close
   (1 0)
   (push.const . #f)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 203783))
 (set.gloc.of \x2E;L384)
 (close
   (1 0)
   (call
     (call
       (push.iloc.0 . 0)
       (push.const . name)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 123916))
     (push)
     (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 123916))
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const define name (record-mutator (record-type-rtd record-name) n))
   (push.const (n . 0) (record-name . 0) (name . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 123916))
 (set.gloc.of \x2E;L367)
 (close
   (1 0)
   (push.const . #f)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 191495))
 (set.gloc.of \x2E;L362)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const _ name)
   (push.gloc.of \x2E;L360)
   (push.gloc.of \x2E;L390)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 181255)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/records.scm" . 181255))
 (set.gloc.of \x2E;L376)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const _ name)
   (push.gloc.of \x2E;L368)
   (push.gloc.of \x2E;L391)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 186375)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/records.scm" . 186375))
 (set.gloc.of \x2E;L382)
 (close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (push.const . name)
     (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 104478))
   (push)
   (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 104478))
 (set.gloc.of \x2E;L356)
 (close
   (1 0)
   (call
     (call
       (push.iloc.0 . 0)
       (push.const . e1)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 80925))
     (push)
     (apply.gloc.of \x2E;syntax->datum "../stdlib/core/records.scm" . 80925))
   (push)
   (ret.subr.gloc.of \x2E;boolean? "../stdlib/core/records.scm" . 80915))
 (set.gloc.of \x2E;L370)
 (close
   (1 0)
   (push.const . #f)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 224263))
 (set.gloc.of \x2E;L381)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const
     (rtd-parent
       (cond ((stash-ref 'parent-rtd #f) => car)
             ((stash-ref 'parent #f) (syntax (record-type-rtd parent)))
             (else #f)))
     (rcd-parent
       (cond ((stash-ref 'parent-rtd #f) => cdr)
             ((stash-ref 'parent #f) (syntax (record-type-rcd parent)))
             (else #f)))
     (uid (stash-ref 'nongenerative #f))
     (sealed (stash-ref 'sealed #f))
     (opaque (stash-ref 'opaque #f))
     (protocol (stash-ref 'protocol #f))
     (((fields _ _) ...) (datum->syntax (syntax k) (stash-ref 'fields '()))))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 123916))
 (set.gloc.of \x2E;L372)
 (close
   (1 0)
   (call
     (call
       (push.iloc.0 . 0)
       (push.const . record-name)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 122897))
     (push)
     (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 122897))
   (if.false.ret)
   (call
     (call
       (push.iloc.0 . 0)
       (push.const . constructor-name)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 122925))
     (push)
     (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 122925))
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (push.const . predicate-name)
     (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 122958))
   (push)
   (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 122958))
 (set.gloc.of \x2E;L398)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const
     (constructor-name
       (datum->syntax (syntax record-name) (string->symbol (string-append "make-" base-name))))
     (predicate-name
       (datum->syntax (syntax record-name) (string->symbol (string-append base-name "?")))))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 174094))
 (set.gloc.of \x2E;L385)
 (close
   (1 0)
   (subr.gloc.of \x2E;make-core-hashtable 0)
   (push)
   (extend . 1)
   (extend.unbound . 3)
   (push.close
     (2 0 . stash-set!)
     (call
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (push.const . #f)
       (subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/records.scm" . 50194)
       (if.false.ret)
       (push.const . define-record-type)
       (push.const . "duplicate ~a clause")
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/records.scm" . 51256)
       (push.iloc 3 . 0)
       (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 51218))
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 1 "../stdlib/core/records.scm" . 52268)
     (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/records.scm" . 52237))
   (push.close
     (2 0 . stash-ref)
     (push.iloc 2 . 0)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/records.scm" . 56340)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (ret.subr.gloc.of \x2E;car (\x2E;car \x2E;L351\x60;1029*)))
     (ret.iloc 1 . 1))
   (push.close
     (2 0 . parse-record-clauses)
     (extend.enclose+
       (2 0 . method-name)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.iloc 2 . 0)
       (call
         (push.iloc.0 . 1)
         (apply.gloc.of \x2E;syntax->datum "../stdlib/core/records.scm" . 64596))
       (push)
       (push.subr.gloc.of \x2E;format 3 "../stdlib/core/records.scm" . 64572)
       (push.subr.gloc.of \x2E;string->symbol 1 "../stdlib/core/records.scm" . 64556)
       (apply.gloc.of \x2E;datum->syntax "../stdlib/core/records.scm" . 64529))
     (push.close
       (1 0)
       (push.gloc.of \x2E;vars)
       (push.iloc.0 . 0)
       (push.const parent protocol parent-rtd sealed opaque nongenerative fields)
       (push.const parent e1)
       (push.gloc.of \x2E;L383)
       (push.close
         (1 0)
         (push.const . parent)
         (call
           (push.iloc.0 . 0)
           (push.const . e1)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 71699))
         (push)
         (apply.iloc (4 . 0) "../stdlib/core/records.scm" . 71699))
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 68624)
       (push.const protocol e1)
       (push.const . #f)
       (push.close
         (1 0)
         (push.const . protocol)
         (call
           (push.iloc.0 . 0)
           (push.const . e1)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 73747))
         (push)
         (apply.iloc (4 . 0) "../stdlib/core/records.scm" . 73747))
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 68624)
       (push.const parent-rtd e1 e2)
       (push.const . #f)
       (push.close
         (1 0)
         (push.const . parent-rtd)
         (call
           (push.iloc.0 . 0)
           (push.const . e1)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 75819))
         (push)
         (call
           (push.iloc.0 . 0)
           (push.const . e2)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 75819))
         (push.cons)
         (apply.iloc (4 . 0) "../stdlib/core/records.scm" . 75795))
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 68624)
       (push.const sealed e1)
       (push.gloc.of \x2E;L399)
       (push.close
         (1 0)
         (push.const . sealed)
         (call
           (push.iloc.0 . 0)
           (push.const . e1)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 78867))
         (push)
         (apply.iloc (4 . 0) "../stdlib/core/records.scm" . 78867))
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 68624)
       (push.const opaque e1)
       (push.gloc.of \x2E;L370)
       (push.close
         (1 0)
         (push.const . opaque)
         (call
           (push.iloc.0 . 0)
           (push.const . e1)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 81939))
         (push)
         (apply.iloc (4 . 0) "../stdlib/core/records.scm" . 81939))
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 68624)
       (push.const nongenerative e1)
       (push.gloc.of \x2E;L366)
       (push.close
         (1 0)
         (push.const . nongenerative)
         (call
           (push.iloc.0 . 0)
           (push.const . e1)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 85011))
         (push)
         (apply.iloc (4 . 0) "../stdlib/core/records.scm" . 85011))
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 68624)
       (push.const nongenerative)
       (push.const . #f)
       (push.close
         (1 0)
         (push.const . nongenerative)
         (call
           (call
             (push.iloc.0 . 0)
             (push.const . k)
             (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/records.scm" . 87086))
           (push)
           (push.const . "<~a>")
           (subr.gloc.of \x2E;make-uuid 0)
           (push)
           (push.subr.gloc.of \x2E;format 2 "../stdlib/core/records.scm" . 87121)
           (push.subr.gloc.of \x2E;string->symbol 1 "../stdlib/core/records.scm" . 87105)
           (apply.gloc.of \x2E;datum->syntax "../stdlib/core/records.scm" . 87086))
         (push)
         (apply.iloc (4 . 0) "../stdlib/core/records.scm" . 87059))
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 68624)
       (push.const fields specs ...)
       (push.const . #f)
       (push.close
         (1 0)
         (push.const . fields)
         (call
           (push.close
             (1 0)
             (push.iloc.1 . 0)
             (push.iloc.0 . 0)
             (push.const immutable mutable)
             (push.const immutable name accessor)
             (push.gloc.of \x2E;L373)
             (push.gloc.of \x2E;L374)
             (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 92187)
             (push.const mutable name accessor mutator)
             (push.gloc.of \x2E;L358)
             (push.gloc.of \x2E;L387)
             (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 92187)
             (push.const immutable name)
             (push.gloc.of \x2E;L363)
             (push.close
               (1 0)
               (push.iloc.0 . 0)
               (call
                 (push.const . "~a-~a")
                 (call
                   (push.iloc.0 . 0)
                   (push.const . name)
                   (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 101406))
                 (push)
                 (apply.iloc+ (4 . 0) "../stdlib/core/records.scm" . 101406))
               (push)
               (push.subr.gloc.of \x2E;list 1 "../stdlib/core/records.scm" . 101406)
               (push.const)
               (push.const proc)
               (push.const . #f)
               (push.gloc.of \x2E;L359)
               (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 101406)
               (push.const . _)
               (push.const . #f)
               (push.gloc.of \x2E;L393)
               (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 101406)
               (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/records.scm" . 101406))
             (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 92187)
             (push.const mutable name)
             (push.gloc.of \x2E;L356)
             (push.close
               (1 0)
               (push.iloc.0 . 0)
               (call
                 (push.const . "~a-~a")
                 (call
                   (push.iloc.0 . 0)
                   (push.const . name)
                   (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 105502))
                 (push)
                 (apply.iloc+ (4 . 0) "../stdlib/core/records.scm" . 105502))
               (push)
               (call
                 (push.const . "~a-~a-set!")
                 (call
                   (push.iloc.0 . 0)
                   (push.const . name)
                   (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 105502))
                 (push)
                 (apply.iloc+ (4 . 0) "../stdlib/core/records.scm" . 105502))
               (push)
               (push.subr.gloc.of \x2E;list 2 "../stdlib/core/records.scm" . 105502)
               (push.const)
               (push.const proc1 proc2)
               (push.const . #f)
               (push.gloc.of \x2E;L369)
               (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 105502)
               (push.const . _)
               (push.const . #f)
               (push.gloc.of \x2E;L361)
               (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 105502)
               (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/records.scm" . 105502))
             (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 92187)
             (push.const . name)
             (push.gloc.of \x2E;L380)
             (push.close
               (1 0)
               (push.iloc.0 . 0)
               (call
                 (push.const . "~a-~a")
                 (call
                   (push.iloc.0 . 0)
                   (push.const . name)
                   (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 111646))
                 (push)
                 (apply.iloc+ (4 . 0) "../stdlib/core/records.scm" . 111646))
               (push)
               (push.subr.gloc.of \x2E;list 1 "../stdlib/core/records.scm" . 111646)
               (push.const)
               (push.const proc)
               (push.const . #f)
               (push.gloc.of \x2E;L386)
               (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 111646)
               (push.const . _)
               (push.const . #f)
               (push.gloc.of \x2E;L365)
               (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 111646)
               (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/records.scm" . 111646))
             (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 92187)
             (push.const . _)
             (push.const . #f)
             (push.close
               (1 0)
               (push.const . define-record-type)
               (push.const . "malformed field spec")
               (push.iloc 8 . 0)
               (push.iloc.1 . 0)
               (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 114718))
             (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 92187)
             (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/records.scm" . 92187))
           (call
             (push.iloc.0 . 0)
             (push.const specs ...)
             (push.const (specs . 1))
             (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 91156))
           (push)
           (apply.gloc.of \x2E;map "../stdlib/core/records.scm" . 91161))
         (push)
         (apply.iloc (4 . 0) "../stdlib/core/records.scm" . 89107))
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 68624)
       (push.const . _)
       (push.const . #f)
       (push.close
         (1 0)
         (push.const . define-record-type)
         (push.const . "malformed record clauses")
         (push.iloc 6 . 0)
         (call
           (push.iloc.1 . 0)
           (apply.gloc.of \x2E;syntax->datum "../stdlib/core/records.scm" . 117848))
         (push)
         (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 117781))
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 68624)
       (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/records.scm" . 68624))
     (push.iloc.1 . 1)
     (apply.gloc.of \x2E;for-each "../stdlib/core/records.scm" . 67598))
   (enclose . 3)
   (push.gloc.of \x2E;vars)
   (push.iloc 2 . 0)
   (push.const)
   (push.const _ (record-name constructor-name predicate-name) record-clauses ...)
   (push.gloc.of \x2E;L398)
   (push.close
     (1 0)
     (call
       (call
         (call
           (push.iloc.0 . 0)
           (push.const . record-name)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 124964))
         (push)
         (apply.gloc.of \x2E;syntax->datum "../stdlib/core/records.scm" . 124964))
       (push)
       (call
         (push.iloc.0 . 0)
         (push.const record-clauses ...)
         (push.const (record-clauses . 1))
         (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 124942))
       (push)
       (apply.iloc (1 . 2) "../stdlib/core/records.scm" . 124942))
     (call
       (call
         (push.const . parent-rtd)
         (push.const . #f)
         (apply.iloc (1 . 1) "../stdlib/core/records.scm" . 125971))
       (if.false.ret)
       (call
         (push.const . parent)
         (push.const . #f)
         (apply.iloc (1 . 1) "../stdlib/core/records.scm" . 126995))
       (if.false.ret)
       (push.const . define-record-type)
       (push.const . "definition have both parent and parent-rtd clause")
       (push.iloc 3 . 0)
       (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 128019))
     (push.iloc.0 . 0)
     (call
       (push.iloc.0 . 0)
       (call
         (push.const . parent)
         (push.const . #f)
         (apply.iloc (1 . 1) "../stdlib/core/records.scm" . 123916))
       (push)
       (push.subr.gloc.of \x2E;list 1 "../stdlib/core/records.scm" . 123916)
       (push.const)
       (push.const parent)
       (push.const . #f)
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (call
           (call
             (push.const . parent-rtd)
             (push.const . #f)
             (apply.iloc (2 . 1) "../stdlib/core/records.scm" . 123916))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.iloc.0 . 0)
             (ret.subr.gloc.of \x2E;car "../stdlib/core/records.scm" . 123916))
           (call
             (push.const . parent)
             (push.const . #f)
             (apply.iloc (3 . 1) "../stdlib/core/records.scm" . 123916))
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.const record-type-rtd parent)
           (push.const (parent . 0))
           (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 123916))
         (push)
         (call
           (call
             (push.const . parent-rtd)
             (push.const . #f)
             (apply.iloc (2 . 1) "../stdlib/core/records.scm" . 123916))
           (push)
           (extend . 1)
           (iloc.0 . 0)
           (if.true
             (push.iloc.0 . 0)
             (ret.subr.gloc.of \x2E;cdr "../stdlib/core/records.scm" . 123916))
           (call
             (push.const . parent)
             (push.const . #f)
             (apply.iloc (3 . 1) "../stdlib/core/records.scm" . 123916))
           (if.false.ret)
           (push.iloc.1 . 0)
           (push.const record-type-rcd parent)
           (push.const (parent . 0))
           (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 123916))
         (push)
         (call
           (push.const . nongenerative)
           (push.const . #f)
           (apply.iloc (2 . 1) "../stdlib/core/records.scm" . 123916))
         (push)
         (call
           (push.const . sealed)
           (push.const . #f)
           (apply.iloc (2 . 1) "../stdlib/core/records.scm" . 123916))
         (push)
         (call
           (push.const . opaque)
           (push.const . #f)
           (apply.iloc (2 . 1) "../stdlib/core/records.scm" . 123916))
         (push)
         (call
           (push.const . protocol)
           (push.const . #f)
           (apply.iloc (2 . 1) "../stdlib/core/records.scm" . 123916))
         (push)
         (call
           (call
             (push.iloc.0 . 0)
             (push.const . k)
             (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/records.scm" . 123916))
           (push)
           (call
             (push.const . fields)
             (push.const)
             (apply.iloc (2 . 1) "../stdlib/core/records.scm" . 123916))
           (push)
           (apply.gloc.of \x2E;datum->syntax "../stdlib/core/records.scm" . 123916))
         (push)
         (push.subr.gloc.of \x2E;list 7 "../stdlib/core/records.scm" . 123916)
         (push.const)
         (push.const rtd-parent rcd-parent uid sealed opaque protocol ((fields _ _) ...))
         (push.const . #f)
         (push.gloc.of \x2E;L394)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 123916)
         (push.const . _)
         (push.const . #f)
         (push.gloc.of \x2E;L372)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 123916)
         (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/records.scm" . 123916))
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 123916)
       (push.const . _)
       (push.const . #f)
       (push.gloc.of \x2E;L396)
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 123916)
       (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/records.scm" . 123916))
     (push)
     (call
       (push.iloc.0 . 0)
       (push.const define constructor-name (record-constructor (record-type-rcd record-name)))
       (push.const (record-name . 0) (constructor-name . 0))
       (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 123916))
     (push)
     (call
       (push.iloc.0 . 0)
       (push.const define predicate-name (record-predicate (record-type-rtd record-name)))
       (push.const (record-name . 0) (predicate-name . 0))
       (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 123916))
     (push)
     (call
       (push.const . -1)
       (extend . 1)
       (push.gloc.of \x2E;values)
       (call
         (push.close
           (1 0)
           (n+.iloc (1 . 0) 1 "../stdlib/core/records.scm" . 123916)
           (set.iloc (1 . 0) "../stdlib/core/records.scm" . 123916)
           (push.iloc 2 . 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;list 2 "../stdlib/core/records.scm" . 123916)
           (push.const)
           (push.const (_ name _) n)
           (push.const . #f)
           (push.gloc.of \x2E;L389)
           (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 123916)
           (push.const . _)
           (push.const . #f)
           (push.gloc.of \x2E;L400)
           (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 123916)
           (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/records.scm" . 123916))
         (call
           (push.const . fields)
           (push.const)
           (apply.iloc (2 . 1) "../stdlib/core/records.scm" . 123916))
         (push)
         (apply.gloc.of \x2E;map "../stdlib/core/records.scm" . 123916))
       (push)
       (apply.gloc.of core.lists\x27;filter "../stdlib/core/records.scm" . 123916))
     (push)
     (call
       (push.const . -1)
       (extend . 1)
       (push.gloc.of \x2E;values)
       (call
         (push.close
           (1 0)
           (n+.iloc (1 . 0) 1 "../stdlib/core/records.scm" . 123916)
           (set.iloc (1 . 0) "../stdlib/core/records.scm" . 123916)
           (push.iloc 2 . 0)
           (push.iloc.0 . 0)
           (push.iloc.1 . 0)
           (push.subr.gloc.of \x2E;list 2 "../stdlib/core/records.scm" . 123916)
           (push.const)
           (push.const (_ _ name) n)
           (push.const . #f)
           (push.gloc.of \x2E;L367)
           (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 123916)
           (push.const . _)
           (push.const . #f)
           (push.gloc.of \x2E;L379)
           (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 123916)
           (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/records.scm" . 123916))
         (call
           (push.const . fields)
           (push.const)
           (apply.iloc (2 . 1) "../stdlib/core/records.scm" . 123916))
         (push)
         (apply.gloc.of \x2E;map "../stdlib/core/records.scm" . 123916))
       (push)
       (apply.gloc.of core.lists\x27;filter "../stdlib/core/records.scm" . 123916))
     (push)
     (push.subr.gloc.of \x2E;list 5 "../stdlib/core/records.scm" . 123916)
     (push.const)
     (push.const record-type constructor predicate (accessors ...) (mutators ...))
     (push.const . #f)
     (push.gloc.of \x2E;L401)
     (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 123916)
     (push.const . _)
     (push.const . #f)
     (push.gloc.of \x2E;L378)
     (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 123916)
     (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/records.scm" . 123916))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 120841)
   (push.const _ record-name record-clauses ...)
   (push.gloc.of \x2E;L375)
   (push.gloc.of \x2E;L397)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/records.scm" . 120841)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/records.scm" . 120841))
 (set.gloc.of \x2E;L377)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const (mutable name) accessor mutator)
   (push.const (mutator . 0) (accessor . 0) (name . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 96285))
 (set.gloc.of \x2E;L387)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const ((_ _ name) spec) (n index))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 123916))
 (set.gloc.of \x2E;L379)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const (mutable name) proc1 proc2)
   (push.const (proc2 . 0) (proc1 . 0) (name . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 105502))
 (set.gloc.of \x2E;L369)
 (close
   (1 0)
   (push.const . #f)
   (push.const . "misplaced auxiliary syntactic keyword")
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 211975))
 (set.gloc.of \x2E;L357)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const
     (record-type
       (with-syntax ((parent (stash-ref 'parent #f)))
         (with-syntax ((rtd-parent
                         (cond ((stash-ref 'parent-rtd #f) => car)
                               ((stash-ref 'parent #f) (syntax (record-type-rtd parent)))
                               (else #f)))
                       (rcd-parent
                         (cond ((stash-ref 'parent-rtd #f) => cdr)
                               ((stash-ref 'parent #f) (syntax (record-type-rcd parent)))
                               (else #f)))
                       (uid (stash-ref 'nongenerative #f))
                       (sealed (stash-ref 'sealed #f))
                       (opaque (stash-ref 'opaque #f))
                       (protocol (stash-ref 'protocol #f))
                       (((fields _ _) ...) (datum->syntax (syntax k) (stash-ref 'fields '()))))
           (syntax
             (define record-name
               (let* ((rtd
                        (make-record-type-descriptor
                          'record-name
                          rtd-parent
                          'uid
                          sealed
                          opaque
                          '#(fields ...)))
                      (rcd (make-record-constructor-descriptor rtd rcd-parent protocol)))
                 (make-record-type 'record-name rtd rcd)))))))
     (constructor
       (syntax (define constructor-name (record-constructor (record-type-rcd record-name)))))
     (predicate (syntax (define predicate-name (record-predicate (record-type-rtd record-name)))))
     ((accessors ...)
      (let ((index -1))
        (filter
          values
          (map (lambda (spec)
                 (set! index (+ index 1))
                 (with-syntax (((_ name _) spec) (n index))
                   (and (identifier? (syntax name))
                        (syntax (define name (record-accessor (record-type-rtd record-name) n))))))
               (stash-ref 'fields '())))))
     ((mutators ...)
      (let ((index -1))
        (filter
          values
          (map (lambda (spec)
                 (set! index (+ index 1))
                 (with-syntax (((_ _ name) spec) (n index))
                   (and (identifier? (syntax name))
                        (syntax (define name (record-mutator (record-type-rtd record-name) n))))))
               (stash-ref 'fields '()))))))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 123916))
 (set.gloc.of \x2E;L378)
 (close
   (1 0)
   (call
     (call
       (push.iloc.0 . 0)
       (push.const . name)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 94243))
     (push)
     (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 94243))
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (push.const . accessor)
     (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 94264))
   (push)
   (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 94264))
 (set.gloc.of \x2E;L373)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const (parent (stash-ref 'parent #f)))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/records.scm" . 123916))
 (set.gloc.of \x2E;L396)
 (close
   (1 0)
   (call
     (call
       (push.iloc.0 . 0)
       (push.const . name)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 97315))
     (push)
     (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 97315))
   (if.false.ret)
   (call
     (call
       (push.iloc.0 . 0)
       (push.const . accessor)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 97336))
     (push)
     (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 97336))
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (push.const . mutator)
     (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 97361))
   (push)
   (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 97361))
 (set.gloc.of \x2E;L358)
 (close
   (1 0)
   (call
     (call
       (push.iloc.0 . 0)
       (push.const . name)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/records.scm" . 123916))
     (push)
     (apply.gloc.of \x2E;identifier? "../stdlib/core/records.scm" . 123916))
   (if.false.ret)
   (push.iloc.0 . 0)
   (push.const define name (record-accessor (record-type-rtd record-name) n))
   (push.const (n . 0) (record-name . 0) (name . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/records.scm" . 123916))
 (set.gloc.of \x2E;L389)
 (call
   (push.const core destructuring)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/records.scm" . 198661))
 (call
   (push.const core syntax-case)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/records.scm" . 198661))
 (call
   (push.const core lists)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/records.scm" . 198661))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/records.scm" . 198661))
 (call
   (push.const
     (e1 unbound)
     (stash-ref unbound)
     (record-name unbound)
     (proc2 unbound)
     (accessor unbound)
     (record-constructor import . \x2E;record-constructor)
     (e2 unbound)
     (mutator unbound)
     (define-record-type import . core.records\x27;define-record-type)
     (k unbound)
     (parent-rtd import . core.records\x27;parent-rtd)
     (... import . \x2E;...)
     (letrec* import . \x2E;letrec*)
     (make-record-type import . \x2E;make-record-type)
     (string->symbol import . \x2E;string->symbol)
     (record-mutator import . \x2E;record-mutator)
     (set! import . \x2E;set!)
     (uid unbound)
     (proc unbound)
     (else import . \x2E;else)
     (protocol import . core.records\x27;protocol)
     (accessors unbound)
     (with-syntax import . core.syntax-case\x27;with-syntax)
     (predicate unbound)
     (n unbound)
     (base-name unbound)
     (predicate-name unbound)
     (string-append import . \x2E;string-append)
     (parent import . core.records\x27;parent)
     (cond import . \x2E;cond)
     (record-clauses unbound)
     (rtd unbound)
     (if import . \x2E;if)
     (car import . \x2E;car)
     (=> import . \x2E;=>)
     (name unbound)
     (spec unbound)
     (specs unbound)
     (record-type-descriptor import . core.records\x27;record-type-descriptor)
     (values import . \x2E;values)
     (define import . \x2E;define)
     (sealed import . core.records\x27;sealed)
     (mutators unbound)
     (record-type-rtd import . \x2E;record-type-rtd)
     (rtd-parent unbound)
     (let import . \x2E;let)
     (begin import . \x2E;begin)
     (_ import . \x2E;_)
     (identifier? import . \x2E;identifier?)
     (lambda import . \x2E;lambda)
     (record-type unbound)
     (filter import . core.lists\x27;filter)
     (record-constructor-descriptor import . core.records\x27;record-constructor-descriptor)
     (syntax import . \x2E;syntax)
     (nongenerative import . core.records\x27;nongenerative)
     (and import . \x2E;and)
     (mutable import . core.records\x27;mutable)
     (record-type-rcd import . \x2E;record-type-rcd)
     (make-record-constructor-descriptor import . \x2E;make-record-constructor-descriptor)
     (map import . \x2E;map)
     (rcd-parent unbound)
     (make-record-type-descriptor import . \x2E;make-record-type-descriptor)
     (quote import . \x2E;quote)
     (record-predicate import . \x2E;record-predicate)
     (constructor-name unbound)
     (record-accessor import . \x2E;record-accessor)
     (datum->syntax import . \x2E;datum->syntax)
     (proc1 unbound)
     (+ import . \x2E;+)
     (fields import . core.records\x27;fields)
     (immutable import . core.records\x27;immutable)
     (opaque import . core.records\x27;opaque)
     (index unbound)
     (cdr import . \x2E;cdr)
     (rcd unbound)
     (core.lists\x27;filter unbound)
     (method-name unbound)
     (let* import . \x2E;let*)
     (constructor unbound))
   (extend . 1)
   (call
     (push.const . syntax)
     (push.const . core.records\x27;define-record-type)
     (call
       (push.gloc.of \x2E;L377)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/records.scm" . 45061))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/records.scm" . 45061))
   (call
     (push.const . syntax)
     (push.const . core.records\x27;record-type-descriptor)
     (call
       (push.gloc.of \x2E;L376)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/records.scm" . 45061))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/records.scm" . 45061))
   (call
     (push.const . syntax)
     (push.const . core.records\x27;record-constructor-descriptor)
     (call
       (push.gloc.of \x2E;L382)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/records.scm" . 45061))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/records.scm" . 45061))
   (call
     (push.const . syntax)
     (push.const . core.records\x27;fields)
     (call
       (push.gloc.of \x2E;L362)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/records.scm" . 45061))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/records.scm" . 45061))
   (call
     (push.const . syntax)
     (push.const . core.records\x27;mutable)
     (call
       (push.gloc.of \x2E;L395)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/records.scm" . 45061))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/records.scm" . 45061))
   (call
     (push.const . syntax)
     (push.const . core.records\x27;immutable)
     (call
       (push.gloc.of \x2E;L364)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/records.scm" . 45061))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/records.scm" . 45061))
   (call
     (push.const . syntax)
     (push.const . core.records\x27;parent)
     (call
       (push.gloc.of \x2E;L384)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/records.scm" . 45061))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/records.scm" . 45061))
   (call
     (push.const . syntax)
     (push.const . core.records\x27;protocol)
     (call
       (push.gloc.of \x2E;L371)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/records.scm" . 45061))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/records.scm" . 45061))
   (call
     (push.const . syntax)
     (push.const . core.records\x27;sealed)
     (call
       (push.gloc.of \x2E;L357)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/records.scm" . 45061))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/records.scm" . 45061))
   (call
     (push.const . syntax)
     (push.const . core.records\x27;opaque)
     (call
       (push.gloc.of \x2E;L392)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/records.scm" . 45061))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/records.scm" . 45061))
   (call
     (push.const . syntax)
     (push.const . core.records\x27;nongenerative)
     (call
       (push.gloc.of \x2E;L388)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/records.scm" . 45061))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/records.scm" . 45061))
   (push.const . syntax)
   (push.const . core.records\x27;parent-rtd)
   (call
     (push.gloc.of \x2E;L381)
     (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/records.scm" . 45061))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/records.scm" . 45061))
 (push.const . core.records)
 (push.const . #f)
 (push.const
   (make-record-type-descriptor import . \x2E;make-record-type-descriptor)
   (record-type-descriptor? import . \x2E;record-type-descriptor?)
   (make-record-constructor-descriptor import . \x2E;make-record-constructor-descriptor)
   (record-constructor import . \x2E;record-constructor)
   (record-predicate import . \x2E;record-predicate)
   (record-accessor import . \x2E;record-accessor)
   (record-mutator import . \x2E;record-mutator)
   (record? import . \x2E;record?)
   (record-rtd import . \x2E;record-rtd)
   (record-type-name import . \x2E;record-type-name)
   (record-type-parent import . \x2E;record-type-parent)
   (record-type-uid import . \x2E;record-type-uid)
   (record-type-generative? import . \x2E;record-type-generative?)
   (record-type-sealed? import . \x2E;record-type-sealed?)
   (record-type-opaque? import . \x2E;record-type-opaque?)
   (record-type-field-names import . \x2E;record-type-field-names)
   (record-field-mutable? import . \x2E;record-field-mutable?)
   (record-type-descriptor import . core.records\x27;record-type-descriptor)
   (record-constructor-descriptor import . core.records\x27;record-constructor-descriptor)
   (define-record-type import . core.records\x27;define-record-type)
   (fields import . core.records\x27;fields)
   (mutable import . core.records\x27;mutable)
   (immutable import . core.records\x27;immutable)
   (parent import . core.records\x27;parent)
   (protocol import . core.records\x27;protocol)
   (sealed import . core.records\x27;sealed)
   (opaque import . core.records\x27;opaque)
   (nongenerative import . core.records\x27;nongenerative)
   (parent-rtd import . core.records\x27;parent-rtd))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/records.scm" . 198661))

((close
   (1 0)
   (push.iloc.0 . 0)
   (push.const
     begin
     (define-record-type
       (condition-type constructor temp)
       (parent supertype)
       (nongenerative)
       (fields (immutable cond-fields rec-accessors) ...))
     (define predicate (condition-predicate (record-type-descriptor condition-type)))
     (define cond-accessors
       (condition-accessor (record-type-descriptor condition-type) rec-accessors))
     ...)
   (push.const
     (cond-accessors . 1)
     (predicate . 0)
     (rec-accessors . 1)
     (cond-fields . 1)
     (supertype . 0)
     (constructor . 0)
     (condition-type . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/conditions.scm" . 36874))
 (set.gloc.of \x2E;L450)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const ((rec-accessors ...) (generate-temporaries (syntax (cond-fields ...)))))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/conditions.scm" . 36874))
 (set.gloc.of \x2E;L451)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (call
     (call
       (push.iloc.0 . 0)
       (push.const cond-fields ...)
       (push.const (cond-fields . 1))
       (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/conditions.scm" . 36874))
     (push)
     (apply.gloc.of \x2E;generate-temporaries "../stdlib/core/conditions.scm" . 36874))
   (push)
   (push.subr.gloc.of \x2E;list 1 "../stdlib/core/conditions.scm" . 36874)
   (push.const)
   (push.const (rec-accessors ...))
   (push.const . #f)
   (push.gloc.of \x2E;L450)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/conditions.scm" . 36874)
   (push.const . _)
   (push.const . #f)
   (push.gloc.of \x2E;L451)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/conditions.scm" . 36874)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/conditions.scm" . 36874))
 (set.gloc.of \x2E;L452)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const _ condition-type supertype constructor predicate (cond-fields cond-accessors) ...)
   (push.const . #f)
   (push.gloc.of \x2E;L452)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/conditions.scm" . 32775)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/conditions.scm" . 32775))
 (set.gloc.of \x2E;L453)
 (call
   (push.const core records)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/conditions.scm" . 36874))
 (call
   (push.const core syntax-case)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/conditions.scm" . 36874))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/conditions.scm" . 36874))
 (call
   (push.const . syntax)
   (push.const . core.conditions\x27;define-condition-type)
   (call
     (push.gloc.of \x2E;L453)
     (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/conditions.scm" . 31749))
   (push)
   (push.const
     (quote import . \x2E;quote)
     (predicate unbound)
     (cond-fields unbound)
     (nongenerative import . core.records\x27;nongenerative)
     (parent import . core.records\x27;parent)
     (constructor unbound)
     (define-condition-type import . core.conditions\x27;define-condition-type)
     (condition-accessor import . \x2E;condition-accessor)
     (condition-predicate import . \x2E;condition-predicate)
     (immutable import . core.records\x27;immutable)
     (generate-temporaries import . \x2E;generate-temporaries)
     (begin import . \x2E;begin)
     (lambda import . \x2E;lambda)
     (define-record-type import . core.records\x27;define-record-type)
     (record-type-descriptor import . core.records\x27;record-type-descriptor)
     (_ import . \x2E;_)
     (rec-accessors unbound)
     (fields import . core.records\x27;fields)
     (supertype unbound)
     (temp unbound)
     (condition-type unbound)
     (define import . \x2E;define)
     (syntax import . \x2E;syntax)
     (let import . \x2E;let)
     (cond-accessors unbound)
     (... import . \x2E;...)
     (with-syntax import . core.syntax-case\x27;with-syntax))
   (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/conditions.scm" . 31749))
 (push.const . core.conditions)
 (push.const . #f)
 (push.const
   (define-condition-type import . core.conditions\x27;define-condition-type)
   (condition import . \x2E;condition)
   (simple-conditions import . \x2E;simple-conditions)
   (condition? import . \x2E;condition?)
   (condition-predicate import . \x2E;condition-predicate)
   (condition-accessor import . \x2E;condition-accessor)
   (&condition import . \x2E;&condition)
   (&message import . \x2E;&message)
   (make-message-condition import . \x2E;make-message-condition)
   (message-condition? import . \x2E;message-condition?)
   (condition-message import . \x2E;condition-message)
   (&warning import . \x2E;&warning)
   (make-warning import . \x2E;make-warning)
   (warning? import . \x2E;warning?)
   (&serious import . \x2E;&serious)
   (make-serious-condition import . \x2E;make-serious-condition)
   (serious-condition? import . \x2E;serious-condition?)
   (&error import . \x2E;&error)
   (make-error import . \x2E;make-error)
   (error? import . \x2E;error?)
   (&violation import . \x2E;&violation)
   (make-violation import . \x2E;make-violation)
   (violation? import . \x2E;violation?)
   (&assertion import . \x2E;&assertion)
   (make-assertion-violation import . \x2E;make-assertion-violation)
   (assertion-violation? import . \x2E;assertion-violation?)
   (&irritants import . \x2E;&irritants)
   (make-irritants-condition import . \x2E;make-irritants-condition)
   (irritants-condition? import . \x2E;irritants-condition?)
   (condition-irritants import . \x2E;condition-irritants)
   (&who import . \x2E;&who)
   (make-who-condition import . \x2E;make-who-condition)
   (who-condition? import . \x2E;who-condition?)
   (condition-who import . \x2E;condition-who)
   (&non-continuable import . \x2E;&non-continuable)
   (make-non-continuable-violation import . \x2E;make-non-continuable-violation)
   (non-continuable-violation? import . \x2E;non-continuable-violation?)
   (&implementation-restriction import . \x2E;&implementation-restriction)
   (make-implementation-restriction-violation
     import
     .
     \x2E;make-implementation-restriction-violation)
   (implementation-restriction-violation? import . \x2E;implementation-restriction-violation?)
   (&lexical import . \x2E;&lexical)
   (make-lexical-violation import . \x2E;make-lexical-violation)
   (lexical-violation? import . \x2E;lexical-violation?)
   (&syntax import . \x2E;&syntax)
   (make-syntax-violation import . \x2E;make-syntax-violation)
   (syntax-violation? import . \x2E;syntax-violation?)
   (syntax-violation-form import . \x2E;syntax-violation-form)
   (syntax-violation-subform import . \x2E;syntax-violation-subform)
   (&undefined import . \x2E;&undefined)
   (make-undefined-violation import . \x2E;make-undefined-violation)
   (undefined-violation? import . \x2E;undefined-violation?))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/conditions.scm" . 36874))

((close
   (1 0)
   (ret.close
     (1 0)
     (push.iloc.1 . 0)
     (push.const . 1)
     (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 38979)
     (push.const . 1)
     (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 38959)
     (push.iloc.0 . 0)
     (push.const . #f)
     (ret.subr.gloc.of \x2E;core-hashtable-ref "../stdlib/core/enums.scm" . 38939)))
 (set.gloc.of \x2E;L469)
 (close
   (1 0)
   (ret.close
     (1 0)
     (call
       (push.iloc.0 . 0)
       (apply.gloc.of core.lists\x27;remove-duplicate-symbols "../stdlib/core/enums.scm" . 42022))
     (push)
     (push.iloc.1 . 0)
     (push.const . 1)
     (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 43071)
     (push.const . 1)
     (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 43051)
     (extend . 2)
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (subr.gloc.of \x2E;symbol? 1 "../stdlib/core/enums.scm" . 45101)
         (if.false.call
           (push.const . "enum-set constructor")
           (push.const . "expected list of symbols, but got ~r as argument 1")
           (push.iloc 2 . 0)
           (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 46169)
           (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 46125))
         (push.iloc.1 . 1)
         (push.iloc.0 . 0)
         (push.const . #f)
         (subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/enums.scm" . 47149)
         (if.true.ret)
         (push.const . "enum-set constructor")
         (push.const . "excpectd symbols which belong to the universe, but got ~r as argument 1")
         (push.iloc 2 . 0)
         (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 48217)
         (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 48173))
       (push.iloc.0 . 0)
       (apply.gloc.of \x2E;for-each "../stdlib/core/enums.scm" . 44061))
     (push.const . type:enum-set)
     (push.iloc 2 . 0)
     (push.const . 1)
     (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 50220)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of \x2E;tuple "../stdlib/core/enums.scm" . 50205)))
 (set.gloc.of \x2E;L468)
 (close
   (2 0)
   (push.cdr.iloc (0 . 0) "../stdlib/core/enums.scm" . 91178)
   (push.cdr.iloc (0 . 1) "../stdlib/core/enums.scm" . 91186)
   (ret.subr.gloc.of \x2E;< "../stdlib/core/enums.scm" . 91175))
 (set.gloc.of \x2E;L471)
 (call
   (push.const core sorting)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/enums.scm" . 36887))
 (call
   (push.const core lists)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/enums.scm" . 36887))
 (call
   (push.const core struct)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/enums.scm" . 36887))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/enums.scm" . 36887))
 (close
   (2 0 . core.enums\x27;construct-enum-type)
   (push.const . type:enum-type)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.gloc.of \x2E;L469)
   (push.gloc.of \x2E;L468)
   (ret.subr.gloc.of \x2E;tuple "../stdlib/core/enums.scm" . 34823))
 (set.gloc.of core.enums\x27;construct-enum-type)
 (close
   (1 0 . core.enums\x27;make-enumeration)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.lists\x27;remove-duplicate-symbols "../stdlib/core/enums.scm" . 54298))
   (push)
   (extend . 1)
   (subr.gloc.of \x2E;make-core-hashtable 0)
   (push)
   (push.const . 0)
   (extend . 2)
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;symbol? 1 "../stdlib/core/enums.scm" . 57371)
       (if.false.call
         (push.const . make-enumeration)
         (push.const . "expected list of symbols, but got ~r as argument 1")
         (push.iloc 2 . 0)
         (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 58434)
         (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 58395))
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/enums.scm" . 59415)
       (n+.iloc (1 . 1) 1 "../stdlib/core/enums.scm" . 60451)
       (set.iloc (1 . 1) "../stdlib/core/enums.scm" . 60439)
       (ret.const.unspec))
     (push.iloc.1 . 0)
     (apply.gloc.of \x2E;for-each "../stdlib/core/enums.scm" . 56331))
   (push.const . type:enum-set)
   (call
     (push.iloc.0 . 0)
     (push.iloc.1 . 0)
     (apply.gloc.of core.enums\x27;construct-enum-type "../stdlib/core/enums.scm" . 62487))
   (push)
   (push.iloc.1 . 0)
   (ret.subr.gloc.of \x2E;tuple "../stdlib/core/enums.scm" . 63501))
 (set.gloc.of core.enums\x27;make-enumeration)
 (close
   (1 0 . core.enums\x27;enum-set-universe)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set\x60;1237* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 67595)
   (if.false.call
     (push.const . enum-set-universe)
     (push.const . "expected enum-set, but got ~r as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 68659)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 68619))
   (push.const . type:enum-set)
   (push.iloc.0 . 0)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 69654)
   (push.iloc.0 . 0)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 70697)
   (push.const . 2)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 70678)
   (ret.subr.gloc.of \x2E;tuple "../stdlib/core/enums.scm" . 69639))
 (set.gloc.of core.enums\x27;enum-set-universe)
 (close
   (1 0 . core.enums\x27;enum-set-indexer)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set\x60;1244* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 74763)
   (if.false.call
     (push.const . enum-set-indexer)
     (push.const . "expected enum-set, but got ~r as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 75826)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 75787))
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 76827)
   (push.const . 3)
   (subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 76808)
   (apply))
 (set.gloc.of core.enums\x27;enum-set-indexer)
 (close
   (1 0 . core.enums\x27;enum-set-constructor)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set\x60;1249* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 80907)
   (if.false.call
     (push.const . enum-set-constructor)
     (push.const . "expected enum-set, but got ~r as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 81974)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 81931))
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 82975)
   (push.const . 4)
   (subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 82952)
   (apply))
 (set.gloc.of core.enums\x27;enum-set-constructor)
 (close
   (1 0 . core.enums\x27;enum-set->list)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set\x60;1254* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 87051)
   (if.false.call
     (push.const . enum-set->list)
     (push.const . "expected enum-set, but got ~r as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 88112)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 88075))
   (push.iloc.0 . 0)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 89131)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 89111)
   (extend . 1)
   (push.gloc.of \x2E;car)
   (call
     (push.gloc.of \x2E;L471)
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (push.const . #f)
         (subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/enums.scm" . 92210)
         (ret.cons "../stdlib/core/enums.scm" . 92202))
       (push.iloc.1 . 0)
       (push.const . 2)
       (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 93214)
       (apply.gloc.of \x2E;map "../stdlib/core/enums.scm" . 92185))
     (push)
     (apply.gloc.of core.sorting\x27;list-sort "../stdlib/core/enums.scm" . 91150))
   (push)
   (apply.gloc.of \x2E;map "../stdlib/core/enums.scm" . 90121))
 (set.gloc.of core.enums\x27;enum-set->list)
 (close
   (2 0 . core.enums\x27;enum-set-member?)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;symbol? 1 "../stdlib/core/enums.scm" . 97291)
   (if.false.call
     (push.const . enum-set-member?)
     (push.const . "expected enum-set, but got ~r as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 98354)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/enums.scm" . 98416)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 98315))
   (push.iloc.0 . 1)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set\x60;1266* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 99339)
   (if.false.call
     (push.const . enum-set-member?)
     (push.const . "expected enum-set, but got ~r as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 100402)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/enums.scm" . 100461)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 100363))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.const . 2)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 101401)
   (subr.gloc.of \x2E;memq 2 "../stdlib/core/enums.scm" . 101388)
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of core.enums\x27;enum-set-member?)
 (close
   (2 0 . core.enums\x27;enum-set-subset?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set1\x60;1270* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 105483)
   (if.false.call
     (push.const . enum-set-subset?)
     (push.const . "expected enum-set, but got ~r as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 106546)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/enums.scm" . 106606)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 106507))
   (push.iloc.0 . 1)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set2\x60;1270* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 107531)
   (if.false.call
     (push.const . enum-set-subset?)
     (push.const . "expected enum-set, but got ~r as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 108594)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/enums.scm" . 108654)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 108555))
   (call
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of core.enums\x27;enum-set-member? "../stdlib/core/enums.scm" . 109601))
     (push.iloc.0 . 0)
     (push.const . 2)
     (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 109628)
     (apply.gloc.of core.lists\x27;for-all "../stdlib/core/enums.scm" . 109580))
   (if.false.ret)
   (call
     (push.iloc.0 . 1)
     (push.const . 1)
     (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 110633)
     (push.const . 2)
     (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 110614)
     (extend . 1)
     (push.close
       (1 0)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (ret.subr.gloc.of \x2E;memq "../stdlib/core/enums.scm" . 111651))
     (push.iloc.1 . 0)
     (push.const . 1)
     (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 111683)
     (push.const . 2)
     (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 111664)
     (apply.gloc.of core.lists\x27;for-all "../stdlib/core/enums.scm" . 111630))
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of core.enums\x27;enum-set-subset?)
 (close
   (2 0 . core.enums\x27;enum-set=?)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set1\x60;1285* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 116747)
   (if.false.call
     (push.const . enum-set=?)
     (push.const . "expected enum-set, but got ~r as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 117804)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/enums.scm" . 117864)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 117771))
   (push.iloc.0 . 1)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set2\x60;1285* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 118795)
   (if.false.call
     (push.const . enum-set=?)
     (push.const . "expected enum-set, but got ~r as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 119852)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/enums.scm" . 119912)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 119819))
   (call
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of core.enums\x27;enum-set-subset? "../stdlib/core/enums.scm" . 120844))
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of core.enums\x27;enum-set-subset? "../stdlib/core/enums.scm" . 121868))
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of core.enums\x27;enum-set=?)
 (close
   (2 0 . core.enums\x27;enum-set-union)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set1\x60;1289* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 126987)
   (if.false.call
     (push.const . enum-set-union)
     (push.const . "expected enum-set, but got ~r as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 128048)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/enums.scm" . 128108)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 128011))
   (push.iloc.0 . 1)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set2\x60;1289* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 129035)
   (if.false.call
     (push.const . enum-set-union)
     (push.const . "expected enum-set, but got ~r as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 130096)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/enums.scm" . 130156)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 130059))
   (push.iloc.0 . 0)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 131088)
   (push.iloc.0 . 1)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 131109)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 131083)
   (if.false.call
     (push.const . enum-set-union)
     (push.const . "expected same type enum-sets")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 132107))
   (push.const . type:enum-set)
   (push.iloc.0 . 0)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 133142)
   (call
     (push.iloc.0 . 0)
     (push.const . 2)
     (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 134200)
     (push.iloc.0 . 1)
     (push.const . 2)
     (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 134224)
     (push.subr.gloc.of \x2E;append 2 "../stdlib/core/enums.scm" . 134192)
     (apply.gloc.of core.lists\x27;remove-duplicate-symbols "../stdlib/core/enums.scm" . 134166))
   (push)
   (ret.subr.gloc.of \x2E;tuple "../stdlib/core/enums.scm" . 133127))
 (set.gloc.of core.enums\x27;enum-set-union)
 (close
   (2 0 . core.enums\x27;enum-set-intersection)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set1\x60;1299* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 138251)
   (if.false.call
     (push.const . enum-set-intersection)
     (push.const . "expected enum-set, but got ~r as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 139319)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/enums.scm" . 139379)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 139275))
   (push.iloc.0 . 1)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set2\x60;1299* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 140299)
   (if.false.call
     (push.const . enum-set-intersection)
     (push.const . "expected enum-set, but got ~r as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 141367)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/enums.scm" . 141427)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 141323))
   (push.iloc.0 . 0)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 142352)
   (push.iloc.0 . 1)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 142373)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 142347)
   (if.false.call
     (push.const . enum-set-intersection)
     (push.const . "expected same type enum-sets")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 143371))
   (push.iloc.0 . 1)
   (push.const . 2)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 144411)
   (extend . 1)
   (push.const . type:enum-set)
   (push.iloc.1 . 0)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 145432)
   (call
     (push.gloc.of \x2E;values)
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (subr.gloc.of \x2E;memq 2 "../stdlib/core/enums.scm" . 146493)
         (if.false.ret)
         (ret.iloc 0 . 0))
       (push.iloc.1 . 0)
       (push.const . 2)
       (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 147500)
       (apply.gloc.of \x2E;map "../stdlib/core/enums.scm" . 146471))
     (push)
     (apply.gloc.of core.lists\x27;filter "../stdlib/core/enums.scm" . 146456))
   (push)
   (ret.subr.gloc.of \x2E;tuple "../stdlib/core/enums.scm" . 145417))
 (set.gloc.of core.enums\x27;enum-set-intersection)
 (close
   (2 0 . core.enums\x27;enum-set-difference)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set1\x60;1313* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 151563)
   (if.false.call
     (push.const . enum-set-difference)
     (push.const . "expected enum-set, but got ~r as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 152629)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/enums.scm" . 152689)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 152587))
   (push.iloc.0 . 1)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set2\x60;1313* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 153611)
   (if.false.call
     (push.const . enum-set-difference)
     (push.const . "expected enum-set, but got ~r as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 154677)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/enums.scm" . 154737)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 154635))
   (push.iloc.0 . 0)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 155664)
   (push.iloc.0 . 1)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 155685)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 155659)
   (if.false.call
     (push.const . enum-set-difference)
     (push.const . "expected same type enum-sets")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 156683))
   (push.iloc.0 . 1)
   (push.const . 2)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 157723)
   (extend . 1)
   (push.const . type:enum-set)
   (push.iloc.1 . 0)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 158744)
   (call
     (push.gloc.of \x2E;values)
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (subr.gloc.of \x2E;memq 2 "../stdlib/core/enums.scm" . 159810)
         (if.true.ret.const . #f)
         (ret.iloc 0 . 0))
       (push.iloc.1 . 0)
       (push.const . 2)
       (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 160812)
       (apply.gloc.of \x2E;map "../stdlib/core/enums.scm" . 159783))
     (push)
     (apply.gloc.of core.lists\x27;filter "../stdlib/core/enums.scm" . 159768))
   (push)
   (ret.subr.gloc.of \x2E;tuple "../stdlib/core/enums.scm" . 158729))
 (set.gloc.of core.enums\x27;enum-set-difference)
 (close
   (1 0 . core.enums\x27;enum-set-complement)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set\x60;1327* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 164875)
   (if.false.call
     (push.const . enum-set-complement)
     (push.const . "expected enum-set, but got ~r as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 165941)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 165899))
   (push.iloc.0 . 0)
   (push.const . 2)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 166938)
   (extend . 1)
   (push.const . type:enum-set)
   (push.iloc.1 . 0)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 167960)
   (call
     (push.gloc.of \x2E;values)
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (subr.gloc.of \x2E;memq 2 "../stdlib/core/enums.scm" . 169026)
         (if.true.ret.const . #f)
         (ret.iloc 0 . 0))
       (push.iloc.1 . 0)
       (push.const . 1)
       (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 170047)
       (push.const . 2)
       (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 170028)
       (apply.gloc.of \x2E;map "../stdlib/core/enums.scm" . 168999))
     (push)
     (apply.gloc.of core.lists\x27;filter "../stdlib/core/enums.scm" . 168984))
   (push)
   (ret.subr.gloc.of \x2E;tuple "../stdlib/core/enums.scm" . 167945))
 (set.gloc.of core.enums\x27;enum-set-complement)
 (close
   (2 0 . core.enums\x27;enum-set-projection)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set1\x60;1339* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 174091)
   (if.false.call
     (push.const . enum-set-projection)
     (push.const . "expected enum-set, but got ~r as argument 1")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 175157)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/enums.scm" . 175217)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 175115))
   (push.iloc.0 . 1)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 (\x2E;tuple-ref set2\x60;1339* 0))
   (push.const . type:enum-set)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/enums.scm" . 176139)
   (if.false.call
     (push.const . enum-set-projection)
     (push.const . "expected enum-set, but got ~r as argument 2")
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/enums.scm" . 177205)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;list 2 "../stdlib/core/enums.scm" . 177265)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/enums.scm" . 177163))
   (push.iloc.0 . 1)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 178231)
   (push.const . 2)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 178212)
   (extend . 1)
   (push.const . type:enum-set)
   (push.iloc.1 . 1)
   (push.const . 1)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 179224)
   (call
     (push.gloc.of \x2E;values)
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (push.iloc.1 . 0)
         (subr.gloc.of \x2E;memq 2 "../stdlib/core/enums.scm" . 180285)
         (if.false.ret)
         (ret.iloc 0 . 0))
       (push.iloc.1 . 0)
       (push.const . 2)
       (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/enums.scm" . 181292)
       (apply.gloc.of \x2E;map "../stdlib/core/enums.scm" . 180263))
     (push)
     (apply.gloc.of core.lists\x27;filter "../stdlib/core/enums.scm" . 180248))
   (push)
   (ret.subr.gloc.of \x2E;tuple "../stdlib/core/enums.scm" . 179209))
 (set.gloc.of core.enums\x27;enum-set-projection)
 (call
   (push.const
     (syntax->datum import . \x2E;syntax->datum)
     (enum-set-type-set! import . core.enums\x27;enum-set-type-set!)
     (unspecified\x60;1203 import . \x2E;unspecified)
     (e unbound)
     (memq import . \x2E;memq)
     (tuple-set!\x60;1204 import . \x2E;tuple-set!)
     (tuple-ref\x60;1204 import . \x2E;tuple-ref)
     (type:enum-type\x60;1203 import . type:enum-type)
     (symbol2 unbound)
     (... import . \x2E;...)
     (syntax import . \x2E;syntax)
     (type-name unbound)
     (enum-type-members-set! import . core.enums\x27;enum-type-members-set!)
     (enum-type-indexer-set! import . core.enums\x27;enum-type-indexer-set!)
     (enum-type-members import . core.enums\x27;enum-type-members)
     (members\x60;1203 import . members)
     (tuple\x60;1204 import . \x2E;tuple)
     (tuple-ref\x60;1203 import . \x2E;tuple-ref)
     (eq?\x60;1203 import . \x2E;eq?)
     (enum-type-universe-set! import . core.enums\x27;enum-type-universe-set!)
     (make-enum-set import . core.enums\x27;make-enum-set)
     (enum-type? import . core.enums\x27;enum-type?)
     (symbol1 unbound)
     (for-all import . core.lists\x27;for-all)
     (enum-type-universe import . core.enums\x27;enum-type-universe)
     (or import . \x2E;or)
     (members\x60;1204 import . members)
     (begin import . \x2E;begin)
     (enum-set? import . core.enums\x27;enum-set?)
     (_ import . \x2E;_)
     (lambda import . \x2E;lambda)
     (enum-set-type import . core.enums\x27;enum-set-type)
     (constructor-syntax unbound)
     (tuple\x60;1203 import . \x2E;tuple)
     (eq?\x60;1204 import . \x2E;eq?)
     (x unbound)
     (define-enumeration import . core.enums\x27;define-enumeration)
     (symbol3 unbound)
     (type:enum-set\x60;1204 import . type:enum-set)
     (universe\x60;1203 import . universe)
     (type\x60;1204 import . type)
     (define import . \x2E;define)
     (make-enumeration import . core.enums\x27;make-enumeration)
     (unspecified\x60;1204 import . \x2E;unspecified)
     (syntax-case import . \x2E;syntax-case)
     (enum-set-members import . core.enums\x27;enum-set-members)
     (quote import . \x2E;quote)
     (enum-type-constructor import . core.enums\x27;enum-type-constructor)
     (tuple-set!\x60;1203 import . \x2E;tuple-set!)
     (enum-set-constructor import . core.enums\x27;enum-set-constructor)
     (constructor\x60;1203 import . constructor)
     (make-enum-type import . core.enums\x27;make-enum-type)
     (enum-set-members-set! import . core.enums\x27;enum-set-members-set!)
     (syntax-violation import . \x2E;syntax-violation)
     (constructor unbound)
     (enum-type-indexer import . core.enums\x27;enum-type-indexer)
     (define-syntax import . \x2E;define-syntax)
     (enum-type-constructor-set! import . core.enums\x27;enum-type-constructor-set!)
     (indexer\x60;1203 import . indexer))
   (extend . 1)
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;make-enum-type)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 29699)
       ((_ universe\x60;1203 members\x60;1203 indexer\x60;1203 constructor\x60;1203)
        (tuple\x60;1203
          (\x2E;quote type:enum-type\x60;1203)
          universe\x60;1203
          members\x60;1203
          indexer\x60;1203
          constructor\x60;1203)
        ((constructor\x60;1203 . 0)
         (indexer\x60;1203 . 0)
         (members\x60;1203 . 0)
         (universe\x60;1203 . 0))
        (type:enum-type\x60;1203 \x2E;quote tuple\x60;1203))
       ((_)
        (tuple\x60;1203
          (\x2E;quote type:enum-type\x60;1203)
          (unspecified\x60;1203)
          (unspecified\x60;1203)
          (unspecified\x60;1203)
          (unspecified\x60;1203))
        ()
        (unspecified\x60;1203 type:enum-type\x60;1203 \x2E;quote tuple\x60;1203)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;enum-type?)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 29699)
       ((_ obj\x60;1203)
        (eq?\x60;1203 (tuple-ref\x60;1203 obj\x60;1203 0) (\x2E;quote type:enum-type\x60;1203))
        ((obj\x60;1203 . 0))
        (type:enum-type\x60;1203 \x2E;quote tuple-ref\x60;1203 eq?\x60;1203)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;enum-type-universe)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 29699)
       ((_ obj\x60;1203)
        (tuple-ref\x60;1203 obj\x60;1203 1)
        ((obj\x60;1203 . 0))
        (tuple-ref\x60;1203)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;enum-type-members)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 29699)
       ((_ obj\x60;1203)
        (tuple-ref\x60;1203 obj\x60;1203 2)
        ((obj\x60;1203 . 0))
        (tuple-ref\x60;1203)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;enum-type-indexer)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 29699)
       ((_ obj\x60;1203)
        (tuple-ref\x60;1203 obj\x60;1203 3)
        ((obj\x60;1203 . 0))
        (tuple-ref\x60;1203)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;enum-type-constructor)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 29699)
       ((_ obj\x60;1203)
        (tuple-ref\x60;1203 obj\x60;1203 4)
        ((obj\x60;1203 . 0))
        (tuple-ref\x60;1203)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;enum-type-universe-set!)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 29699)
       ((_ obj\x60;1203 value\x60;1203)
        (tuple-set!\x60;1203 obj\x60;1203 1 value\x60;1203)
        ((value\x60;1203 . 0) (obj\x60;1203 . 0))
        (tuple-set!\x60;1203)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;enum-type-members-set!)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 29699)
       ((_ obj\x60;1203 value\x60;1203)
        (tuple-set!\x60;1203 obj\x60;1203 2 value\x60;1203)
        ((value\x60;1203 . 0) (obj\x60;1203 . 0))
        (tuple-set!\x60;1203)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;enum-type-indexer-set!)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 29699)
       ((_ obj\x60;1203 value\x60;1203)
        (tuple-set!\x60;1203 obj\x60;1203 3 value\x60;1203)
        ((value\x60;1203 . 0) (obj\x60;1203 . 0))
        (tuple-set!\x60;1203)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;enum-type-constructor-set!)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 29699)
       ((_ obj\x60;1203 value\x60;1203)
        (tuple-set!\x60;1203 obj\x60;1203 4 value\x60;1203)
        ((value\x60;1203 . 0) (obj\x60;1203 . 0))
        (tuple-set!\x60;1203)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;make-enum-set)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 30723)
       ((_ type\x60;1204 members\x60;1204)
        (tuple\x60;1204 (\x2E;quote type:enum-set\x60;1204) type\x60;1204 members\x60;1204)
        ((members\x60;1204 . 0) (type\x60;1204 . 0))
        (type:enum-set\x60;1204 \x2E;quote tuple\x60;1204))
       ((_)
        (tuple\x60;1204
          (\x2E;quote type:enum-set\x60;1204)
          (unspecified\x60;1204)
          (unspecified\x60;1204))
        ()
        (unspecified\x60;1204 type:enum-set\x60;1204 \x2E;quote tuple\x60;1204)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;enum-set?)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 30723)
       ((_ obj\x60;1204)
        (eq?\x60;1204 (tuple-ref\x60;1204 obj\x60;1204 0) (\x2E;quote type:enum-set\x60;1204))
        ((obj\x60;1204 . 0))
        (type:enum-set\x60;1204 \x2E;quote tuple-ref\x60;1204 eq?\x60;1204)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;enum-set-type)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 30723)
       ((_ obj\x60;1204)
        (tuple-ref\x60;1204 obj\x60;1204 1)
        ((obj\x60;1204 . 0))
        (tuple-ref\x60;1204)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;enum-set-members)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 30723)
       ((_ obj\x60;1204)
        (tuple-ref\x60;1204 obj\x60;1204 2)
        ((obj\x60;1204 . 0))
        (tuple-ref\x60;1204)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;enum-set-type-set!)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 30723)
       ((_ obj\x60;1204 value\x60;1204)
        (tuple-set!\x60;1204 obj\x60;1204 1 value\x60;1204)
        ((value\x60;1204 . 0) (obj\x60;1204 . 0))
        (tuple-set!\x60;1204)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (call
     (push.const . syntax)
     (push.const . core.enums\x27;enum-set-members-set!)
     (push.const
       ()
       ("../stdlib/core/enums.scm" . 30723)
       ((_ obj\x60;1204 value\x60;1204)
        (tuple-set!\x60;1204 obj\x60;1204 2 value\x60;1204)
        ((value\x60;1204 . 0) (obj\x60;1204 . 0))
        (tuple-set!\x60;1204)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
   (push.const . syntax)
   (push.const . core.enums\x27;define-enumeration)
   (push.const
     ()
     ("../stdlib/core/enums.scm" . 184325)
     ((_ type-name (symbol1 ...) constructor-syntax)
      (begin
        (define constructor (enum-set-constructor (make-enumeration '(symbol1 ...))))
        (define-syntax type-name
          (lambda (x)
            (syntax-case x
              ()
              ((_ symbol2)
               (or (memq (syntax->datum (syntax symbol2)) '(symbol1 ...))
                   (syntax-violation 'type-name "excpectd symbols which belong to the universe" x))
               (syntax 'symbol2)))))
        (define-syntax constructor-syntax
          (lambda (x)
            (syntax-case x
              ()
              ((_ symbol3 (... ...))
               (or (for-all (lambda (e) (memq e '(symbol1 ...)))
                            (syntax->datum (syntax (symbol3 (... ...)))))
                   (syntax-violation
                     'constructor-syntax
                     "excpectd symbols which belong to the universe"
                     x))
               (syntax (constructor '(symbol3 (... ...)))))))))
      ((constructor-syntax . 0) (symbol1 . 1) (type-name . 0))
      (e
        for-all
        symbol3
        syntax-violation
        syntax
        syntax->datum
        memq
        or
        symbol2
        _
        syntax-case
        x
        lambda
        define-syntax
        quote
        make-enumeration
        enum-set-constructor
        constructor
        define
        begin)))
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/enums.scm" . 36887))
 (push.const . core.enums)
 (push.const . #f)
 (push.const
   (make-enumeration import . core.enums\x27;make-enumeration)
   (enum-set? import . core.enums\x27;enum-set?)
   (enum-set-universe import . core.enums\x27;enum-set-universe)
   (enum-set-indexer import . core.enums\x27;enum-set-indexer)
   (enum-set-constructor import . core.enums\x27;enum-set-constructor)
   (enum-set->list import . core.enums\x27;enum-set->list)
   (enum-set-member? import . core.enums\x27;enum-set-member?)
   (enum-set-subset? import . core.enums\x27;enum-set-subset?)
   (enum-set=? import . core.enums\x27;enum-set=?)
   (enum-set-union import . core.enums\x27;enum-set-union)
   (enum-set-intersection import . core.enums\x27;enum-set-intersection)
   (enum-set-difference import . core.enums\x27;enum-set-difference)
   (enum-set-complement import . core.enums\x27;enum-set-complement)
   (enum-set-projection import . core.enums\x27;enum-set-projection)
   (define-enumeration import . core.enums\x27;define-enumeration))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/enums.scm" . 36887))

((close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (push.const . k)
     (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/io.scm" . 72714))
   (push)
   (call
     (push.const . output)
     (push.gloc.of core.io.assistants\x27;direction-codes)
     (apply.gloc.of core.io.assistants\x27;lookup "../stdlib/core/io.scm" . 72733))
   (push)
   (apply.gloc.of \x2E;datum->syntax "../stdlib/core/io.scm" . 72714))
 (set.gloc.of \x2E;L505)
 (close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (push.const . k)
     (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/io.scm" . 70666))
   (push)
   (call
     (push.const . input)
     (push.gloc.of core.io.assistants\x27;direction-codes)
     (apply.gloc.of core.io.assistants\x27;lookup "../stdlib/core/io.scm" . 70685))
   (push)
   (apply.gloc.of \x2E;datum->syntax "../stdlib/core/io.scm" . 70666))
 (set.gloc.of \x2E;L504)
 (close
   (1 0)
   (push.cdr.iloc (0 . 0) "../stdlib/core/io.scm" . 44085)
   (car.iloc (0 . 0) "../stdlib/core/io.scm" . 44093)
   (ret.cons "../stdlib/core/io.scm" . 44079))
 (set.gloc.of \x2E;L496)
 (close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (push.const . k)
     (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/io.scm" . 74762))
   (push)
   (call
     (push.const . input/output)
     (push.gloc.of core.io.assistants\x27;direction-codes)
     (apply.gloc.of core.io.assistants\x27;lookup "../stdlib/core/io.scm" . 74781))
   (push)
   (apply.gloc.of \x2E;datum->syntax "../stdlib/core/io.scm" . 74762))
 (set.gloc.of \x2E;L502)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const _ type)
   (push.const . #f)
   (push.close
     (1 0)
     (call
       (push.iloc.0 . 0)
       (push.const . k)
       (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/io.scm" . 58378))
     (push)
     (call
       (call
         (call
           (push.iloc.0 . 0)
           (push.const . type)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/io.scm" . 60455))
         (push)
         (apply.gloc.of \x2E;syntax->datum "../stdlib/core/io.scm" . 60440))
       (push)
       (push.gloc.of core.io.assistants\x27;type-codes)
       (push.subr.gloc.of \x2E;assq 2 "../stdlib/core/io.scm" . 60434)
       (extend . 1)
       (iloc.0 . 0)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of \x2E;cdr "../stdlib/core/io.scm" . 62482))
       (push.const . port-type)
       (push.const . "invalid port type")
       (push.iloc 2 . 0)
       (apply.gloc.of \x2E;syntax-violation "../stdlib/core/io.scm" . 62482))
     (push)
     (apply.gloc.of
       \x2E;datum->syntax
       (\x2E;datum->syntax
         (\x2E;syntax/i0n \x2E;vars\x60;1354* 'k)
         (let ((\x2E;L493\x60;1356*
                 (\x2E;assq
                   (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;1354* 'type))
                   core.io.assistants\x27;type-codes)))
           (if \x2E;L493\x60;1356*
               (\x2E;cdr \x2E;L493\x60;1356*)
               (\x2E;syntax-violation 'port-type "invalid port type" x\x60;1352*))))))
   (push.subr.gloc.of
     \x2E;list
     3
     (\x2E;list
       '(_ type)
       #f
       (lambda (\x2E;vars\x60;1354*)
         (\x2E;datum->syntax
           (\x2E;syntax/i0n \x2E;vars\x60;1354* 'k)
           (let ((\x2E;L493\x60;1356*
                   (\x2E;assq
                     (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;1354* 'type))
                     core.io.assistants\x27;type-codes)))
             (if \x2E;L493\x60;1356*
                 (\x2E;cdr \x2E;L493\x60;1356*)
                 (\x2E;syntax-violation 'port-type "invalid port type" x\x60;1352*)))))))
   (push.const . _)
   (push.const . #f)
   (push.close
     (1 0)
     (push.const . port-type)
     (push.const . "invalid port type")
     (push.iloc.1 . 0)
     (apply.gloc.of \x2E;syntax-violation "../stdlib/core/io.scm" . 64522))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 56327)
   (apply.gloc.of
     \x2E;syntax-dispatch
     (\x2E;syntax-dispatch
       \x2E;vars
       x\x60;1352*
       '()
       (\x2E;list
         '(_ type)
         #f
         (lambda (\x2E;vars\x60;1354*)
           (\x2E;datum->syntax
             (\x2E;syntax/i0n \x2E;vars\x60;1354* 'k)
             (let ((\x2E;L493\x60;1356*
                     (\x2E;assq
                       (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;1354* 'type))
                       core.io.assistants\x27;type-codes)))
               (if \x2E;L493\x60;1356*
                   (\x2E;cdr \x2E;L493\x60;1356*)
                   (\x2E;syntax-violation 'port-type "invalid port type" x\x60;1352*))))))
       (\x2E;list
         '_
         #f
         (lambda (\x2E;vars\x60;1358*)
           (\x2E;syntax-violation 'port-type "invalid port type" x\x60;1352*))))))
 (set.gloc.of \x2E;L498)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const input output)
   (push.const _ input)
   (push.const . #f)
   (push.gloc.of \x2E;L504)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 68615)
   (push.const _ output)
   (push.const . #f)
   (push.gloc.of \x2E;L505)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 68615)
   (push.const _ input output)
   (push.const . #f)
   (push.gloc.of \x2E;L502)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 68615)
   (push.const . _)
   (push.const . #f)
   (push.close
     (1 0)
     (push.const . port-direction)
     (push.const . "invalid port direction")
     (push.iloc.1 . 0)
     (apply.gloc.of \x2E;syntax-violation "../stdlib/core/io.scm" . 76810))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 68615)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/io.scm" . 68615))
 (set.gloc.of \x2E;L499)
 (call
   (push.const core enums)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/io.scm" . 72714))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/io.scm" . 72714))
 (const (input . 1) (output . 2) (input/output . 3))
 (set.gloc.of core.io.assistants\x27;direction-codes)
 (const (file . 1) (bytevector . 2) (custom . 3))
 (set.gloc.of core.io.assistants\x27;type-codes)
 (const (no-create . 1) (no-fail . 2) (no-truncate . 4))
 (set.gloc.of core.io.assistants\x27;file-option-codes)
 (const (none . 1) (line . 2) (block . 3))
 (set.gloc.of core.io.assistants\x27;buffer-mode-codes)
 (const (latin-1 . 1) (utf-8 . 2) (utf-16 . 3))
 (set.gloc.of core.io.assistants\x27;codec-codes)
 (const (none . 1) (lf . 2) (cr . 3) (crlf . 4) (nel . 5) (crnel . 6) (ls . 7))
 (set.gloc.of core.io.assistants\x27;eol-style-codes)
 (const (ignore . 1) (raise . 2) (replace . 3))
 (set.gloc.of core.io.assistants\x27;error-handling-mode-codes)
 (close
   (1 0 . core.io.assistants\x27;flip)
   (push.gloc.of \x2E;L496)
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;map "../stdlib/core/io.scm" . 44062))
 (set.gloc.of core.io.assistants\x27;flip)
 (call
   (push.gloc.of core.io.assistants\x27;codec-codes)
   (apply.gloc.of core.io.assistants\x27;flip "../stdlib/core/io.scm" . 46111))
 (set.gloc.of core.io.assistants\x27;flipped-codec-codes)
 (call
   (push.gloc.of core.io.assistants\x27;eol-style-codes)
   (apply.gloc.of core.io.assistants\x27;flip "../stdlib/core/io.scm" . 48163))
 (set.gloc.of core.io.assistants\x27;flipped-eol-style-codes)
 (call
   (push.gloc.of core.io.assistants\x27;error-handling-mode-codes)
   (apply.gloc.of core.io.assistants\x27;flip "../stdlib/core/io.scm" . 50221))
 (set.gloc.of core.io.assistants\x27;flipped-error-handling-mode-codes)
 (close
   (2 0 . core.io.assistants\x27;lookup)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;assq 2 "../stdlib/core/io.scm" . 52269)
   (extend . 1)
   (iloc.0 . 0)
   (if.false.ret)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;cdr (\x2E;cdr \x2E;L494\x60;1376*)))
 (set.gloc.of core.io.assistants\x27;lookup)
 (close
   (1 0 . core.io.assistants\x27;port-lookup-file-option-code)
   (push.iloc.0 . 0)
   (push.gloc.of core.io.assistants\x27;file-option-codes)
   (apply.gloc.of core.io.assistants\x27;lookup "../stdlib/core/io.scm" . 78902))
 (set.gloc.of core.io.assistants\x27;port-lookup-file-option-code)
 (close
   (1 0 . core.io.assistants\x27;port-lookup-buffer-mode-code)
   (push.iloc.0 . 0)
   (push.gloc.of core.io.assistants\x27;buffer-mode-codes)
   (apply.gloc.of core.io.assistants\x27;lookup "../stdlib/core/io.scm" . 79926))
 (set.gloc.of core.io.assistants\x27;port-lookup-buffer-mode-code)
 (close
   (1 0 . core.io.assistants\x27;port-lookup-codec-code)
   (push.iloc.0 . 0)
   (push.gloc.of core.io.assistants\x27;codec-codes)
   (apply.gloc.of core.io.assistants\x27;lookup "../stdlib/core/io.scm" . 80944))
 (set.gloc.of core.io.assistants\x27;port-lookup-codec-code)
 (close
   (1 0 . core.io.assistants\x27;port-lookup-eol-style-code)
   (push.iloc.0 . 0)
   (push.gloc.of core.io.assistants\x27;eol-style-codes)
   (apply.gloc.of core.io.assistants\x27;lookup "../stdlib/core/io.scm" . 81972))
 (set.gloc.of core.io.assistants\x27;port-lookup-eol-style-code)
 (close
   (1 0 . core.io.assistants\x27;port-lookup-error-handling-mode-code)
   (push.iloc.0 . 0)
   (push.gloc.of core.io.assistants\x27;error-handling-mode-codes)
   (apply.gloc.of core.io.assistants\x27;lookup "../stdlib/core/io.scm" . 83006))
 (set.gloc.of core.io.assistants\x27;port-lookup-error-handling-mode-code)
 (close
   (1 0 . core.io.assistants\x27;port-reverse-lookup-codec-code)
   (push.iloc.0 . 0)
   (push.gloc.of core.io.assistants\x27;flipped-codec-codes)
   (apply.gloc.of core.io.assistants\x27;lookup "../stdlib/core/io.scm" . 84024))
 (set.gloc.of core.io.assistants\x27;port-reverse-lookup-codec-code)
 (close
   (1 0 . core.io.assistants\x27;port-reverse-lookup-eol-style-code)
   (push.iloc.0 . 0)
   (push.gloc.of core.io.assistants\x27;flipped-eol-style-codes)
   (apply.gloc.of core.io.assistants\x27;lookup "../stdlib/core/io.scm" . 85052))
 (set.gloc.of core.io.assistants\x27;port-reverse-lookup-eol-style-code)
 (close
   (1 0 . core.io.assistants\x27;port-reverse-lookup-error-handling-mode-code)
   (push.iloc.0 . 0)
   (push.gloc.of core.io.assistants\x27;flipped-error-handling-mode-codes)
   (apply.gloc.of core.io.assistants\x27;lookup "../stdlib/core/io.scm" . 86086))
 (set.gloc.of core.io.assistants\x27;port-reverse-lookup-error-handling-mode-code)
 (call
   (call
     (call
       (push.gloc.of \x2E;car)
       (push.gloc.of core.io.assistants\x27;file-option-codes)
       (apply.gloc.of \x2E;map "../stdlib/core/io.scm" . 88133))
     (push)
     (apply.gloc.of core.enums\x27;make-enumeration "../stdlib/core/io.scm" . 88115))
   (push)
   (apply.gloc.of core.enums\x27;enum-set-constructor "../stdlib/core/io.scm" . 88093))
 (set.gloc.of core.io.assistants\x27;make-file-options)
 (call
   (push.const
     (core.io.assistants\x27;direction-codes unbound)
     (lambda import . \x2E;lambda)
     (k unbound)
     (port-type import . core.io.assistants\x27;port-type)
     (if import . \x2E;if)
     (core.io.assistants\x27;lookup unbound)
     (_ import . \x2E;_)
     (let import . \x2E;let)
     (type unbound)
     (core.io.assistants\x27;type-codes unbound)
     (input unbound)
     (quote import . \x2E;quote)
     (output unbound)
     (begin import . \x2E;begin)
     (port-direction import . core.io.assistants\x27;port-direction)
     (input/output unbound))
   (extend . 1)
   (call
     (push.const . syntax)
     (push.const . core.io.assistants\x27;port-type)
     (call
       (push.gloc.of \x2E;L498)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/io.scm" . 55301))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/io.scm" . 55301))
   (push.const . syntax)
   (push.const . core.io.assistants\x27;port-direction)
   (call
     (push.gloc.of \x2E;L499)
     (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/io.scm" . 55301))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/io.scm" . 55301))
 (push.const . core.io.assistants)
 (push.const . #f)
 (push.const
   (port-type import . core.io.assistants\x27;port-type)
   (port-direction import . core.io.assistants\x27;port-direction)
   (port-lookup-file-option-code import . core.io.assistants\x27;port-lookup-file-option-code)
   (port-lookup-buffer-mode-code import . core.io.assistants\x27;port-lookup-buffer-mode-code)
   (port-lookup-codec-code import . core.io.assistants\x27;port-lookup-codec-code)
   (port-lookup-eol-style-code import . core.io.assistants\x27;port-lookup-eol-style-code)
   (port-lookup-error-handling-mode-code
     import
     .
     core.io.assistants\x27;port-lookup-error-handling-mode-code)
   (port-reverse-lookup-codec-code import . core.io.assistants\x27;port-reverse-lookup-codec-code)
   (port-reverse-lookup-eol-style-code
     import
     .
     core.io.assistants\x27;port-reverse-lookup-eol-style-code)
   (port-reverse-lookup-error-handling-mode-code
     import
     .
     core.io.assistants\x27;port-reverse-lookup-error-handling-mode-code)
   (make-file-options import . core.io.assistants\x27;make-file-options))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/io.scm" . 72714))
((close
   (1 0)
   (push.iloc.0 . 0)
   (push.const
     or
     (<= (length options) n-options)
     (assertion-violation
       'name
       (format
         "expected ~a to ~a, but ~a arguments given"
         n-args
         n-limit
         (+ n-args (length options)))
       (cons* args ... options)))
   (push.const (args . 1) (n-limit . 0) (n-args . 0) (name . 0) (n-options . 0) (options . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/io.scm" . 226314))
 (set.gloc.of \x2E;L554)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (call
     (call
       (push.iloc.0 . 0)
       (push.const . n-args)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/io.scm" . 226314))
     (push)
     (apply.gloc.of \x2E;syntax->datum "../stdlib/core/io.scm" . 226314))
   (push)
   (call
     (call
       (push.iloc.0 . 0)
       (push.const . n-options)
       (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/io.scm" . 226314))
     (push)
     (apply.gloc.of \x2E;syntax->datum "../stdlib/core/io.scm" . 226314))
   (push)
   (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/io.scm" . 226314)
   (push.subr.gloc.of \x2E;list 1 "../stdlib/core/io.scm" . 226314)
   (push.const)
   (push.const n-limit)
   (push.const . #f)
   (push.gloc.of \x2E;L554)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 226314)
   (push.const . _)
   (push.const . #f)
   (push.gloc.of \x2E;L544)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 226314)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/io.scm" . 226314))
 (set.gloc.of \x2E;L577)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const _ name n-args n-options args ... options)
   (push.const . #f)
   (push.gloc.of \x2E;L577)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 224263)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/io.scm" . 224263))
 (set.gloc.of \x2E;L588)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (apply.gloc.of
     core.io.assistants\x27;port-lookup-file-option-code
     "../stdlib/core/io.scm"
     .
     492619))
 (set.gloc.of \x2E;L555)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const quote mode)
   (push.const (mode . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/io.scm" . 296970))
 (set.gloc.of \x2E;L543)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const _ options ...)
   (push.const . #f)
   (push.close
     (1 0)
     (call
       (call
         (push.iloc.0 . 0)
         (push.const options ...)
         (push.const (options . 1))
         (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/io.scm" . 238628))
       (push)
       (apply.gloc.of \x2E;syntax->datum "../stdlib/core/io.scm" . 238613))
     (push)
     (extend . 1)
     (call
       (call
         (call
           (push.iloc.0 . 0)
           (apply.gloc.of core.lists\x27;list-of-unique-symbols? "../stdlib/core/io.scm" . 239637))
         (if.false.ret)
         (push.gloc.of core.io.assistants\x27;port-lookup-file-option-code)
         (push.iloc.0 . 0)
         (apply.gloc.of core.lists\x27;for-all "../stdlib/core/io.scm" . 239667))
       (if.true.ret)
       (push.const . file-options)
       (push.const . "invalid option")
       (push.iloc 2 . 0)
       (apply.gloc.of \x2E;syntax-violation "../stdlib/core/io.scm" . 240656))
     (push.iloc.1 . 0)
     (push.const make-file-options '(options ...))
     (push.const (options . 1))
     (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/io.scm" . 241676))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 236551)
   (push.const . _)
   (push.const . #f)
   (push.close
     (1 0)
     (push.const . file-options)
     (push.const . "invalid syntax")
     (push.iloc.1 . 0)
     (apply.gloc.of \x2E;syntax-violation "../stdlib/core/io.scm" . 243722))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 236551)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/io.scm" . 236551))
 (set.gloc.of \x2E;L591)
 (close (0 0) (apply.gloc.of core.io\x27;open-string-output-port "../stdlib/core/io.scm" . 347171))
 (set.gloc.of \x2E;L575)
 (close (0 0) (apply.gloc.of core.io\x27;open-string-output-port "../stdlib/core/io.scm" . 524324))
 (set.gloc.of \x2E;L582)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const quote style)
   (push.const (style . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/io.scm" . 286730))
 (set.gloc.of \x2E;L550)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const _ mode)
   (push.close
     (1 0)
     (call
       (call
         (call
           (push.iloc.0 . 0)
           (push.const . mode)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/io.scm" . 294979))
         (push)
         (apply.gloc.of \x2E;syntax->datum "../stdlib/core/io.scm" . 294964))
       (push)
       (apply.gloc.of
         core.io.assistants\x27;port-lookup-error-handling-mode-code
         "../stdlib/core/io.scm"
         .
         294926))
     (if.true.ret)
     (push.const . error-handling-mode)
     (push.const . "invalid directive")
     (push.iloc.1 . 0)
     (apply.gloc.of \x2E;syntax-violation "../stdlib/core/io.scm" . 295950))
   (push.gloc.of \x2E;L543)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 292871)
   (push.const . _)
   (push.const . #f)
   (push.close
     (1 0)
     (push.const . error-handling-mode)
     (push.const . "invalid directive")
     (push.iloc.1 . 0)
     (apply.gloc.of \x2E;syntax-violation "../stdlib/core/io.scm" . 299018))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 292871)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/io.scm" . 292871))
 (set.gloc.of \x2E;L568)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (push.const quote mode)
   (push.const (mode . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/io.scm" . 262154))
 (set.gloc.of \x2E;L581)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const (n-limit (+ (datum n-args) (datum n-options))))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/io.scm" . 226314))
 (set.gloc.of \x2E;L544)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const _ mode)
   (push.close
     (1 0)
     (call
       (call
         (call
           (push.iloc.0 . 0)
           (push.const . mode)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/io.scm" . 260155))
         (push)
         (apply.gloc.of \x2E;syntax->datum "../stdlib/core/io.scm" . 260140))
       (push)
       (apply.gloc.of
         core.io.assistants\x27;port-lookup-buffer-mode-code
         "../stdlib/core/io.scm"
         .
         260110))
     (if.true.ret)
     (push.const . buffer-mode)
     (push.const . "invalid buffer mode")
     (push.iloc.1 . 0)
     (apply.gloc.of \x2E;syntax-violation "../stdlib/core/io.scm" . 261134))
   (push.gloc.of \x2E;L581)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 258055)
   (push.const . _)
   (push.const . #f)
   (push.close
     (1 0)
     (push.const . buffer-mode)
     (push.const . "invalid buffer mode")
     (push.iloc.1 . 0)
     (apply.gloc.of \x2E;syntax-violation "../stdlib/core/io.scm" . 264202))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 258055)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/io.scm" . 258055))
 (set.gloc.of \x2E;L535)
 (close
   (2 0)
   (push.iloc.0 . 0)
   (call
     (iloc.0 . 1)
     (if.false.ret)
     (push.const . open-temporary-file-port)
     (push.const . 1)
     (push.iloc.0 . 1)
     (apply.gloc.of core.io\x27;transcoder-descriptor "../stdlib/core/io.scm" . 716856))
   (push)
   (ret.subr.gloc.of \x2E;make-temporary-file-port "../stdlib/core/io.scm" . 716809))
 (set.gloc.of \x2E;L536)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const _ style)
   (push.close
     (1 0)
     (call
       (call
         (call
           (push.iloc.0 . 0)
           (push.const . style)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/io.scm" . 284729))
         (push)
         (apply.gloc.of \x2E;syntax->datum "../stdlib/core/io.scm" . 284714))
       (push)
       (apply.gloc.of
         core.io.assistants\x27;port-lookup-eol-style-code
         "../stdlib/core/io.scm"
         .
         284686))
     (if.true.ret)
     (push.const . eol-style)
     (push.const . "invalid eol style")
     (push.iloc.1 . 0)
     (apply.gloc.of \x2E;syntax-violation "../stdlib/core/io.scm" . 285710))
   (push.gloc.of \x2E;L550)
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 282631)
   (push.const . _)
   (push.const . #f)
   (push.close
     (1 0)
     (push.const . eol-style)
     (push.const . "invalid eol style")
     (push.iloc.1 . 0)
     (apply.gloc.of \x2E;syntax-violation "../stdlib/core/io.scm" . 288778))
   (push.subr.gloc.of \x2E;list 3 "../stdlib/core/io.scm" . 282631)
   (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/io.scm" . 282631))
 (set.gloc.of \x2E;L545)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (apply.gloc.of
     core.io.assistants\x27;port-lookup-file-option-code
     "../stdlib/core/io.scm"
     .
     600145))
 (set.gloc.of \x2E;L549)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (apply.gloc.of
     core.io.assistants\x27;port-lookup-file-option-code
     "../stdlib/core/io.scm"
     .
     405578))
 (set.gloc.of \x2E;L556)
 (call
   (push.const core enums)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/io.scm" . 226314))
 (call
   (push.const core optargs)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/io.scm" . 226314))
 (call
   (push.const core bytevectors)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/io.scm" . 226314))
 (call
   (push.const core conditions)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/io.scm" . 226314))
 (call
   (push.const core lists)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/io.scm" . 226314))
 (call
   (push.const core syntax-case)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/io.scm" . 226314))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/io.scm" . 226314))
 (call
   (push.const core io assistants)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/io.scm" . 226314))
 (close
   (1 0 . core.io\x27;buffer-mode?)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.io.assistants\x27;port-lookup-buffer-mode-code
       "../stdlib/core/io.scm"
       .
       268300))
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of core.io\x27;buffer-mode?)
 (push.const . type:codec)
 (push.const . utf-8)
 (subr.gloc.of \x2E;tuple 2 "../stdlib/core/io.scm" . 272418)
 (set.gloc.of core.io\x27;predefined-utf-8-codec)
 (push.const . type:codec)
 (push.const . utf-16)
 (subr.gloc.of \x2E;tuple 2 "../stdlib/core/io.scm" . 273443)
 (set.gloc.of core.io\x27;predefined-utf-16-codec)
 (push.const . type:codec)
 (push.const . latin-1)
 (subr.gloc.of \x2E;tuple 2 "../stdlib/core/io.scm" . 274468)
 (set.gloc.of core.io\x27;predefined-latin-1-codec)
 (close (0 0 . core.io\x27;utf-8-codec) (ret.gloc.of core.io\x27;predefined-utf-8-codec))
 (set.gloc.of core.io\x27;utf-8-codec)
 (close (0 0 . core.io\x27;utf-16-codec) (ret.gloc.of core.io\x27;predefined-utf-16-codec))
 (set.gloc.of core.io\x27;utf-16-codec)
 (close (0 0 . core.io\x27;latin-1-codec) (ret.gloc.of core.io\x27;predefined-latin-1-codec))
 (set.gloc.of core.io\x27;latin-1-codec)
 (close
   (1 1 . core.io\x27;make-transcoder)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;length 1 (\x2E;length options\x60;1446*))
   (push.const . 2)
   (subr.gloc.of \x2E;<= 2 (\x2E;<= (\x2E;length options\x60;1446*) 2))
   (if.false.call
     (push.const . make-transcoder)
     (push.const . "expected ~a to ~a, but ~a arguments given")
     (push.const . 1)
     (push.const . 3)
     (push.const . 1)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;length 1 (\x2E;length options\x60;1446*))
     (push.subr.gloc.of \x2E;+ 2 (\x2E;+ 1 (\x2E;length options\x60;1446*)))
     (push.subr.gloc.of
       \x2E;format
       4
       (\x2E;format
         "expected ~a to ~a, but ~a arguments given"
         1
         3
         (\x2E;+ 1 (\x2E;length options\x60;1446*))))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;cons* 2 (\x2E;cons* codec\x60;1446* options\x60;1446*))
     (apply.gloc.of
       \x2E;assertion-violation
       (\x2E;assertion-violation
         'make-transcoder
         (\x2E;format
           "expected ~a to ~a, but ~a arguments given"
           1
           3
           (\x2E;+ 1 (\x2E;length options\x60;1446*)))
         (\x2E;cons* codec\x60;1446* options\x60;1446*))))
   (push.close
     (2 0)
     (call
       (push.iloc.1 . 0)
       (push.const . 0)
       (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/io.scm" . 305185)
       (const . type:codec)
       (if.not.eq?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.const . 1)
       (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/io.scm" . 305242)
       (apply.gloc.of
         core.io.assistants\x27;port-lookup-codec-code
         "../stdlib/core/io.scm"
         .
         305218))
     (push)
     (call
       (push.iloc.0 . 0)
       (apply.gloc.of
         core.io.assistants\x27;port-lookup-eol-style-code
         "../stdlib/core/io.scm"
         .
         306199))
     (push)
     (call
       (push.iloc.0 . 1)
       (apply.gloc.of
         core.io.assistants\x27;port-lookup-error-handling-mode-code
         "../stdlib/core/io.scm"
         .
         307223))
     (push)
     (extend . 3)
     (iloc.0 . 0)
     (if.false.call
       (push.const . make-transcoder)
       (push.const . "expected codec, but got ~r, as argument 1")
       (push.iloc 2 . 0)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/io.scm" . 308284)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/io.scm" . 308246))
     (iloc.0 . 1)
     (if.false.call
       (push.const . make-transcoder)
       (push.const . "expected eol-style, but got ~r, as argument 2")
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/io.scm" . 309308)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/io.scm" . 309270))
     (iloc.0 . 2)
     (if.false.call
       (push.const . make-transcoder)
       (push.const . "expected error-handling-mode, but got ~r, as argument 3")
       (push.iloc.1 . 1)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/io.scm" . 310332)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/io.scm" . 310294))
     (push.const . 3)
     (push.subr.gloc.of \x2E;make-bytevector 1 "../stdlib/core/io.scm" . 311317)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.iloc.1 . 0)
     (subr.gloc.of \x2E;bytevector-u8-set! 3 "../stdlib/core/io.scm" . 312333)
     (push.iloc.0 . 0)
     (push.const . 1)
     (push.iloc.1 . 1)
     (subr.gloc.of \x2E;bytevector-u8-set! 3 "../stdlib/core/io.scm" . 313357)
     (push.iloc.0 . 0)
     (push.const . 2)
     (push.iloc.1 . 2)
     (subr.gloc.of \x2E;bytevector-u8-set! 3 "../stdlib/core/io.scm" . 314381)
     (push.const . type:transcoder)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of \x2E;tuple "../stdlib/core/io.scm" . 315405))
   (call
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;length 1 "../stdlib/core/io.scm" . 304170)
     (extend . 1)
     (=n.iloc (0 . 0) 2 "../stdlib/core/io.scm" . 304170)
     (if.true (ret.iloc 1 . 1))
     (=n.iloc (0 . 0) 1 (\x2E;= argc\x60;1449\x60;1456* 1))
     (if.true
       (push.iloc.1 . 1)
       (push.const . replace)
       (push.subr.gloc.of \x2E;list 1 (\x2E;list 'replace))
       (ret.subr.gloc.of \x2E;append (\x2E;append options\x60;1446* (\x2E;list 'replace))))
     (call (apply.gloc.of core.io\x27;native-eol-style "../stdlib/core/io.scm" . 304170))
     (push)
     (push.const . replace)
     (ret.subr.gloc.of \x2E;list "../stdlib/core/io.scm" . 304170))
   (push)
   (apply.gloc.of
     \x2E;apply
     (\x2E;apply
       (lambda (eol-style\x60;1450* error-handling-mode\x60;1450*)
         (let ((octet0\x60;1452*
                 (and (\x2E;eq? (\x2E;tuple-ref codec\x60;1446* 0) 'type:codec)
                      (core.io.assistants\x27;port-lookup-codec-code
                        (\x2E;tuple-ref codec\x60;1446* 1))))
               (octet1\x60;1452*
                 (core.io.assistants\x27;port-lookup-eol-style-code eol-style\x60;1450*))
               (octet2\x60;1452*
                 (core.io.assistants\x27;port-lookup-error-handling-mode-code
                   error-handling-mode\x60;1450*)))
           (or octet0\x60;1452*
               (\x2E;assertion-violation
                 'make-transcoder
                 (\x2E;format "expected codec, but got ~r, as argument 1" codec\x60;1446*)))
           (or octet1\x60;1452*
               (\x2E;assertion-violation
                 'make-transcoder
                 (\x2E;format "expected eol-style, but got ~r, as argument 2" eol-style\x60;1450*)))
           (or octet2\x60;1452*
               (\x2E;assertion-violation
                 'make-transcoder
                 (\x2E;format
                   "expected error-handling-mode, but got ~r, as argument 3"
                   error-handling-mode\x60;1450*)))
           (let ((bv\x60;1454* (\x2E;make-bytevector 3)))
             (\x2E;bytevector-u8-set! bv\x60;1454* 0 octet0\x60;1452*)
             (\x2E;bytevector-u8-set! bv\x60;1454* 1 octet1\x60;1452*)
             (\x2E;bytevector-u8-set! bv\x60;1454* 2 octet2\x60;1452*)
             (\x2E;tuple 'type:transcoder bv\x60;1454*))))
       (let ((argc\x60;1449\x60;1456* (\x2E;length options\x60;1446*)))
         (if (\x2E;= argc\x60;1449\x60;1456* 2)
             options\x60;1446*
             (if (\x2E;= argc\x60;1449\x60;1456* 1)
                 (\x2E;append options\x60;1446* (\x2E;list 'replace))
                 (\x2E;list (core.io\x27;native-eol-style) 'replace)))))))
 (set.gloc.of core.io\x27;make-transcoder)
 (close
   (3 0 . core.io\x27;transcoder-descriptor)
   (push.iloc.0 . 2)
   (push.const . 0)
   (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/io.scm" . 319504)
   (push.const . type:transcoder)
   (subr.gloc.of \x2E;eq? 2 "../stdlib/core/io.scm" . 319499)
   (if.false.call
     (push.iloc.0 . 0)
     (push.const . "expected transcoder, but got ~r, as argument ~a")
     (push.iloc.0 . 2)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;format 3 "../stdlib/core/io.scm" . 320548)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/io.scm" . 320523))
   (push.iloc.0 . 2)
   (push.const . 1)
   (ret.subr.gloc.of \x2E;tuple-ref "../stdlib/core/io.scm" . 321543))
 (set.gloc.of core.io\x27;transcoder-descriptor)
 (close
   (1 0 . core.io\x27;transcoder-codec)
   (call
     (call
       (push.const . transcoder-codec)
       (push.const . 1)
       (push.iloc.0 . 0)
       (apply.gloc.of core.io\x27;transcoder-descriptor "../stdlib/core/io.scm" . 325696))
     (push)
     (push.const . 0)
     (push.subr.gloc.of \x2E;bytevector-u8-ref 2 "../stdlib/core/io.scm" . 325677)
     (apply.gloc.of
       core.io.assistants\x27;port-reverse-lookup-codec-code
       "../stdlib/core/io.scm"
       .
       325645))
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . latin-1)
   (if.eq? (apply.gloc.of core.io\x27;latin-1-codec "../stdlib/core/io.scm" . 326676))
   (push.iloc.0 . 0)
   (const . utf-8)
   (if.eq? (apply.gloc.of core.io\x27;utf-8-codec "../stdlib/core/io.scm" . 327698))
   (push.iloc.0 . 0)
   (const . utf-16)
   (if.eq? (apply.gloc.of core.io\x27;utf-16-codec "../stdlib/core/io.scm" . 328723))
   (ret.const.unspec))
 (set.gloc.of core.io\x27;transcoder-codec)
 (close
   (1 0 . core.io\x27;transcoder-eol-style)
   (call
     (push.const . transcoder-eol-style)
     (push.const . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of core.io\x27;transcoder-descriptor "../stdlib/core/io.scm" . 332862))
   (push)
   (push.const . 1)
   (push.subr.gloc.of \x2E;bytevector-u8-ref 2 "../stdlib/core/io.scm" . 332843)
   (apply.gloc.of
     core.io.assistants\x27;port-reverse-lookup-eol-style-code
     "../stdlib/core/io.scm"
     .
     332807))
 (set.gloc.of core.io\x27;transcoder-eol-style)
 (close
   (1 0 . core.io\x27;transcoder-error-handling-mode)
   (call
     (push.const . transcoder-error-handling-mode)
     (push.const . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of core.io\x27;transcoder-descriptor "../stdlib/core/io.scm" . 336968))
   (push)
   (push.const . 2)
   (push.subr.gloc.of \x2E;bytevector-u8-ref 2 "../stdlib/core/io.scm" . 336949)
   (apply.gloc.of
     core.io.assistants\x27;port-reverse-lookup-error-handling-mode-code
     "../stdlib/core/io.scm"
     .
     336903))
 (set.gloc.of core.io\x27;transcoder-error-handling-mode)
 (call
   (push.const . type:transcoder)
   (subr.gloc.of \x2E;native-transcoder-descriptor 0)
   (push)
   (push.subr.gloc.of \x2E;tuple 2 "../stdlib/core/io.scm" . 339991)
   (extend . 1)
   (ret.close (0 0) (ret.iloc 1 . 0)))
 (set.gloc.of core.io\x27;native-transcoder)
 (close
   (0 0 . core.io\x27;native-eol-style)
   (call (apply.gloc.of core.io\x27;native-transcoder "../stdlib/core/io.scm" . 343101))
   (push)
   (apply.gloc.of core.io\x27;transcoder-eol-style "../stdlib/core/io.scm" . 343079))
 (set.gloc.of core.io\x27;native-eol-style)
 (close
   (2 0 . core.io\x27;bytevector->string)
   (push.gloc.of \x2E;L575)
   (push.close
     (2 0)
     (call
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (apply.gloc.of core.io\x27;open-bytevector-input-port "../stdlib/core/io.scm" . 349195))
     (push)
     (push.close
       (1 0)
       (extend.enclose+
         (1 0 . loop)
         (push.iloc.0 . 0)
         (subr.gloc.of \x2E;eof-object? 1 "../stdlib/core/io.scm" . 352278)
         (if.true (apply.iloc (3 . 1) "../stdlib/core/io.scm" . 352294))
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (subr.gloc.of \x2E;put-char 2 "../stdlib/core/io.scm" . 354326)
         (push.iloc 2 . 0)
         (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/io.scm" . 355356)
         (apply.iloc+ (1 . 0) "../stdlib/core/io.scm" . 355350))
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/io.scm" . 351259)
       (apply.iloc+ (0 . 0) "../stdlib/core/io.scm" . 352271))
     (apply.gloc.of
       \x2E;call-with-port
       (\x2E;call-with-port
         (core.io\x27;open-bytevector-input-port bytes\x60;1479* transcoder\x60;1479*)
         (lambda (in\x60;1483*)
           (letrec* ((loop\x60;1487*
                       (lambda (c\x60;1488*)
                         (if (\x2E;eof-object? c\x60;1488*)
                             (extract\x60;1481*)
                             (begin
                               (\x2E;put-char out\x60;1481* c\x60;1488*)
                               (loop\x60;1487* (\x2E;get-char in\x60;1483*)))))))
             (loop\x60;1487* (\x2E;get-char in\x60;1483*)))))))
   (apply.gloc.of \x2E;call-with-values "../stdlib/core/io.scm" . 226314))
 (set.gloc.of core.io\x27;bytevector->string)
 (close
   (2 0 . core.io\x27;string->bytevector)
   (push.close
     (0 0)
     (push.iloc.1 . 1)
     (apply.gloc.of core.io\x27;open-bytevector-output-port "../stdlib/core/io.scm" . 359459))
   (push.close
     (2 0)
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;make-string-input-port 1 "../stdlib/core/io.scm" . 361483)
     (push.close
       (1 0)
       (extend.enclose+
         (1 0 . loop)
         (push.iloc.0 . 0)
         (subr.gloc.of \x2E;eof-object? 1 "../stdlib/core/io.scm" . 364566)
         (if.true (apply.iloc (3 . 1) "../stdlib/core/io.scm" . 364582))
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (subr.gloc.of \x2E;put-char 2 "../stdlib/core/io.scm" . 366614)
         (push.iloc 2 . 0)
         (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/io.scm" . 367644)
         (apply.iloc+ (1 . 0) "../stdlib/core/io.scm" . 367638))
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/io.scm" . 363547)
       (apply.iloc+ (0 . 0) "../stdlib/core/io.scm" . 364559))
     (apply.gloc.of
       \x2E;call-with-port
       (\x2E;call-with-port
         (\x2E;make-string-input-port string\x60;1491*)
         (lambda (in\x60;1495*)
           (letrec* ((loop\x60;1499*
                       (lambda (c\x60;1500*)
                         (if (\x2E;eof-object? c\x60;1500*)
                             (extract\x60;1493*)
                             (begin
                               (\x2E;put-char out\x60;1493* c\x60;1500*)
                               (loop\x60;1499* (\x2E;get-char in\x60;1495*)))))))
             (loop\x60;1499* (\x2E;get-char in\x60;1495*)))))))
   (apply.gloc.of \x2E;call-with-values "../stdlib/core/io.scm" . 359459))
 (set.gloc.of core.io\x27;string->bytevector)
 (close
   (1 0 . core.io\x27;port-transcoder)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;port-transcoder-descriptor 1 "../stdlib/core/io.scm" . 373779)
   (extend . 1)
   (iloc.0 . 0)
   (if.false.ret)
   (push.iloc.0 . 0)
   (const . #t)
   (if.eq? (apply.gloc.of core.io\x27;native-transcoder "../stdlib/core/io.scm" . 376850))
   (push.const . type:transcoder)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;tuple "../stdlib/core/io.scm" . 377874))
 (set.gloc.of core.io\x27;port-transcoder)
 (close
   (1 0 . core.io\x27;textual-port?)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;port-transcoder-descriptor 1 "../stdlib/core/io.scm" . 381964)
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of core.io\x27;textual-port?)
 (close
   (1 0 . core.io\x27;binary-port?)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;port-transcoder-descriptor 1 "../stdlib/core/io.scm" . 386060)
   (ret.subr.gloc.of \x2E;not "../stdlib/core/io.scm" . 386055))
 (set.gloc.of core.io\x27;binary-port?)
 (close
   (2 0 . core.io\x27;transcoded-port)
   (push.iloc.0 . 0)
   (call
     (push.const . transcoded-port)
     (push.const . 2)
     (push.iloc.0 . 1)
     (apply.gloc.of core.io\x27;transcoder-descriptor "../stdlib/core/io.scm" . 390178))
   (push)
   (ret.subr.gloc.of \x2E;make-transcoded-port "../stdlib/core/io.scm" . 390151))
 (set.gloc.of core.io\x27;transcoded-port)
 (close
   (1 1 . core.io\x27;open-file-input-port)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;length 1 (\x2E;length options\x60;1513*))
   (push.const . 3)
   (subr.gloc.of \x2E;<= 2 (\x2E;<= (\x2E;length options\x60;1513*) 3))
   (if.false.call
     (push.const . open-file-input-port)
     (push.const . "expected ~a to ~a, but ~a arguments given")
     (push.const . 1)
     (push.const . 4)
     (push.const . 1)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;length 1 (\x2E;length options\x60;1513*))
     (push.subr.gloc.of \x2E;+ 2 (\x2E;+ 1 (\x2E;length options\x60;1513*)))
     (push.subr.gloc.of
       \x2E;format
       4
       (\x2E;format
         "expected ~a to ~a, but ~a arguments given"
         1
         4
         (\x2E;+ 1 (\x2E;length options\x60;1513*))))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;cons* 2 (\x2E;cons* filename\x60;1513* options\x60;1513*))
     (apply.gloc.of
       \x2E;assertion-violation
       (\x2E;assertion-violation
         'open-file-input-port
         (\x2E;format
           "expected ~a to ~a, but ~a arguments given"
           1
           4
           (\x2E;+ 1 (\x2E;length options\x60;1513*)))
         (\x2E;cons* filename\x60;1513* options\x60;1513*))))
   (push.close
     (3 0)
     (call (push.iloc.1 . 0) (apply.gloc.of \x2E;track-file-open "../stdlib/core/io.scm" . 400393))
     (push.const . open-file-input-port)
     (push.const . 1)
     (push.const . 1)
     (push.iloc.1 . 0)
     (call
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/io.scm" . 405578)
       (const . type:enum-set)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 0)
       (call
         (call
           (push.const)
           (apply.gloc.of
             core.io.assistants\x27;make-file-options
             "../stdlib/core/io.scm"
             .
             405578))
         (push)
         (apply.gloc.of core.enums\x27;enum-set-universe "../stdlib/core/io.scm" . 405578))
       (push)
       (apply.gloc.of core.enums\x27;enum-set-subset? "../stdlib/core/io.scm" . 405578))
     (if.false.call
       (push.const . open-file-input-port)
       (push.const . "expected file-options object, but got ~r, as argument 2")
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/io.scm" . 405578)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of \x2E;cons* 2 "../stdlib/core/io.scm" . 405578)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/io.scm" . 405578))
     (call
       (push.gloc.of \x2E;+)
       (call
         (push.gloc.of \x2E;L556)
         (call
           (push.iloc.0 . 0)
           (apply.gloc.of core.enums\x27;enum-set->list "../stdlib/core/io.scm" . 405578))
         (push)
         (apply.gloc.of \x2E;map "../stdlib/core/io.scm" . 405578))
       (push)
       (apply.gloc.of \x2E;apply "../stdlib/core/io.scm" . 405578))
     (push)
     (call
       (push.iloc.0 . 1)
       (apply.gloc.of
         core.io.assistants\x27;port-lookup-buffer-mode-code
         "../stdlib/core/io.scm"
         .
         406548))
     (push)
     (call
       (iloc.0 . 2)
       (if.false.ret)
       (push.const . open-file-input-port)
       (push.const . 4)
       (push.iloc.0 . 2)
       (apply.gloc.of core.io\x27;transcoder-descriptor "../stdlib/core/io.scm" . 407588))
     (push)
     (ret.subr.gloc.of \x2E;open-port "../stdlib/core/io.scm" . 401417))
   (call
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;length 1 "../stdlib/core/io.scm" . 397357)
     (extend . 1)
     (=n.iloc (0 . 0) 3 "../stdlib/core/io.scm" . 397357)
     (if.true (ret.iloc 1 . 1))
     (=n.iloc (0 . 0) 2 (\x2E;= argc\x60;1516\x60;1526* 2))
     (if.true
       (push.iloc.1 . 1)
       (push.const . #f)
       (push.subr.gloc.of \x2E;list 1 (\x2E;list #f))
       (ret.subr.gloc.of \x2E;append (\x2E;append options\x60;1513* (\x2E;list #f))))
     (=n.iloc (0 . 0) 1 "../stdlib/core/io.scm" . 397357)
     (if.true
       (push.iloc.1 . 1)
       (push.const . block)
       (push.const . #f)
       (push.subr.gloc.of \x2E;list 2 (\x2E;list 'block #f))
       (ret.subr.gloc.of \x2E;append (\x2E;append options\x60;1513* (\x2E;list 'block #f))))
     (call
       (push.const)
       (apply.gloc.of core.io.assistants\x27;make-file-options "../stdlib/core/io.scm" . 397357))
     (push)
     (push.const . block)
     (push.const . #f)
     (ret.subr.gloc.of
       \x2E;list
       (\x2E;list (core.io.assistants\x27;make-file-options '()) 'block #f)))
   (push)
   (apply.gloc.of
     \x2E;apply
     (\x2E;apply
       (lambda (file-options\x60;1517* buffer-mode\x60;1517* transcoder\x60;1517*)
         (\x2E;track-file-open filename\x60;1513*)
         (\x2E;open-port
           'open-file-input-port
           1
           1
           filename\x60;1513*
           (begin
             (or (and (\x2E;eq? (\x2E;tuple-ref file-options\x60;1517* 0) 'type:enum-set)
                      (core.enums\x27;enum-set-subset?
                        file-options\x60;1517*
                        (core.enums\x27;enum-set-universe
                          (core.io.assistants\x27;make-file-options '()))))
                 (\x2E;assertion-violation
                   'open-file-input-port
                   (\x2E;format
                     "expected file-options object, but got ~r, as argument 2"
                     file-options\x60;1517*)
                   (\x2E;cons* filename\x60;1513* options\x60;1513*)))
             (\x2E;apply
               \x2E;+
               (\x2E;map \x2E;L556 (core.enums\x27;enum-set->list file-options\x60;1517*))))
           (core.io.assistants\x27;port-lookup-buffer-mode-code buffer-mode\x60;1517*)
           (and transcoder\x60;1517*
                (core.io\x27;transcoder-descriptor 'open-file-input-port 4 transcoder\x60;1517*))))
       (let ((argc\x60;1516\x60;1526* (\x2E;length options\x60;1513*)))
         (if (\x2E;= argc\x60;1516\x60;1526* 3)
             options\x60;1513*
             (if (\x2E;= argc\x60;1516\x60;1526* 2)
                 (\x2E;append options\x60;1513* (\x2E;list #f))
                 (if (\x2E;= argc\x60;1516\x60;1526* 1)
                     (\x2E;append options\x60;1513* (\x2E;list 'block #f))
                     (\x2E;list (core.io.assistants\x27;make-file-options '()) 'block #f))))))))
 (set.gloc.of core.io\x27;open-file-input-port)
 (close
   (1 1 . core.io\x27;open-bytevector-input-port)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;length 1 (\x2E;length options\x60;1538*))
   (push.const . 1)
   (subr.gloc.of \x2E;<= 2 (\x2E;<= (\x2E;length options\x60;1538*) 1))
   (if.false.call
     (push.const . open-bytevector-input-port)
     (push.const . "expected ~a to ~a, but ~a arguments given")
     (push.const . 1)
     (push.const . 2)
     (push.const . 1)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;length 1 (\x2E;length options\x60;1538*))
     (push.subr.gloc.of \x2E;+ 2 (\x2E;+ 1 (\x2E;length options\x60;1538*)))
     (push.subr.gloc.of
       \x2E;format
       4
       (\x2E;format
         "expected ~a to ~a, but ~a arguments given"
         1
         2
         (\x2E;+ 1 (\x2E;length options\x60;1538*))))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;cons* 2 (\x2E;cons* bytes\x60;1538* options\x60;1538*))
     (apply.gloc.of
       \x2E;assertion-violation
       (\x2E;assertion-violation
         'open-bytevector-input-port
         (\x2E;format
           "expected ~a to ~a, but ~a arguments given"
           1
           2
           (\x2E;+ 1 (\x2E;length options\x60;1538*)))
         (\x2E;cons* bytes\x60;1538* options\x60;1538*))))
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of \x2E;car (\x2E;car options\x60;1538*)))
   (push)
   (extend . 1)
   (push.const . open-bytevector-input-port)
   (push.const . 2)
   (push.const . 1)
   (push.const . bytevector)
   (push.iloc.1 . 0)
   (push.const . #f)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.const . open-bytevector-input-port)
     (push.const . 2)
     (push.iloc.0 . 0)
     (apply.gloc.of core.io\x27;transcoder-descriptor "../stdlib/core/io.scm" . 419876))
   (push)
   (ret.subr.gloc.of \x2E;open-port "../stdlib/core/io.scm" . 413705))
 (set.gloc.of core.io\x27;open-bytevector-input-port)
 (close
   (1 0 . core.io\x27;open-string-input-port)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;make-string-input-port "../stdlib/core/io.scm" . 423943))
 (set.gloc.of core.io\x27;open-string-input-port)
 (close
   (5 0 . core.io\x27;make-custom-binary-input-port)
   (push.const . make-custom-binary-input-port)
   (push.const . 3)
   (push.const . 1)
   (push.iloc.0 . 0)
   (push.const . #f)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.iloc.0 . 4)
   (push.subr.gloc.of \x2E;vector 6 "../stdlib/core/io.scm" . 432146)
   (push.const . #f)
   (push.const . #f)
   (ret.subr.gloc.of \x2E;open-port "../stdlib/core/io.scm" . 428039))
 (set.gloc.of core.io\x27;make-custom-binary-input-port)
 (close
   (5 0 . core.io\x27;make-custom-textual-input-port)
   (extend.unbound . 4)
   (push.close
     (3 0 . bv-read!)
     (=n.iloc (0 . 2) 0 "../stdlib/core/io.scm" . 443410)
     (if.true.ret.const . 0)
     (push.iloc.0 . 2)
     (push.const . 4)
     (push.subr.gloc.of \x2E;div 2 "../stdlib/core/io.scm" . 445470)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . #\nul)
     (push.subr.gloc.of \x2E;make-string 2 "../stdlib/core/io.scm" . 446494)
     (extend . 1)
     (call
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.iloc.1 . 0)
       (apply.iloc (4 . 1) "../stdlib/core/io.scm" . 447520))
     (push)
     (extend . 1)
     (=n.iloc (0 . 0) 0 "../stdlib/core/io.scm" . 448539)
     (if.true.ret.const . 0)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;substring 3 "../stdlib/core/io.scm" . 450617)
     (push.subr.gloc.of \x2E;string->utf8 1 "../stdlib/core/io.scm" . 450603)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;bytevector-length 1 "../stdlib/core/io.scm" . 451625)
     (extend . 1)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.iloc 5 . 0)
     (push.iloc 5 . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;bytevector-copy! 5 "../stdlib/core/io.scm" . 452637)
     (ret.iloc 0 . 0))
   (push.close
     (1 0 . bv-get-position)
     (push.iloc.1 . 3)
     (push.iloc.0 . 0)
     (call (apply.iloc (2 . 2) "../stdlib/core/io.scm" . 457775))
     (push)
     (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/io.scm" . 457739)
     (ret.iloc 0 . 0))
   (push.close
     (1 0 . bv-set-position!)
     (push.iloc.1 . 3)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/io.scm" . 462866)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (apply.iloc (3 . 3) "../stdlib/core/io.scm" . 463907))
     (subr.gloc.of \x2E;warning-level 0 "../stdlib/core/io.scm" . 464914)
     (if.true
       (subr.gloc.of \x2E;current-error-port 0)
       (push)
       (push.const
         .
         "~&warning in set-port-position: expected return value of a call to get-position, but got ~u~%~!")
       (push.iloc.1 . 0)
       (subr.gloc.of \x2E;format 3 "../stdlib/core/io.scm" . 465938)
       (push.iloc.1 . 0)
       (apply.iloc (3 . 3) "../stdlib/core/io.scm" . 466962))
     (push.iloc.1 . 0)
     (apply.iloc (3 . 3) "../stdlib/core/io.scm" . 469010))
   (enclose . 3)
   (push.const . eqv?)
   (subr.gloc.of \x2E;make-core-hashtable 1 "../stdlib/core/io.scm" . 439320)
   (set.iloc (0 . 3))
   (push.const . make-custom-textual-input-port)
   (push.const . 3)
   (push.const . 1)
   (push.iloc.1 . 0)
   (push.const . #t)
   (call (iloc.1 . 1) (if.false.ret) (ret.iloc 0 . 0))
   (push)
   (push.const . #f)
   (call (iloc.1 . 2) (if.false.ret) (ret.iloc 0 . 1))
   (push)
   (call (iloc.1 . 3) (if.false.ret) (ret.iloc 0 . 2))
   (push)
   (push.iloc.1 . 4)
   (push.subr.gloc.of \x2E;vector 6 "../stdlib/core/io.scm" . 475154)
   (push.const . #f)
   (push.const . #t)
   (ret.subr.gloc.of \x2E;open-port "../stdlib/core/io.scm" . 471047))
 (set.gloc.of core.io\x27;make-custom-textual-input-port)
 (close
   (1 1 . core.io\x27;open-file-output-port)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;length 1 (\x2E;length options\x60;1578*))
   (push.const . 3)
   (subr.gloc.of \x2E;<= 2 (\x2E;<= (\x2E;length options\x60;1578*) 3))
   (if.false.call
     (push.const . open-file-output-port)
     (push.const . "expected ~a to ~a, but ~a arguments given")
     (push.const . 1)
     (push.const . 4)
     (push.const . 1)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;length 1 (\x2E;length options\x60;1578*))
     (push.subr.gloc.of \x2E;+ 2 (\x2E;+ 1 (\x2E;length options\x60;1578*)))
     (push.subr.gloc.of
       \x2E;format
       4
       (\x2E;format
         "expected ~a to ~a, but ~a arguments given"
         1
         4
         (\x2E;+ 1 (\x2E;length options\x60;1578*))))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;cons* 2 (\x2E;cons* filename\x60;1578* options\x60;1578*))
     (apply.gloc.of
       \x2E;assertion-violation
       (\x2E;assertion-violation
         'open-file-output-port
         (\x2E;format
           "expected ~a to ~a, but ~a arguments given"
           1
           4
           (\x2E;+ 1 (\x2E;length options\x60;1578*)))
         (\x2E;cons* filename\x60;1578* options\x60;1578*))))
   (push.close
     (3 0)
     (call (push.iloc.1 . 0) (apply.gloc.of \x2E;track-file-open "../stdlib/core/io.scm" . 487433))
     (push.const . open-file-output-port)
     (push.const . 1)
     (push.const . 2)
     (push.iloc.1 . 0)
     (call
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/io.scm" . 492619)
       (const . type:enum-set)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 0)
       (call
         (call
           (push.const)
           (apply.gloc.of
             core.io.assistants\x27;make-file-options
             "../stdlib/core/io.scm"
             .
             492619))
         (push)
         (apply.gloc.of core.enums\x27;enum-set-universe "../stdlib/core/io.scm" . 492619))
       (push)
       (apply.gloc.of core.enums\x27;enum-set-subset? "../stdlib/core/io.scm" . 492619))
     (if.false.call
       (push.const . open-file-output-port)
       (push.const . "expected file-options object, but got ~r, as argument 2")
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/io.scm" . 492619)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of \x2E;cons* 2 "../stdlib/core/io.scm" . 492619)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/io.scm" . 492619))
     (call
       (push.gloc.of \x2E;+)
       (call
         (push.gloc.of \x2E;L555)
         (call
           (push.iloc.0 . 0)
           (apply.gloc.of core.enums\x27;enum-set->list "../stdlib/core/io.scm" . 492619))
         (push)
         (apply.gloc.of \x2E;map "../stdlib/core/io.scm" . 492619))
       (push)
       (apply.gloc.of \x2E;apply "../stdlib/core/io.scm" . 492619))
     (push)
     (call
       (push.iloc.0 . 1)
       (apply.gloc.of
         core.io.assistants\x27;port-lookup-buffer-mode-code
         "../stdlib/core/io.scm"
         .
         493588))
     (push)
     (call
       (iloc.0 . 2)
       (if.false.ret)
       (push.const . open-file-output-port)
       (push.const . 4)
       (push.iloc.0 . 2)
       (apply.gloc.of core.io\x27;transcoder-descriptor "../stdlib/core/io.scm" . 494628))
     (push)
     (ret.subr.gloc.of \x2E;open-port "../stdlib/core/io.scm" . 488457))
   (call
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;length 1 "../stdlib/core/io.scm" . 484397)
     (extend . 1)
     (=n.iloc (0 . 0) 3 "../stdlib/core/io.scm" . 484397)
     (if.true (ret.iloc 1 . 1))
     (=n.iloc (0 . 0) 2 (\x2E;= argc\x60;1581\x60;1591* 2))
     (if.true
       (push.iloc.1 . 1)
       (push.const . #f)
       (push.subr.gloc.of \x2E;list 1 (\x2E;list #f))
       (ret.subr.gloc.of \x2E;append (\x2E;append options\x60;1578* (\x2E;list #f))))
     (=n.iloc (0 . 0) 1 "../stdlib/core/io.scm" . 484397)
     (if.true
       (push.iloc.1 . 1)
       (push.const . block)
       (push.const . #f)
       (push.subr.gloc.of \x2E;list 2 (\x2E;list 'block #f))
       (ret.subr.gloc.of \x2E;append (\x2E;append options\x60;1578* (\x2E;list 'block #f))))
     (call
       (push.const)
       (apply.gloc.of core.io.assistants\x27;make-file-options "../stdlib/core/io.scm" . 484397))
     (push)
     (push.const . block)
     (push.const . #f)
     (ret.subr.gloc.of
       \x2E;list
       (\x2E;list (core.io.assistants\x27;make-file-options '()) 'block #f)))
   (push)
   (apply.gloc.of
     \x2E;apply
     (\x2E;apply
       (lambda (file-options\x60;1582* buffer-mode\x60;1582* transcoder\x60;1582*)
         (\x2E;track-file-open filename\x60;1578*)
         (\x2E;open-port
           'open-file-output-port
           1
           2
           filename\x60;1578*
           (begin
             (or (and (\x2E;eq? (\x2E;tuple-ref file-options\x60;1582* 0) 'type:enum-set)
                      (core.enums\x27;enum-set-subset?
                        file-options\x60;1582*
                        (core.enums\x27;enum-set-universe
                          (core.io.assistants\x27;make-file-options '()))))
                 (\x2E;assertion-violation
                   'open-file-output-port
                   (\x2E;format
                     "expected file-options object, but got ~r, as argument 2"
                     file-options\x60;1582*)
                   (\x2E;cons* filename\x60;1578* options\x60;1578*)))
             (\x2E;apply
               \x2E;+
               (\x2E;map \x2E;L555 (core.enums\x27;enum-set->list file-options\x60;1582*))))
           (core.io.assistants\x27;port-lookup-buffer-mode-code buffer-mode\x60;1582*)
           (and transcoder\x60;1582*
                (core.io\x27;transcoder-descriptor 'open-file-output-port 4 transcoder\x60;1582*))))
       (let ((argc\x60;1581\x60;1591* (\x2E;length options\x60;1578*)))
         (if (\x2E;= argc\x60;1581\x60;1591* 3)
             options\x60;1578*
             (if (\x2E;= argc\x60;1581\x60;1591* 2)
                 (\x2E;append options\x60;1578* (\x2E;list #f))
                 (if (\x2E;= argc\x60;1581\x60;1591* 1)
                     (\x2E;append options\x60;1578* (\x2E;list 'block #f))
                     (\x2E;list (core.io.assistants\x27;make-file-options '()) 'block #f))))))))
 (set.gloc.of core.io\x27;open-file-output-port)
 (close
   (1 0 . core.io\x27;bytevector-output-port-values)
   (push.iloc.0 . 0)
   (push.close
     (0 0)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of \x2E;extract-accumulated-bytevector "../stdlib/core/io.scm" . 498719))
   (ret.subr.gloc.of \x2E;values "../stdlib/core/io.scm" . 498695))
 (set.gloc.of core.io\x27;bytevector-output-port-values)
 (close
   (0 1 . core.io\x27;open-bytevector-output-port)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;length 1 (\x2E;length options\x60;1607*))
   (push.const . 1)
   (subr.gloc.of \x2E;<= 2 (\x2E;<= (\x2E;length options\x60;1607*) 1))
   (if.false.call
     (push.const . open-bytevector-output-port)
     (push.const . "expected ~a to ~a, but ~a arguments given")
     (push.const . 0)
     (push.const . 1)
     (push.const . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;length 1 (\x2E;length options\x60;1607*))
     (push.subr.gloc.of \x2E;+ 2 (\x2E;+ 0 (\x2E;length options\x60;1607*)))
     (push.subr.gloc.of
       \x2E;format
       4
       (\x2E;format
         "expected ~a to ~a, but ~a arguments given"
         0
         1
         (\x2E;+ 0 (\x2E;length options\x60;1607*))))
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cons* 1 (\x2E;cons* options\x60;1607*))
     (apply.gloc.of
       \x2E;assertion-violation
       (\x2E;assertion-violation
         'open-bytevector-output-port
         (\x2E;format
           "expected ~a to ~a, but ~a arguments given"
           0
           1
           (\x2E;+ 0 (\x2E;length options\x60;1607*)))
         (\x2E;cons* options\x60;1607*))))
   (call
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 0)
     (ret.subr.gloc.of \x2E;car (\x2E;car options\x60;1607*)))
   (push)
   (extend . 1)
   (push.const . open-bytevector-output-port)
   (push.const . 2)
   (push.const . 2)
   (push.const . bytevector)
   (push.const . #f)
   (push.const . #f)
   (call
     (iloc.0 . 0)
     (if.false.ret)
     (push.const . open-bytevector-output-port)
     (push.const . 1)
     (push.iloc.0 . 0)
     (apply.gloc.of core.io\x27;transcoder-descriptor "../stdlib/core/io.scm" . 512037))
   (push)
   (push.subr.gloc.of \x2E;open-port 7 "../stdlib/core/io.scm" . 505866)
   (apply.gloc.of core.io\x27;bytevector-output-port-values "../stdlib/core/io.scm" . 504841))
 (set.gloc.of core.io\x27;open-bytevector-output-port)
 (close
   (1 1 . core.io\x27;call-with-bytevector-output-port)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;length 1 (\x2E;length options\x60;1615*))
   (push.const . 1)
   (subr.gloc.of \x2E;<= 2 (\x2E;<= (\x2E;length options\x60;1615*) 1))
   (if.false.call
     (push.const . call-with-bytevector-output-port)
     (push.const . "expected ~a to ~a, but ~a arguments given")
     (push.const . 1)
     (push.const . 2)
     (push.const . 1)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;length 1 (\x2E;length options\x60;1615*))
     (push.subr.gloc.of \x2E;+ 2 (\x2E;+ 1 (\x2E;length options\x60;1615*)))
     (push.subr.gloc.of
       \x2E;format
       4
       (\x2E;format
         "expected ~a to ~a, but ~a arguments given"
         1
         2
         (\x2E;+ 1 (\x2E;length options\x60;1615*))))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;cons* 2 (\x2E;cons* proc\x60;1615* options\x60;1615*))
     (apply.gloc.of
       \x2E;assertion-violation
       (\x2E;assertion-violation
         'call-with-bytevector-output-port
         (\x2E;format
           "expected ~a to ~a, but ~a arguments given"
           1
           2
           (\x2E;+ 1 (\x2E;length options\x60;1615*)))
         (\x2E;cons* proc\x60;1615* options\x60;1615*))))
   (call
     (iloc.0 . 1)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 1)
     (ret.subr.gloc.of \x2E;car (\x2E;car options\x60;1615*)))
   (push)
   (extend . 1)
   (push.close
     (0 0)
     (push.iloc.1 . 0)
     (apply.gloc.of core.io\x27;open-bytevector-output-port "../stdlib/core/io.scm" . 518182))
   (push.close
     (2 0)
     (call (push.iloc.0 . 0) (apply.iloc (2 . 0) "../stdlib/core/io.scm" . 519179))
     (call (apply.iloc (0 . 1) "../stdlib/core/io.scm" . 520217))
     (push)
     (extend . 1)
     (push.iloc.1 . 0)
     (subr.gloc.of \x2E;close-port 1 "../stdlib/core/io.scm" . 520229)
     (ret.iloc 0 . 0))
   (apply.gloc.of
     \x2E;call-with-values
     (\x2E;call-with-values
       (lambda () (core.io\x27;open-bytevector-output-port transcoder\x60;1619*))
       (lambda (port\x60;1621* extract\x60;1621*)
         (proc\x60;1615* port\x60;1621*)
         (let ((result\x60;1623* (extract\x60;1621*)))
           (\x2E;close-port port\x60;1621*)
           result\x60;1623*)))))
 (set.gloc.of core.io\x27;call-with-bytevector-output-port)
 (close
   (1 0 . core.io\x27;call-with-string-output-port)
   (push.gloc.of \x2E;L582)
   (push.close
     (2 0)
     (call (push.iloc.0 . 0) (apply.iloc (1 . 0) "../stdlib/core/io.scm" . 525321))
     (call (apply.iloc (0 . 1) "../stdlib/core/io.scm" . 526359))
     (push)
     (extend . 1)
     (push.iloc.1 . 0)
     (subr.gloc.of \x2E;close-port 1 "../stdlib/core/io.scm" . 526371)
     (ret.iloc 0 . 0))
   (apply.gloc.of \x2E;call-with-values "../stdlib/core/io.scm" . 226314))
 (set.gloc.of core.io\x27;call-with-string-output-port)
 (close
   (1 0 . core.io\x27;string-output-port-values)
   (push.iloc.0 . 0)
   (push.close
     (0 0)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of \x2E;extract-accumulated-string "../stdlib/core/io.scm" . 530463))
   (ret.subr.gloc.of \x2E;values "../stdlib/core/io.scm" . 530439))
 (set.gloc.of core.io\x27;string-output-port-values)
 (close
   (0 0 . core.io\x27;open-string-output-port)
   (subr.gloc.of \x2E;make-string-output-port 0)
   (push)
   (apply.gloc.of core.io\x27;string-output-port-values "../stdlib/core/io.scm" . 534535))
 (set.gloc.of core.io\x27;open-string-output-port)
 (close
   (5 0 . core.io\x27;make-custom-binary-output-port)
   (push.const . make-custom-binary-output-port)
   (push.const . 3)
   (push.const . 2)
   (push.iloc.0 . 0)
   (push.const . #f)
   (push.const . #f)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.iloc.0 . 4)
   (push.subr.gloc.of \x2E;vector 6 "../stdlib/core/io.scm" . 542738)
   (push.const . #f)
   (push.const . #f)
   (ret.subr.gloc.of \x2E;open-port "../stdlib/core/io.scm" . 538631))
 (set.gloc.of core.io\x27;make-custom-binary-output-port)
 (close
   (5 0 . core.io\x27;make-custom-textual-output-port)
   (extend.unbound . 4)
   (push.close
     (3 0 . bv-write!)
     (=n.iloc (0 . 2) 0 "../stdlib/core/io.scm" . 554002)
     (if.true
       (call
         (push.const . "")
         (push.const . 0)
         (push.const . 0)
         (apply.iloc (2 . 1) "../stdlib/core/io.scm" . 554014))
       (ret.const . 0))
     (push.iloc.0 . 2)
     (push.subr.gloc.of \x2E;make-bytevector 1 "../stdlib/core/io.scm" . 556065)
     (extend . 1)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.iloc.1 . 2)
     (subr.gloc.of \x2E;bytevector-copy! 5 "../stdlib/core/io.scm" . 557076)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;utf8->string 1 "../stdlib/core/io.scm" . 558112)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . 0)
     (call
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;string-length 1 "../stdlib/core/io.scm" . 559136)
       (apply.iloc (4 . 1) "../stdlib/core/io.scm" . 560165))
     (push)
     (push.subr.gloc.of \x2E;substring 3 "../stdlib/core/io.scm" . 561209)
     (push.subr.gloc.of \x2E;string->utf8 1 "../stdlib/core/io.scm" . 561195)
     (ret.subr.gloc.of \x2E;bytevector-length "../stdlib/core/io.scm" . 561176))
   (push.close
     (1 0 . bv-get-position)
     (push.iloc.1 . 3)
     (push.iloc.0 . 0)
     (call (apply.iloc (2 . 2) "../stdlib/core/io.scm" . 565295))
     (push)
     (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/io.scm" . 565259)
     (ret.iloc 0 . 0))
   (push.close
     (1 0 . bv-set-position!)
     (push.iloc.1 . 3)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/io.scm" . 570386)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (apply.iloc (3 . 3) "../stdlib/core/io.scm" . 571427))
     (subr.gloc.of \x2E;warning-level 0 "../stdlib/core/io.scm" . 572434)
     (if.true
       (subr.gloc.of \x2E;current-error-port 0)
       (push)
       (push.const
         .
         "~&warning in set-port-position: expected return value of a call to get-position, but got ~u~%~!")
       (push.iloc.1 . 0)
       (subr.gloc.of \x2E;format 3 "../stdlib/core/io.scm" . 573458)
       (push.iloc.1 . 0)
       (apply.iloc (3 . 3) "../stdlib/core/io.scm" . 574482))
     (push.iloc.1 . 0)
     (apply.iloc (3 . 3) "../stdlib/core/io.scm" . 576530))
   (enclose . 3)
   (push.const . eqv?)
   (subr.gloc.of \x2E;make-core-hashtable 1 "../stdlib/core/io.scm" . 549912)
   (set.iloc (0 . 3))
   (push.const . make-custom-textual-output-port)
   (push.const . 3)
   (push.const . 2)
   (push.iloc.1 . 0)
   (push.const . #t)
   (push.const . #f)
   (call (iloc.1 . 1) (if.false.ret) (ret.iloc 0 . 0))
   (push)
   (call (iloc.1 . 2) (if.false.ret) (ret.iloc 0 . 1))
   (push)
   (call (iloc.1 . 3) (if.false.ret) (ret.iloc 0 . 2))
   (push)
   (push.iloc.1 . 4)
   (push.subr.gloc.of \x2E;vector 6 "../stdlib/core/io.scm" . 582674)
   (push.const . #f)
   (push.const . #t)
   (ret.subr.gloc.of \x2E;open-port "../stdlib/core/io.scm" . 578567))
 (set.gloc.of core.io\x27;make-custom-textual-output-port)
 (close
   (1 1 . core.io\x27;open-file-input/output-port)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;length 1 (\x2E;length options\x60;1664*))
   (push.const . 3)
   (subr.gloc.of \x2E;<= 2 (\x2E;<= (\x2E;length options\x60;1664*) 3))
   (if.false.call
     (push.const . open-file-input/output-port)
     (push.const . "expected ~a to ~a, but ~a arguments given")
     (push.const . 1)
     (push.const . 4)
     (push.const . 1)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;length 1 (\x2E;length options\x60;1664*))
     (push.subr.gloc.of \x2E;+ 2 (\x2E;+ 1 (\x2E;length options\x60;1664*)))
     (push.subr.gloc.of
       \x2E;format
       4
       (\x2E;format
         "expected ~a to ~a, but ~a arguments given"
         1
         4
         (\x2E;+ 1 (\x2E;length options\x60;1664*))))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;cons* 2 (\x2E;cons* filename\x60;1664* options\x60;1664*))
     (apply.gloc.of
       \x2E;assertion-violation
       (\x2E;assertion-violation
         'open-file-input/output-port
         (\x2E;format
           "expected ~a to ~a, but ~a arguments given"
           1
           4
           (\x2E;+ 1 (\x2E;length options\x60;1664*)))
         (\x2E;cons* filename\x60;1664* options\x60;1664*))))
   (push.close
     (3 0)
     (call (push.iloc.1 . 0) (apply.gloc.of \x2E;track-file-open "../stdlib/core/io.scm" . 594953))
     (push.const . open-file-input/output-port)
     (push.const . 1)
     (push.const . 3)
     (push.iloc.1 . 0)
     (call
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.subr.gloc.of \x2E;tuple-ref 2 "../stdlib/core/io.scm" . 600145)
       (const . type:enum-set)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 0)
       (call
         (call
           (push.const)
           (apply.gloc.of
             core.io.assistants\x27;make-file-options
             "../stdlib/core/io.scm"
             .
             600145))
         (push)
         (apply.gloc.of core.enums\x27;enum-set-universe "../stdlib/core/io.scm" . 600145))
       (push)
       (apply.gloc.of core.enums\x27;enum-set-subset? "../stdlib/core/io.scm" . 600145))
     (if.false.call
       (push.const . open-file-input/output-port)
       (push.const . "expected file-options object, but got ~r, as argument 2")
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/io.scm" . 600145)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of \x2E;cons* 2 "../stdlib/core/io.scm" . 600145)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/io.scm" . 600145))
     (call
       (push.gloc.of \x2E;+)
       (call
         (push.gloc.of \x2E;L549)
         (call
           (push.iloc.0 . 0)
           (apply.gloc.of core.enums\x27;enum-set->list "../stdlib/core/io.scm" . 600145))
         (push)
         (apply.gloc.of \x2E;map "../stdlib/core/io.scm" . 600145))
       (push)
       (apply.gloc.of \x2E;apply "../stdlib/core/io.scm" . 600145))
     (push)
     (call
       (push.iloc.0 . 1)
       (apply.gloc.of
         core.io.assistants\x27;port-lookup-buffer-mode-code
         "../stdlib/core/io.scm"
         .
         601108))
     (push)
     (call
       (iloc.0 . 2)
       (if.false.ret)
       (push.const . open-file-input/output-port)
       (push.const . 4)
       (push.iloc.0 . 2)
       (apply.gloc.of core.io\x27;transcoder-descriptor "../stdlib/core/io.scm" . 602148))
     (push)
     (ret.subr.gloc.of \x2E;open-port "../stdlib/core/io.scm" . 595977))
   (call
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;length 1 "../stdlib/core/io.scm" . 591917)
     (extend . 1)
     (=n.iloc (0 . 0) 3 "../stdlib/core/io.scm" . 591917)
     (if.true (ret.iloc 1 . 1))
     (=n.iloc (0 . 0) 2 (\x2E;= argc\x60;1667\x60;1677* 2))
     (if.true
       (push.iloc.1 . 1)
       (push.const . #f)
       (push.subr.gloc.of \x2E;list 1 (\x2E;list #f))
       (ret.subr.gloc.of \x2E;append (\x2E;append options\x60;1664* (\x2E;list #f))))
     (=n.iloc (0 . 0) 1 "../stdlib/core/io.scm" . 591917)
     (if.true
       (push.iloc.1 . 1)
       (push.const . block)
       (push.const . #f)
       (push.subr.gloc.of \x2E;list 2 (\x2E;list 'block #f))
       (ret.subr.gloc.of \x2E;append (\x2E;append options\x60;1664* (\x2E;list 'block #f))))
     (call
       (push.const)
       (apply.gloc.of core.io.assistants\x27;make-file-options "../stdlib/core/io.scm" . 591917))
     (push)
     (push.const . block)
     (push.const . #f)
     (ret.subr.gloc.of
       \x2E;list
       (\x2E;list (core.io.assistants\x27;make-file-options '()) 'block #f)))
   (push)
   (apply.gloc.of
     \x2E;apply
     (\x2E;apply
       (lambda (file-options\x60;1668* buffer-mode\x60;1668* transcoder\x60;1668*)
         (\x2E;track-file-open filename\x60;1664*)
         (\x2E;open-port
           'open-file-input/output-port
           1
           3
           filename\x60;1664*
           (begin
             (or (and (\x2E;eq? (\x2E;tuple-ref file-options\x60;1668* 0) 'type:enum-set)
                      (core.enums\x27;enum-set-subset?
                        file-options\x60;1668*
                        (core.enums\x27;enum-set-universe
                          (core.io.assistants\x27;make-file-options '()))))
                 (\x2E;assertion-violation
                   'open-file-input/output-port
                   (\x2E;format
                     "expected file-options object, but got ~r, as argument 2"
                     file-options\x60;1668*)
                   (\x2E;cons* filename\x60;1664* options\x60;1664*)))
             (\x2E;apply
               \x2E;+
               (\x2E;map \x2E;L549 (core.enums\x27;enum-set->list file-options\x60;1668*))))
           (core.io.assistants\x27;port-lookup-buffer-mode-code buffer-mode\x60;1668*)
           (and transcoder\x60;1668*
                (core.io\x27;transcoder-descriptor
                  'open-file-input/output-port
                  4
                  transcoder\x60;1668*))))
       (let ((argc\x60;1667\x60;1677* (\x2E;length options\x60;1664*)))
         (if (\x2E;= argc\x60;1667\x60;1677* 3)
             options\x60;1664*
             (if (\x2E;= argc\x60;1667\x60;1677* 2)
                 (\x2E;append options\x60;1664* (\x2E;list #f))
                 (if (\x2E;= argc\x60;1667\x60;1677* 1)
                     (\x2E;append options\x60;1664* (\x2E;list 'block #f))
                     (\x2E;list (core.io.assistants\x27;make-file-options '()) 'block #f))))))))
 (set.gloc.of core.io\x27;open-file-input/output-port)
 (close
   (6 0 . core.io\x27;make-custom-binary-input/output-port)
   (push.const . make-custom-binary-input/output-port)
   (push.const . 3)
   (push.const . 3)
   (push.iloc.0 . 0)
   (push.const . #f)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.iloc.0 . 4)
   (push.iloc.0 . 5)
   (push.subr.gloc.of \x2E;vector 6 "../stdlib/core/io.scm" . 610322)
   (push.const . #f)
   (push.const . #f)
   (ret.subr.gloc.of \x2E;open-port "../stdlib/core/io.scm" . 606215))
 (set.gloc.of core.io\x27;make-custom-binary-input/output-port)
 (close
   (6 0 . core.io\x27;make-custom-textual-input/output-port)
   (extend.unbound . 5)
   (push.close
     (3 0 . bv-read!)
     (=n.iloc (0 . 2) 0 "../stdlib/core/io.scm" . 621586)
     (if.true.ret.const . 0)
     (push.iloc.0 . 2)
     (push.const . 4)
     (push.subr.gloc.of \x2E;div 2 "../stdlib/core/io.scm" . 623646)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . #\nul)
     (push.subr.gloc.of \x2E;make-string 2 "../stdlib/core/io.scm" . 624670)
     (extend . 1)
     (call
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.iloc.1 . 0)
       (apply.iloc (4 . 1) "../stdlib/core/io.scm" . 625696))
     (push)
     (extend . 1)
     (=n.iloc (0 . 0) 0 "../stdlib/core/io.scm" . 626715)
     (if.true.ret.const . 0)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;substring 3 "../stdlib/core/io.scm" . 628793)
     (push.subr.gloc.of \x2E;string->utf8 1 "../stdlib/core/io.scm" . 628779)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;bytevector-length 1 "../stdlib/core/io.scm" . 629801)
     (extend . 1)
     (push.iloc.1 . 0)
     (push.const . 0)
     (push.iloc 5 . 0)
     (push.iloc 5 . 1)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;bytevector-copy! 5 "../stdlib/core/io.scm" . 630813)
     (ret.iloc 0 . 0))
   (push.close
     (3 0 . bv-write!)
     (=n.iloc (0 . 2) 0 "../stdlib/core/io.scm" . 635922)
     (if.true
       (call
         (push.const . "")
         (push.const . 0)
         (push.const . 0)
         (apply.iloc (2 . 2) "../stdlib/core/io.scm" . 635934))
       (ret.const . 0))
     (push.iloc.0 . 2)
     (push.subr.gloc.of \x2E;make-bytevector 1 "../stdlib/core/io.scm" . 637985)
     (extend . 1)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.iloc.1 . 2)
     (subr.gloc.of \x2E;bytevector-copy! 5 "../stdlib/core/io.scm" . 638996)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;utf8->string 1 "../stdlib/core/io.scm" . 640032)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const . 0)
     (call
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;string-length 1 "../stdlib/core/io.scm" . 641056)
       (apply.iloc (4 . 2) "../stdlib/core/io.scm" . 642085))
     (push)
     (push.subr.gloc.of \x2E;substring 3 "../stdlib/core/io.scm" . 643129)
     (push.subr.gloc.of \x2E;string->utf8 1 "../stdlib/core/io.scm" . 643115)
     (ret.subr.gloc.of \x2E;bytevector-length "../stdlib/core/io.scm" . 643096))
   (push.close
     (1 0 . bv-get-position)
     (push.iloc.1 . 4)
     (push.iloc.0 . 0)
     (call (apply.iloc (2 . 3) "../stdlib/core/io.scm" . 647215))
     (push)
     (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/io.scm" . 647179)
     (ret.iloc 0 . 0))
   (push.close
     (1 0 . bv-set-position!)
     (push.iloc.1 . 4)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/io.scm" . 652306)
     (extend . 1)
     (iloc.0 . 0)
     (if.true (push.iloc.0 . 0) (apply.iloc (3 . 4) "../stdlib/core/io.scm" . 653347))
     (subr.gloc.of \x2E;warning-level 0 "../stdlib/core/io.scm" . 654354)
     (if.true
       (subr.gloc.of \x2E;current-error-port 0)
       (push)
       (push.const
         .
         "~&warning in set-port-position: expected return value of a call to get-position, but got ~u~%~!")
       (push.iloc.1 . 0)
       (subr.gloc.of \x2E;format 3 "../stdlib/core/io.scm" . 655378)
       (push.iloc.1 . 0)
       (apply.iloc (3 . 4) "../stdlib/core/io.scm" . 656402))
     (push.iloc.1 . 0)
     (apply.iloc (3 . 4) "../stdlib/core/io.scm" . 658450))
   (enclose . 4)
   (push.const . eqv?)
   (subr.gloc.of \x2E;make-core-hashtable 1 "../stdlib/core/io.scm" . 617496)
   (set.iloc (0 . 4))
   (push.const . make-custom-textual-input/output-port)
   (push.const . 3)
   (push.const . 3)
   (push.iloc.1 . 0)
   (push.const . #t)
   (call (iloc.1 . 1) (if.false.ret) (ret.iloc 0 . 0))
   (push)
   (call (iloc.1 . 2) (if.false.ret) (ret.iloc 0 . 1))
   (push)
   (call (iloc.1 . 3) (if.false.ret) (ret.iloc 0 . 2))
   (push)
   (call (iloc.1 . 4) (if.false.ret) (ret.iloc 0 . 3))
   (push)
   (push.iloc.1 . 5)
   (push.subr.gloc.of \x2E;vector 6 "../stdlib/core/io.scm" . 664594)
   (push.const . #f)
   (push.const . #t)
   (ret.subr.gloc.of \x2E;open-port "../stdlib/core/io.scm" . 660487))
 (set.gloc.of core.io\x27;make-custom-textual-input/output-port)
 (close
   (2 0 . core.io\x27;call-with-input-file)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.io\x27;open-input-file "../stdlib/core/io.scm" . 672791))
   (push)
   (push.iloc.0 . 1)
   (apply.gloc.of \x2E;call-with-port "../stdlib/core/io.scm" . 672775))
 (set.gloc.of core.io\x27;call-with-input-file)
 (close
   (2 0 . core.io\x27;call-with-output-file)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.io\x27;open-output-file "../stdlib/core/io.scm" . 676887))
   (push)
   (push.iloc.0 . 1)
   (apply.gloc.of \x2E;call-with-port "../stdlib/core/io.scm" . 676871))
 (set.gloc.of core.io\x27;call-with-output-file)
 (close
   (2 0 . core.io\x27;with-input-from-file)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.io\x27;open-input-file "../stdlib/core/io.scm" . 680979))
   (push)
   (subr.gloc.of \x2E;current-input-port 0)
   (push)
   (extend . 2)
   (push.close
     (0 0)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of \x2E;set-current-input-port! "../stdlib/core/io.scm" . 683029))
   (push.close
     (0 0)
     (call (apply.iloc (2 . 1) "../stdlib/core/io.scm" . 684064))
     (push)
     (extend . 1)
     (call
       (push.iloc 2 . 0)
       (apply.gloc.of core.io\x27;close-input-port "../stdlib/core/io.scm" . 684074))
     (ret.iloc 0 . 0))
   (push.close
     (0 0)
     (push.iloc.1 . 1)
     (ret.subr.gloc.of \x2E;set-current-input-port! "../stdlib/core/io.scm" . 685077))
   (apply.gloc.of \x2E;dynamic-wind "../stdlib/core/io.scm" . 681993))
 (set.gloc.of core.io\x27;with-input-from-file)
 (close
   (2 0 . core.io\x27;with-output-to-file)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.io\x27;open-output-file "../stdlib/core/io.scm" . 689171))
   (push)
   (subr.gloc.of \x2E;current-output-port 0)
   (push)
   (extend . 2)
   (push.close
     (0 0)
     (push.iloc.1 . 0)
     (ret.subr.gloc.of \x2E;set-current-output-port! "../stdlib/core/io.scm" . 691221))
   (push.close
     (0 0)
     (call (apply.iloc (2 . 1) "../stdlib/core/io.scm" . 692256))
     (push)
     (extend . 1)
     (call
       (push.iloc 2 . 0)
       (apply.gloc.of core.io\x27;close-output-port "../stdlib/core/io.scm" . 692266))
     (ret.iloc 0 . 0))
   (push.close
     (0 0)
     (push.iloc.1 . 1)
     (ret.subr.gloc.of \x2E;set-current-output-port! "../stdlib/core/io.scm" . 693269))
   (apply.gloc.of \x2E;dynamic-wind "../stdlib/core/io.scm" . 690185))
 (set.gloc.of core.io\x27;with-output-to-file)
 (close
   (1 0 . core.io\x27;open-input-file)
   (push.iloc.0 . 0)
   (call
     (push.const)
     (apply.gloc.of core.io.assistants\x27;make-file-options "../stdlib/core/io.scm" . 697382))
   (push)
   (push.const . block)
   (call (apply.gloc.of core.io\x27;native-transcoder "../stdlib/core/io.scm" . 697417))
   (push)
   (apply.gloc.of core.io\x27;open-file-input-port "../stdlib/core/io.scm" . 697351))
 (set.gloc.of core.io\x27;open-input-file)
 (close
   (1 0 . core.io\x27;open-output-file)
   (push.iloc.0 . 0)
   (call
     (push.const)
     (apply.gloc.of core.io.assistants\x27;make-file-options "../stdlib/core/io.scm" . 701479))
   (push)
   (push.const . block)
   (call (apply.gloc.of core.io\x27;native-transcoder "../stdlib/core/io.scm" . 701514))
   (push)
   (apply.gloc.of core.io\x27;open-file-output-port "../stdlib/core/io.scm" . 701447))
 (set.gloc.of core.io\x27;open-output-file)
 (close
   (1 0 . core.io\x27;close-input-port)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;close-port "../stdlib/core/io.scm" . 705543))
 (set.gloc.of core.io\x27;close-input-port)
 (close
   (1 0 . core.io\x27;close-output-port)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;close-port "../stdlib/core/io.scm" . 709639))
 (set.gloc.of core.io\x27;close-output-port)
 (close
   (0 1 . core.io\x27;open-temporary-file-port)
   (push.gloc.of \x2E;L536)
   (call
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;length 1 "../stdlib/core/io.scm" . 715783)
     (extend . 1)
     (=n.iloc (0 . 0) 2 "../stdlib/core/io.scm" . 715783)
     (if.true (ret.iloc 1 . 0))
     (=n.iloc (0 . 0) 1 "../stdlib/core/io.scm" . 715783)
     (if.true
       (push.iloc.1 . 0)
       (push.const . #f)
       (push.subr.gloc.of \x2E;list 1 (\x2E;list #f))
       (ret.subr.gloc.of \x2E;append (\x2E;append options\x60;1770* (\x2E;list #f))))
     (push.const . "temporary file")
     (push.const . #f)
     (ret.subr.gloc.of \x2E;list (\x2E;list "temporary file" #f)))
   (push)
   (apply.gloc.of
     \x2E;apply
     (\x2E;apply
       \x2E;L536
       (let ((argc\x60;1772\x60;1775* (\x2E;length options\x60;1770*)))
         (if (\x2E;= argc\x60;1772\x60;1775* 2)
             options\x60;1770*
             (if (\x2E;= argc\x60;1772\x60;1775* 1)
                 (\x2E;append options\x60;1770* (\x2E;list #f))
                 (\x2E;list "temporary file" #f)))))))
 (set.gloc.of core.io\x27;open-temporary-file-port)
 (call
   (push.const
     (map import . \x2E;map)
     (length import . \x2E;length)
     (options unbound)
     (quote import . \x2E;quote)
     (who unbound)
     (_ import . \x2E;_)
     (lambda import . \x2E;lambda)
     (or import . \x2E;or)
     (eol-style import . core.io\x27;eol-style)
     (<= import . \x2E;<=)
     (n-limit unbound)
     (core.lists\x27;list-of-unique-symbols? unbound)
     (style unbound)
     (x unbound)
     (args unbound)
     (core.lists\x27;for-all unbound)
     (assertion-violation import . \x2E;assertion-violation)
     (n-options unbound)
     (make-file-options import . core.io.assistants\x27;make-file-options)
     (enum-set-subset? import . core.enums\x27;enum-set-subset?)
     (buffer-mode import . core.io\x27;buffer-mode)
     (begin import . \x2E;begin)
     (cons* import . \x2E;cons*)
     (core.io.assistants\x27;port-lookup-error-handling-mode-code unbound)
     (enum-set? import . core.enums\x27;enum-set?)
     (core.io.assistants\x27;port-lookup-file-option-code unbound)
     (error-handling-mode import . core.io\x27;error-handling-mode)
     (enum-set-universe import . core.enums\x27;enum-set-universe)
     (file-options import . core.io\x27;file-options)
     (... import . \x2E;...)
     (core.io.assistants\x27;port-lookup-buffer-mode-code unbound)
     (and import . \x2E;and)
     (datum import . core.syntax-case\x27;datum)
     (file-options->bits import . core.io\x27;file-options->bits)
     (check-option-count import . core.io\x27;check-option-count)
     (name unbound)
     (apply import . \x2E;apply)
     (e unbound)
     (n-args unbound)
     (let import . \x2E;let)
     (format import . \x2E;format)
     (mode unbound)
     (+ import . \x2E;+)
     (core.io.assistants\x27;port-lookup-eol-style-code unbound)
     (enum-set->list import . core.enums\x27;enum-set->list)
     (port-lookup-file-option-code import . core.io.assistants\x27;port-lookup-file-option-code)
     (with-syntax import . core.syntax-case\x27;with-syntax))
   (extend . 1)
   (call
     (push.const . syntax)
     (push.const . core.io\x27;check-option-count)
     (call
       (push.gloc.of \x2E;L588)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/io.scm" . 223237))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/io.scm" . 223237))
   (call
     (push.const . syntax)
     (push.const . core.io\x27;file-options)
     (call
       (push.gloc.of \x2E;L591)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/io.scm" . 223237))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/io.scm" . 223237))
   (call
     (push.const . syntax)
     (push.const . core.io\x27;file-options->bits)
     (push.const
       ()
       ("../stdlib/core/io.scm" . 246789)
       ((_ x who args)
        (begin
          (or (and (enum-set? x) (enum-set-subset? x (enum-set-universe (file-options))))
              (assertion-violation
                'who
                (format "expected file-options object, but got ~r, as argument 2" x)
                args))
          (apply + (map (lambda (e) (port-lookup-file-option-code e)) (enum-set->list x))))
        ((args . 0) (who . 0) (x . 0))
        (enum-set->list
          port-lookup-file-option-code
          e
          lambda
          map
          +
          apply
          format
          quote
          assertion-violation
          file-options
          enum-set-universe
          enum-set-subset?
          enum-set?
          and
          or
          begin)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/io.scm" . 223237))
   (call
     (push.const . syntax)
     (push.const . core.io\x27;buffer-mode)
     (call
       (push.gloc.of \x2E;L535)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/io.scm" . 223237))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/io.scm" . 223237))
   (call
     (push.const . syntax)
     (push.const . core.io\x27;eol-style)
     (call
       (push.gloc.of \x2E;L545)
       (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/io.scm" . 223237))
     (push)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/io.scm" . 223237))
   (push.const . syntax)
   (push.const . core.io\x27;error-handling-mode)
   (call
     (push.gloc.of \x2E;L568)
     (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/io.scm" . 223237))
   (push)
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/io.scm" . 223237))
 (push.const . core.io)
 (push.const . #f)
 (push.const
   (file-options import . core.io\x27;file-options)
   (buffer-mode import . core.io\x27;buffer-mode)
   (buffer-mode? import . core.io\x27;buffer-mode?)
   (utf-8-codec import . core.io\x27;utf-8-codec)
   (utf-16-codec import . core.io\x27;utf-16-codec)
   (latin-1-codec import . core.io\x27;latin-1-codec)
   (eol-style import . core.io\x27;eol-style)
   (error-handling-mode import . core.io\x27;error-handling-mode)
   (make-transcoder import . core.io\x27;make-transcoder)
   (transcoder-codec import . core.io\x27;transcoder-codec)
   (transcoder-eol-style import . core.io\x27;transcoder-eol-style)
   (transcoder-error-handling-mode import . core.io\x27;transcoder-error-handling-mode)
   (native-transcoder import . core.io\x27;native-transcoder)
   (native-eol-style import . core.io\x27;native-eol-style)
   (bytevector->string import . core.io\x27;bytevector->string)
   (string->bytevector import . core.io\x27;string->bytevector)
   (eof-object import . \x2E;eof-object)
   (eof-object? import . \x2E;eof-object?)
   (port? import . \x2E;port?)
   (port-transcoder import . core.io\x27;port-transcoder)
   (textual-port? import . core.io\x27;textual-port?)
   (binary-port? import . core.io\x27;binary-port?)
   (transcoded-port import . core.io\x27;transcoded-port)
   (port-has-port-position? import . \x2E;port-has-port-position?)
   (port-position import . \x2E;port-position)
   (port-has-set-port-position!? import . \x2E;port-has-set-port-position!?)
   (set-port-position! import . \x2E;set-port-position!)
   (close-port import . \x2E;close-port)
   (call-with-port import . \x2E;call-with-port)
   (input-port? import . \x2E;input-port?)
   (port-eof? import . \x2E;port-eof?)
   (open-file-input-port import . core.io\x27;open-file-input-port)
   (open-bytevector-input-port import . core.io\x27;open-bytevector-input-port)
   (open-string-input-port import . core.io\x27;open-string-input-port)
   (standard-input-port import . \x2E;standard-input-port)
   (current-input-port import . \x2E;current-input-port)
   (get-u8 import . \x2E;get-u8)
   (lookahead-u8 import . \x2E;lookahead-u8)
   (get-bytevector-n import . \x2E;get-bytevector-n)
   (get-bytevector-n! import . \x2E;get-bytevector-n!)
   (get-bytevector-some import . \x2E;get-bytevector-some)
   (get-bytevector-all import . \x2E;get-bytevector-all)
   (get-char import . \x2E;get-char)
   (lookahead-char import . \x2E;lookahead-char)
   (get-string-n import . \x2E;get-string-n)
   (get-string-n! import . \x2E;get-string-n!)
   (get-string-all import . \x2E;get-string-all)
   (get-line import . \x2E;get-line)
   (get-datum import . \x2E;get-datum)
   (output-port? import . \x2E;output-port?)
   (flush-output-port import . \x2E;flush-output-port)
   (output-port-buffer-mode import . \x2E;output-port-buffer-mode)
   (open-file-output-port import . core.io\x27;open-file-output-port)
   (open-bytevector-output-port import . core.io\x27;open-bytevector-output-port)
   (call-with-bytevector-output-port import . core.io\x27;call-with-bytevector-output-port)
   (open-string-output-port import . core.io\x27;open-string-output-port)
   (call-with-string-output-port import . core.io\x27;call-with-string-output-port)
   (standard-output-port import . \x2E;standard-output-port)
   (standard-error-port import . \x2E;standard-error-port)
   (current-output-port import . \x2E;current-output-port)
   (current-error-port import . \x2E;current-error-port)
   (put-u8 import . \x2E;put-u8)
   (put-bytevector import . \x2E;put-bytevector)
   (put-char import . \x2E;put-char)
   (put-string import . \x2E;put-string)
   (put-datum import . \x2E;put-datum)
   (open-file-input/output-port import . core.io\x27;open-file-input/output-port)
   (call-with-input-file import . core.io\x27;call-with-input-file)
   (call-with-output-file import . core.io\x27;call-with-output-file)
   (with-input-from-file import . core.io\x27;with-input-from-file)
   (with-output-to-file import . core.io\x27;with-output-to-file)
   (open-input-file import . core.io\x27;open-input-file)
   (open-output-file import . core.io\x27;open-output-file)
   (close-input-port import . core.io\x27;close-input-port)
   (close-output-port import . core.io\x27;close-output-port)
   (read-char import . \x2E;read-char)
   (peek-char import . \x2E;peek-char)
   (read import . \x2E;read)
   (write-char import . \x2E;write-char)
   (newline import . \x2E;newline)
   (display import . \x2E;display)
   (write import . \x2E;write)
   (make-custom-binary-input-port import . core.io\x27;make-custom-binary-input-port)
   (make-custom-textual-input-port import . core.io\x27;make-custom-textual-input-port)
   (make-custom-binary-output-port import . core.io\x27;make-custom-binary-output-port)
   (make-custom-textual-output-port import . core.io\x27;make-custom-textual-output-port)
   (make-custom-binary-input/output-port import . core.io\x27;make-custom-binary-input/output-port)
   (make-custom-textual-input/output-port
     import
     .
     core.io\x27;make-custom-textual-input/output-port)
   (&i/o import . \x2E;&i/o)
   (make-i/o-error import . \x2E;make-i/o-error)
   (i/o-error? import . \x2E;i/o-error?)
   (&i/o-read import . \x2E;&i/o-read)
   (make-i/o-read-error import . \x2E;make-i/o-read-error)
   (i/o-read-error? import . \x2E;i/o-read-error?)
   (&i/o-write import . \x2E;&i/o-write)
   (make-i/o-write-error import . \x2E;make-i/o-write-error)
   (i/o-write-error? import . \x2E;i/o-write-error?)
   (&i/o-invalid-position import . \x2E;&i/o-invalid-position)
   (make-i/o-invalid-position-error import . \x2E;make-i/o-invalid-position-error)
   (i/o-invalid-position-error? import . \x2E;i/o-invalid-position-error?)
   (i/o-error-position import . \x2E;i/o-error-position)
   (&i/o-filename import . \x2E;&i/o-filename)
   (make-i/o-filename-error import . \x2E;make-i/o-filename-error)
   (i/o-filename-error? import . \x2E;i/o-filename-error?)
   (i/o-error-filename import . \x2E;i/o-error-filename)
   (&i/o-file-protection import . \x2E;&i/o-file-protection)
   (make-i/o-file-protection-error import . \x2E;make-i/o-file-protection-error)
   (i/o-file-protection-error? import . \x2E;i/o-file-protection-error?)
   (&i/o-file-is-read-only import . \x2E;&i/o-file-is-read-only)
   (make-i/o-file-is-read-only-error import . \x2E;make-i/o-file-is-read-only-error)
   (i/o-file-is-read-only-error? import . \x2E;i/o-file-is-read-only-error?)
   (&i/o-file-already-exists import . \x2E;&i/o-file-already-exists)
   (make-i/o-file-already-exists-error import . \x2E;make-i/o-file-already-exists-error)
   (i/o-file-already-exists-error? import . \x2E;i/o-file-already-exists-error?)
   (&i/o-file-does-not-exist import . \x2E;&i/o-file-does-not-exist)
   (make-i/o-file-does-not-exist-error import . \x2E;make-i/o-file-does-not-exist-error)
   (i/o-file-does-not-exist-error? import . \x2E;i/o-file-does-not-exist-error?)
   (&i/o-port import . \x2E;&i/o-port)
   (make-i/o-port-error import . \x2E;make-i/o-port-error)
   (i/o-port-error? import . \x2E;i/o-port-error?)
   (i/o-error-port import . \x2E;i/o-error-port)
   (&i/o-decoding import . \x2E;&i/o-decoding)
   (make-i/o-decoding-error import . \x2E;make-i/o-decoding-error)
   (i/o-decoding-error? import . \x2E;i/o-decoding-error?)
   (&i/o-encoding import . \x2E;&i/o-encoding)
   (make-i/o-encoding-error import . \x2E;make-i/o-encoding-error)
   (i/o-encoding-error? import . \x2E;i/o-encoding-error?)
   (i/o-encoding-error-char import . \x2E;i/o-encoding-error-char)
   (open-temporary-file-port import . core.io\x27;open-temporary-file-port)
   (format import . \x2E;format))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/io.scm" . 226314))

((call
   (push.const core optargs)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core optargs))))
 (call
   (push.const core lists)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core lists))))
 (call
   (push.const core io)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core io))))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core primitives))))
 (push.const . core.files)
 (push.const . #f)
 (push.const
   (file-exists? import . \x2E;file-exists?)
   (delete-file import . \x2E;delete-file)
   (directory-list import . \x2E;directory-list)
   (current-directory import . \x2E;current-directory)
   (&i/o import . \x2E;&i/o)
   (make-i/o-error import . \x2E;make-i/o-error)
   (i/o-error? import . \x2E;i/o-error?)
   (&i/o-read import . \x2E;&i/o-read)
   (make-i/o-read-error import . \x2E;make-i/o-read-error)
   (i/o-read-error? import . \x2E;i/o-read-error?)
   (&i/o-write import . \x2E;&i/o-write)
   (make-i/o-write-error import . \x2E;make-i/o-write-error)
   (i/o-write-error? import . \x2E;i/o-write-error?)
   (&i/o-invalid-position import . \x2E;&i/o-invalid-position)
   (make-i/o-invalid-position-error import . \x2E;make-i/o-invalid-position-error)
   (i/o-invalid-position-error? import . \x2E;i/o-invalid-position-error?)
   (i/o-error-position import . \x2E;i/o-error-position)
   (&i/o-filename import . \x2E;&i/o-filename)
   (make-i/o-filename-error import . \x2E;make-i/o-filename-error)
   (i/o-filename-error? import . \x2E;i/o-filename-error?)
   (i/o-error-filename import . \x2E;i/o-error-filename)
   (&i/o-file-protection import . \x2E;&i/o-file-protection)
   (make-i/o-file-protection-error import . \x2E;make-i/o-file-protection-error)
   (i/o-file-protection-error? import . \x2E;i/o-file-protection-error?)
   (&i/o-file-is-read-only import . \x2E;&i/o-file-is-read-only)
   (make-i/o-file-is-read-only-error import . \x2E;make-i/o-file-is-read-only-error)
   (i/o-file-is-read-only-error? import . \x2E;i/o-file-is-read-only-error?)
   (&i/o-file-already-exists import . \x2E;&i/o-file-already-exists)
   (make-i/o-file-already-exists-error import . \x2E;make-i/o-file-already-exists-error)
   (i/o-file-already-exists-error? import . \x2E;i/o-file-already-exists-error?)
   (&i/o-file-does-not-exist import . \x2E;&i/o-file-does-not-exist)
   (make-i/o-file-does-not-exist-error import . \x2E;make-i/o-file-does-not-exist-error)
   (i/o-file-does-not-exist-error? import . \x2E;i/o-file-does-not-exist-error?)
   (&i/o-port import . \x2E;&i/o-port)
   (make-i/o-port-error import . \x2E;make-i/o-port-error)
   (i/o-port-error? import . \x2E;i/o-port-error?)
   (i/o-error-port import . \x2E;i/o-error-port))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'core.files
     #f
     '((file-exists? import . \x2E;file-exists?)
       (delete-file import . \x2E;delete-file)
       (directory-list import . \x2E;directory-list)
       (current-directory import . \x2E;current-directory)
       (&i/o import . \x2E;&i/o)
       (make-i/o-error import . \x2E;make-i/o-error)
       (i/o-error? import . \x2E;i/o-error?)
       (&i/o-read import . \x2E;&i/o-read)
       (make-i/o-read-error import . \x2E;make-i/o-read-error)
       (i/o-read-error? import . \x2E;i/o-read-error?)
       (&i/o-write import . \x2E;&i/o-write)
       (make-i/o-write-error import . \x2E;make-i/o-write-error)
       (i/o-write-error? import . \x2E;i/o-write-error?)
       (&i/o-invalid-position import . \x2E;&i/o-invalid-position)
       (make-i/o-invalid-position-error import . \x2E;make-i/o-invalid-position-error)
       (i/o-invalid-position-error? import . \x2E;i/o-invalid-position-error?)
       (i/o-error-position import . \x2E;i/o-error-position)
       (&i/o-filename import . \x2E;&i/o-filename)
       (make-i/o-filename-error import . \x2E;make-i/o-filename-error)
       (i/o-filename-error? import . \x2E;i/o-filename-error?)
       (i/o-error-filename import . \x2E;i/o-error-filename)
       (&i/o-file-protection import . \x2E;&i/o-file-protection)
       (make-i/o-file-protection-error import . \x2E;make-i/o-file-protection-error)
       (i/o-file-protection-error? import . \x2E;i/o-file-protection-error?)
       (&i/o-file-is-read-only import . \x2E;&i/o-file-is-read-only)
       (make-i/o-file-is-read-only-error import . \x2E;make-i/o-file-is-read-only-error)
       (i/o-file-is-read-only-error? import . \x2E;i/o-file-is-read-only-error?)
       (&i/o-file-already-exists import . \x2E;&i/o-file-already-exists)
       (make-i/o-file-already-exists-error import . \x2E;make-i/o-file-already-exists-error)
       (i/o-file-already-exists-error? import . \x2E;i/o-file-already-exists-error?)
       (&i/o-file-does-not-exist import . \x2E;&i/o-file-does-not-exist)
       (make-i/o-file-does-not-exist-error import . \x2E;make-i/o-file-does-not-exist-error)
       (i/o-file-does-not-exist-error? import . \x2E;i/o-file-does-not-exist-error?)
       (&i/o-port import . \x2E;&i/o-port)
       (make-i/o-port-error import . \x2E;make-i/o-port-error)
       (i/o-port-error? import . \x2E;i/o-port-error?)
       (i/o-error-port import . \x2E;i/o-error-port)))))

((close
   (0 0)
   (apply.gloc.of
     core.io\x27;open-bytevector-output-port
     "../stdlib/core/bytevector-transcoders.scm"
     .
     25646))
 (set.gloc.of \x2E;L661)
 (close
   (0 0)
   (apply.gloc.of
     core.io\x27;open-bytevector-output-port
     "../stdlib/core/bytevector-transcoders.scm"
     .
     100398))
 (set.gloc.of \x2E;L664)
 (call
   (push.const core bytevectors)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/bytevector-transcoders.scm" . 25646))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/bytevector-transcoders.scm" . 25646))
 (call
   (push.const core io)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/bytevector-transcoders.scm" . 25646))
 (call
   (push.const core optargs)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/bytevector-transcoders.scm" . 25646))
 (call
   (push.const core intrinsics)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/bytevector-transcoders.scm" . 25646))
 (close
   (1 1 . core.bytevector-transcoders\x27;string->utf32)
   (call
     (iloc.0 . 1)
     (if.pair?
       (push.iloc.0 . 1)
       (ret.subr.gloc.of \x2E;car "../stdlib/core/bytevector-transcoders.scm" . 20515))
     (ret.const . big))
   (push)
   (extend . 1)
   (push.iloc.1 . 0)
   (push.subr.gloc.of \x2E;string-length 1 "../stdlib/core/bytevector-transcoders.scm" . 21520)
   (push.const . 0)
   (subr.gloc.of \x2E;= 2 "../stdlib/core/bytevector-transcoders.scm" . 21517)
   (if.true.ret.const . #vu8())
   (push.iloc.1 . 0)
   (push.subr.gloc.of
     \x2E;make-string-input-port
     1
     "../stdlib/core/bytevector-transcoders.scm"
     .
     23578)
   (push.const . 4)
   (push.subr.gloc.of \x2E;make-bytevector 1 "../stdlib/core/bytevector-transcoders.scm" . 24600)
   (extend . 2)
   (push.gloc.of \x2E;L661)
   (push.close
     (2 0)
     (extend.enclose+
       (1 0 . loop)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;eof-object? 1 "../stdlib/core/bytevector-transcoders.scm" . 27674)
       (if.true (apply.iloc (2 . 1) "../stdlib/core/bytevector-transcoders.scm" . 27691))
       (push.iloc 3 . 1)
       (push.const . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/bytevector-transcoders.scm" . 29749)
       (push.iloc 4 . 0)
       (subr.gloc.of \x2E;bytevector-u32-set! 4 "../stdlib/core/bytevector-transcoders.scm" . 29722)
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (subr.gloc.of \x2E;put-bytevector 2 "../stdlib/core/bytevector-transcoders.scm" . 30746)
       (push.iloc 3 . 0)
       (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/bytevector-transcoders.scm" . 31776)
       (apply.iloc+ (1 . 0) "../stdlib/core/bytevector-transcoders.scm" . 31770))
     (push.iloc 2 . 0)
     (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/bytevector-transcoders.scm" . 26656)
     (apply.iloc+ (0 . 0) "../stdlib/core/bytevector-transcoders.scm" . 27667))
   (apply.gloc.of
     \x2E;call-with-values
     (\x2E;call-with-values
       \x2E;L661
       (lambda (output\x60;1790* extract\x60;1790*)
         (letrec* ((loop\x60;1794*
                     (lambda (ch\x60;1795*)
                       (if (\x2E;eof-object? ch\x60;1795*)
                           (extract\x60;1790*)
                           (begin
                             (\x2E;bytevector-u32-set!
                               buf\x60;1788*
                               0
                               (\x2E;char->integer ch\x60;1795*)
                               endian\x60;1786*)
                             (\x2E;put-bytevector output\x60;1790* buf\x60;1788*)
                             (loop\x60;1794* (\x2E;get-char input\x60;1788*)))))))
           (loop\x60;1794* (\x2E;get-char input\x60;1788*)))))))
 (set.gloc.of core.bytevector-transcoders\x27;string->utf32)
 (close
   (1 0 . core.bytevector-transcoders\x27;test-utf32-bom)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;bytevector-length 1 "../stdlib/core/bytevector-transcoders.scm" . 35856)
   (push.const . 4)
   (subr.gloc.of \x2E;>= 2 "../stdlib/core/bytevector-transcoders.scm" . 35852)
   (if.false.ret)
   (push.const . 4)
   (push.subr.gloc.of \x2E;make-bytevector 1 "../stdlib/core/bytevector-transcoders.scm" . 36887)
   (extend . 1)
   (push.iloc.1 . 0)
   (push.const . 0)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.const . 4)
   (subr.gloc.of \x2E;bytevector-copy! 5 "../stdlib/core/bytevector-transcoders.scm" . 37902)
   (push.iloc.0 . 0)
   (push.const . #vu8(0 0 254 255))
   (subr.gloc.of \x2E;equal? 2 "../stdlib/core/bytevector-transcoders.scm" . 38933)
   (if.true.ret.const . big)
   (push.iloc.0 . 0)
   (push.const . #vu8(255 254 0 0))
   (subr.gloc.of \x2E;equal? 2 "../stdlib/core/bytevector-transcoders.scm" . 39957)
   (if.false.ret)
   (ret.const . little))
 (set.gloc.of core.bytevector-transcoders\x27;test-utf32-bom)
 (close
   (4 0 . core.bytevector-transcoders\x27;transcode-utf32->string)
   (subr.gloc.of \x2E;make-string-output-port 0)
   (push)
   (extend . 1)
   (extend.enclose+
     (2 0 . loop)
     (=n.iloc (0 . 1) 0 "../stdlib/core/bytevector-transcoders.scm" . 47122)
     (if.true
       (push.iloc 2 . 0)
       (ret.subr.gloc.of
         \x2E;extract-accumulated-string
         "../stdlib/core/bytevector-transcoders.scm"
         .
         47133))
     (>=n.iloc (0 . 1) 4 "../stdlib/core/bytevector-transcoders.scm" . 48146)
     (if.true
       (call
         (push.iloc 3 . 2)
         (push.iloc.0 . 0)
         (push.iloc 3 . 3)
         (push.subr.gloc.of
           \x2E;bytevector-u32-ref
           3
           "../stdlib/core/bytevector-transcoders.scm"
           .
           49180)
         (extend . 1)
         (>n.iloc (0 . 0) 1114111 "../stdlib/core/bytevector-transcoders.scm" . 50203)
         (if.true
           (push.iloc 3 . 0)
           (push.const . #\)
           (ret.subr.gloc.of \x2E;put-char "../stdlib/core/bytevector-transcoders.scm" . 50219))
         (push.const . 55296)
         (push.iloc.0 . 0)
         (push.const . 57343)
         (subr.gloc.of \x2E;<= 3 "../stdlib/core/bytevector-transcoders.scm" . 51227)
         (if.true
           (push.iloc 3 . 0)
           (push.const . #\)
           (ret.subr.gloc.of \x2E;put-char "../stdlib/core/bytevector-transcoders.scm" . 51249))
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of
           \x2E;integer->char
           1
           "../stdlib/core/bytevector-transcoders.scm"
           .
           52273)
         (ret.subr.gloc.of \x2E;put-char "../stdlib/core/bytevector-transcoders.scm" . 52256))
       (push.n+.iloc (0 . 0) 4 "../stdlib/core/bytevector-transcoders.scm" . 53272)
       (push.n+.iloc (0 . 1) -4 "../stdlib/core/bytevector-transcoders.scm" . 53280)
       (apply.iloc+ (1 . 0) "../stdlib/core/bytevector-transcoders.scm" . 53266))
     (push.iloc 2 . 0)
     (push.const . #\)
     (subr.gloc.of \x2E;put-char 2 "../stdlib/core/bytevector-transcoders.scm" . 55314)
     (push.iloc 2 . 0)
     (ret.subr.gloc.of
       \x2E;extract-accumulated-string
       "../stdlib/core/bytevector-transcoders.scm"
       .
       56338))
   (push.iloc 2 . 0)
   (push.iloc 2 . 1)
   (apply.iloc+ (0 . 0) "../stdlib/core/bytevector-transcoders.scm" . 47115))
 (set.gloc.of core.bytevector-transcoders\x27;transcode-utf32->string)
 (close
   (2 1 . core.bytevector-transcoders\x27;utf32->string)
   (call
     (iloc.0 . 2)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 2)
     (ret.subr.gloc.of \x2E;car "../stdlib/core/bytevector-transcoders.scm" . 62480))
   (if.true
     (push.const . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of
       \x2E;bytevector-length
       1
       "../stdlib/core/bytevector-transcoders.scm"
       .
       62507)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of
       core.bytevector-transcoders\x27;transcode-utf32->string
       "../stdlib/core/bytevector-transcoders.scm"
       .
       62480))
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.bytevector-transcoders\x27;test-utf32-bom
       "../stdlib/core/bytevector-transcoders.scm"
       .
       63504))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.const . 4)
     (push.iloc.1 . 0)
     (push.subr.gloc.of
       \x2E;bytevector-length
       1
       "../stdlib/core/bytevector-transcoders.scm"
       .
       65587)
     (push.const . 4)
     (push.subr.gloc.of \x2E;- 2 "../stdlib/core/bytevector-transcoders.scm" . 65584)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.bytevector-transcoders\x27;transcode-utf32->string
       "../stdlib/core/bytevector-transcoders.scm"
       .
       65557))
   (push.const . 0)
   (push.iloc.1 . 0)
   (push.subr.gloc.of \x2E;bytevector-length 1 "../stdlib/core/bytevector-transcoders.scm" . 67627)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (apply.gloc.of
     core.bytevector-transcoders\x27;transcode-utf32->string
     "../stdlib/core/bytevector-transcoders.scm"
     .
     67600))
 (set.gloc.of core.bytevector-transcoders\x27;utf32->string)
 (close
   (1 0 . core.bytevector-transcoders\x27;encode-surrogates)
   (push.n+.iloc (0 . 0) -65536 "../stdlib/core/bytevector-transcoders.scm" . 71696)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const . 1024)
   (push.subr.gloc.of \x2E;div 2 "../stdlib/core/bytevector-transcoders.scm" . 72725)
   (push.const . 55296)
   (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/bytevector-transcoders.scm" . 72722)
   (call
     (push.iloc.0 . 0)
     (push.const . 1024)
     (apply.gloc.of \x2E;mod "../stdlib/core/bytevector-transcoders.scm" . 73749))
   (push)
   (push.const . 56320)
   (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/bytevector-transcoders.scm" . 73746)
   (ret.subr.gloc.of \x2E;values "../stdlib/core/bytevector-transcoders.scm" . 74763))
 (set.gloc.of core.bytevector-transcoders\x27;encode-surrogates)
 (close
   (2 0 . core.bytevector-transcoders\x27;decode-surrogates)
   (push.n+.iloc (0 . 0) -55296 "../stdlib/core/bytevector-transcoders.scm" . 78871)
   (push.const . 1024)
   (push.subr.gloc.of \x2E;* 2 "../stdlib/core/bytevector-transcoders.scm" . 78868)
   (push.n+.iloc (0 . 1) -56320 "../stdlib/core/bytevector-transcoders.scm" . 78893)
   (push.const . 65536)
   (push.subr.gloc.of \x2E;+ 3 "../stdlib/core/bytevector-transcoders.scm" . 78865)
   (extend . 1)
   (>n.iloc (0 . 0) 1114111 "../stdlib/core/bytevector-transcoders.scm" . 79888)
   (if.true.ret.const . #\)
   (push.const . 55296)
   (push.iloc.0 . 0)
   (push.const . 57343)
   (subr.gloc.of \x2E;<= 3 "../stdlib/core/bytevector-transcoders.scm" . 80912)
   (if.true.ret.const . #\)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;integer->char "../stdlib/core/bytevector-transcoders.scm" . 81941))
 (set.gloc.of core.bytevector-transcoders\x27;decode-surrogates)
 (close
   (1 0 . core.bytevector-transcoders\x27;test-utf16-bom)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;bytevector-length 1 "../stdlib/core/bytevector-transcoders.scm" . 86032)
   (push.const . 2)
   (subr.gloc.of \x2E;>= 2 "../stdlib/core/bytevector-transcoders.scm" . 86028)
   (if.false.ret)
   (push.const . 2)
   (push.subr.gloc.of \x2E;make-bytevector 1 "../stdlib/core/bytevector-transcoders.scm" . 87063)
   (extend . 1)
   (push.iloc.1 . 0)
   (push.const . 0)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.const . 2)
   (subr.gloc.of \x2E;bytevector-copy! 5 "../stdlib/core/bytevector-transcoders.scm" . 88078)
   (push.iloc.0 . 0)
   (push.const . #vu8(254 255))
   (subr.gloc.of \x2E;equal? 2 "../stdlib/core/bytevector-transcoders.scm" . 89109)
   (if.true.ret.const . big)
   (push.iloc.0 . 0)
   (push.const . #vu8(255 254))
   (subr.gloc.of \x2E;equal? 2 "../stdlib/core/bytevector-transcoders.scm" . 90133)
   (if.false.ret)
   (ret.const . little))
 (set.gloc.of core.bytevector-transcoders\x27;test-utf16-bom)
 (close
   (1 1 . core.bytevector-transcoders\x27;string->utf16)
   (call
     (iloc.0 . 1)
     (if.pair?
       (push.iloc.0 . 1)
       (ret.subr.gloc.of \x2E;car "../stdlib/core/bytevector-transcoders.scm" . 95267))
     (ret.const . big))
   (push)
   (extend . 1)
   (push.iloc.1 . 0)
   (push.subr.gloc.of \x2E;string-length 1 "../stdlib/core/bytevector-transcoders.scm" . 96272)
   (push.const . 0)
   (subr.gloc.of \x2E;= 2 "../stdlib/core/bytevector-transcoders.scm" . 96269)
   (if.true.ret.const . #vu8())
   (push.iloc.1 . 0)
   (push.subr.gloc.of
     \x2E;make-string-input-port
     1
     "../stdlib/core/bytevector-transcoders.scm"
     .
     98330)
   (push.const . 2)
   (push.subr.gloc.of \x2E;make-bytevector 1 "../stdlib/core/bytevector-transcoders.scm" . 99352)
   (extend . 2)
   (push.gloc.of \x2E;L664)
   (push.close
     (2 0)
     (extend.enclose+
       (1 0 . loop)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;eof-object? 1 "../stdlib/core/bytevector-transcoders.scm" . 102426)
       (if.true (apply.iloc (2 . 1) "../stdlib/core/bytevector-transcoders.scm" . 102443))
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/bytevector-transcoders.scm" . 104484)
       (extend . 1)
       (>=n.iloc (0 . 0) 65536 "../stdlib/core/bytevector-transcoders.scm" . 105507)
       (if.true
         (call
           (push.close
             (0 0)
             (push.iloc.1 . 0)
             (apply.gloc.of
               core.bytevector-transcoders\x27;encode-surrogates
               "../stdlib/core/bytevector-transcoders.scm"
               .
               106558))
           (push.close
             (2 0)
             (push.iloc 5 . 1)
             (push.const . 0)
             (push.iloc.0 . 0)
             (push.iloc 6 . 0)
             (subr.gloc.of
               \x2E;bytevector-u16-set!
               4
               "../stdlib/core/bytevector-transcoders.scm"
               .
               107557)
             (push.iloc 4 . 0)
             (push.iloc 5 . 1)
             (subr.gloc.of
               \x2E;put-bytevector
               2
               "../stdlib/core/bytevector-transcoders.scm"
               .
               108581)
             (push.iloc 5 . 1)
             (push.const . 0)
             (push.iloc.0 . 1)
             (push.iloc 6 . 0)
             (subr.gloc.of
               \x2E;bytevector-u16-set!
               4
               "../stdlib/core/bytevector-transcoders.scm"
               .
               109605)
             (push.iloc 4 . 0)
             (push.iloc 5 . 1)
             (ret.subr.gloc.of
               \x2E;put-bytevector
               "../stdlib/core/bytevector-transcoders.scm"
               .
               110629))
           (apply.gloc.of
             \x2E;call-with-values
             (\x2E;call-with-values
               (lambda () (core.bytevector-transcoders\x27;encode-surrogates sv\x60;1856*))
               (lambda (left\x60;1858* right\x60;1858*)
                 (\x2E;bytevector-u16-set! buf\x60;1847* 0 left\x60;1858* endian\x60;1845*)
                 (\x2E;put-bytevector output\x60;1849* buf\x60;1847*)
                 (\x2E;bytevector-u16-set! buf\x60;1847* 0 right\x60;1858* endian\x60;1845*)
                 (\x2E;put-bytevector output\x60;1849* buf\x60;1847*)))))
         (push.iloc 4 . 0)
         (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/bytevector-transcoders.scm" . 111657)
         (apply.iloc+ (2 . 0) "../stdlib/core/bytevector-transcoders.scm" . 111651))
       (push.iloc 4 . 1)
       (push.const . 0)
       (push.iloc.0 . 0)
       (push.iloc 5 . 0)
       (subr.gloc.of
         \x2E;bytevector-u16-set!
         4
         "../stdlib/core/bytevector-transcoders.scm"
         .
         113699)
       (push.iloc 3 . 0)
       (push.iloc 4 . 1)
       (subr.gloc.of \x2E;put-bytevector 2 "../stdlib/core/bytevector-transcoders.scm" . 114723)
       (push.iloc 4 . 0)
       (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/bytevector-transcoders.scm" . 115753)
       (apply.iloc+ (2 . 0) "../stdlib/core/bytevector-transcoders.scm" . 115747))
     (push.iloc 2 . 0)
     (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/bytevector-transcoders.scm" . 101408)
     (apply.iloc+ (0 . 0) "../stdlib/core/bytevector-transcoders.scm" . 102419))
   (apply.gloc.of
     \x2E;call-with-values
     (\x2E;call-with-values
       \x2E;L664
       (lambda (output\x60;1849* extract\x60;1849*)
         (letrec* ((loop\x60;1853*
                     (lambda (ch\x60;1854*)
                       (if (\x2E;eof-object? ch\x60;1854*)
                           (extract\x60;1849*)
                           (let ((sv\x60;1856* (\x2E;char->integer ch\x60;1854*)))
                             (if (\x2E;>= sv\x60;1856* 65536)
                                 (begin
                                   (\x2E;call-with-values
                                     (lambda ()
                                       (core.bytevector-transcoders\x27;encode-surrogates
                                         sv\x60;1856*))
                                     (lambda (left\x60;1858* right\x60;1858*)
                                       (\x2E;bytevector-u16-set!
                                         buf\x60;1847*
                                         0
                                         left\x60;1858*
                                         endian\x60;1845*)
                                       (\x2E;put-bytevector output\x60;1849* buf\x60;1847*)
                                       (\x2E;bytevector-u16-set!
                                         buf\x60;1847*
                                         0
                                         right\x60;1858*
                                         endian\x60;1845*)
                                       (\x2E;put-bytevector output\x60;1849* buf\x60;1847*)))
                                   (loop\x60;1853* (\x2E;get-char input\x60;1847*)))
                                 (begin
                                   (\x2E;bytevector-u16-set!
                                     buf\x60;1847*
                                     0
                                     sv\x60;1856*
                                     endian\x60;1845*)
                                   (\x2E;put-bytevector output\x60;1849* buf\x60;1847*)
                                   (loop\x60;1853* (\x2E;get-char input\x60;1847*)))))))))
           (loop\x60;1853* (\x2E;get-char input\x60;1847*)))))))
 (set.gloc.of core.bytevector-transcoders\x27;string->utf16)
 (close
   (4 0 . core.bytevector-transcoders\x27;transcode-utf16->string)
   (subr.gloc.of \x2E;make-string-output-port 0)
   (push)
   (extend . 1)
   (extend.enclose+
     (2 0 . loop)
     (=n.iloc (0 . 1) 0 "../stdlib/core/bytevector-transcoders.scm" . 121874)
     (if.true
       (push.iloc 2 . 0)
       (ret.subr.gloc.of
         \x2E;extract-accumulated-string
         "../stdlib/core/bytevector-transcoders.scm"
         .
         121885))
     (>=n.iloc (0 . 1) 2 "../stdlib/core/bytevector-transcoders.scm" . 122898)
     (if.true
       (push.iloc 3 . 2)
       (push.iloc.0 . 0)
       (push.iloc 3 . 3)
       (push.subr.gloc.of
         \x2E;bytevector-u16-ref
         3
         "../stdlib/core/bytevector-transcoders.scm"
         .
         123932)
       (extend . 1)
       (push.const . 55296)
       (push.iloc.0 . 0)
       (push.const . 56319)
       (subr.gloc.of \x2E;<= 3 "../stdlib/core/bytevector-transcoders.scm" . 124955)
       (if.true
         (>=n.iloc (1 . 1) 4 "../stdlib/core/bytevector-transcoders.scm" . 125986)
         (if.true
           (push.iloc 4 . 2)
           (push.n+.iloc (1 . 0) 2 "../stdlib/core/bytevector-transcoders.scm" . 127049)
           (push.iloc 4 . 3)
           (push.subr.gloc.of
             \x2E;bytevector-u16-ref
             3
             "../stdlib/core/bytevector-transcoders.scm"
             .
             127023)
           (extend . 1)
           (push.const . 56320)
           (push.iloc.0 . 0)
           (push.const . 57343)
           (subr.gloc.of \x2E;<= 3 "../stdlib/core/bytevector-transcoders.scm" . 128043)
           (if.true
             (push.iloc 4 . 0)
             (call
               (push.iloc.1 . 0)
               (push.iloc.0 . 0)
               (apply.gloc.of
                 core.bytevector-transcoders\x27;decode-surrogates
                 "../stdlib/core/bytevector-transcoders.scm"
                 .
                 129084))
             (push)
             (subr.gloc.of \x2E;put-char 2 "../stdlib/core/bytevector-transcoders.scm" . 129067)
             (push.n+.iloc (2 . 0) 4 "../stdlib/core/bytevector-transcoders.scm" . 130097)
             (push.n+.iloc (2 . 1) -4 "../stdlib/core/bytevector-transcoders.scm" . 130105)
             (apply.iloc+ (3 . 0) "../stdlib/core/bytevector-transcoders.scm" . 130091))
           (push.iloc 4 . 0)
           (push.const . #\)
           (subr.gloc.of \x2E;put-char 2 "../stdlib/core/bytevector-transcoders.scm" . 132139)
           (push.n+.iloc (2 . 0) 2 "../stdlib/core/bytevector-transcoders.scm" . 133169)
           (push.n+.iloc (2 . 1) -2 "../stdlib/core/bytevector-transcoders.scm" . 133177)
           (apply.iloc+ (3 . 0) "../stdlib/core/bytevector-transcoders.scm" . 133163))
         (push.iloc 3 . 0)
         (push.const . #\)
         (subr.gloc.of \x2E;put-char 2 "../stdlib/core/bytevector-transcoders.scm" . 135202)
         (push.iloc 3 . 0)
         (ret.subr.gloc.of
           \x2E;extract-accumulated-string
           "../stdlib/core/bytevector-transcoders.scm"
           .
           136226))
       (push.const . 56320)
       (push.iloc.0 . 0)
       (push.const . 57343)
       (subr.gloc.of \x2E;<= 3 "../stdlib/core/bytevector-transcoders.scm" . 137243)
       (if.true
         (push.iloc 3 . 0)
         (push.const . #\)
         (subr.gloc.of \x2E;put-char 2 "../stdlib/core/bytevector-transcoders.scm" . 138267)
         (push.n+.iloc (1 . 0) 2 "../stdlib/core/bytevector-transcoders.scm" . 139297)
         (push.n+.iloc (1 . 1) -2 "../stdlib/core/bytevector-transcoders.scm" . 139305)
         (apply.iloc+ (2 . 0) "../stdlib/core/bytevector-transcoders.scm" . 139291))
       (push.iloc 3 . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;integer->char 1 "../stdlib/core/bytevector-transcoders.scm" . 141356)
       (subr.gloc.of \x2E;put-char 2 "../stdlib/core/bytevector-transcoders.scm" . 141339)
       (push.n+.iloc (1 . 0) 2 "../stdlib/core/bytevector-transcoders.scm" . 142369)
       (push.n+.iloc (1 . 1) -2 "../stdlib/core/bytevector-transcoders.scm" . 142377)
       (apply.iloc+ (2 . 0) "../stdlib/core/bytevector-transcoders.scm" . 142363))
     (push.iloc 2 . 0)
     (push.const . #\)
     (subr.gloc.of \x2E;put-char 2 "../stdlib/core/bytevector-transcoders.scm" . 144402)
     (push.iloc 2 . 0)
     (ret.subr.gloc.of
       \x2E;extract-accumulated-string
       "../stdlib/core/bytevector-transcoders.scm"
       .
       145426))
   (push.iloc 2 . 0)
   (push.iloc 2 . 1)
   (apply.iloc+ (0 . 0) "../stdlib/core/bytevector-transcoders.scm" . 121867))
 (set.gloc.of core.bytevector-transcoders\x27;transcode-utf16->string)
 (close
   (2 1 . core.bytevector-transcoders\x27;utf16->string)
   (call
     (iloc.0 . 2)
     (if.not.pair?.ret.const . #f)
     (push.iloc.0 . 2)
     (ret.subr.gloc.of \x2E;car "../stdlib/core/bytevector-transcoders.scm" . 151568))
   (if.true
     (push.const . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of
       \x2E;bytevector-length
       1
       "../stdlib/core/bytevector-transcoders.scm"
       .
       151595)
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of
       core.bytevector-transcoders\x27;transcode-utf16->string
       "../stdlib/core/bytevector-transcoders.scm"
       .
       151568))
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.bytevector-transcoders\x27;test-utf16-bom
       "../stdlib/core/bytevector-transcoders.scm"
       .
       152592))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.const . 2)
     (push.iloc.1 . 0)
     (push.subr.gloc.of
       \x2E;bytevector-length
       1
       "../stdlib/core/bytevector-transcoders.scm"
       .
       154675)
     (push.const . 2)
     (push.subr.gloc.of \x2E;- 2 "../stdlib/core/bytevector-transcoders.scm" . 154672)
     (push.iloc.1 . 0)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.bytevector-transcoders\x27;transcode-utf16->string
       "../stdlib/core/bytevector-transcoders.scm"
       .
       154645))
   (push.const . 0)
   (push.iloc.1 . 0)
   (push.subr.gloc.of \x2E;bytevector-length 1 "../stdlib/core/bytevector-transcoders.scm" . 156715)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (apply.gloc.of
     core.bytevector-transcoders\x27;transcode-utf16->string
     "../stdlib/core/bytevector-transcoders.scm"
     .
     156688))
 (set.gloc.of core.bytevector-transcoders\x27;utf16->string)
 (push.const . core.bytevector-transcoders)
 (push.const . #f)
 (push.const
   (string->utf8 import . \x2E;string->utf8)
   (utf8->string import . \x2E;utf8->string)
   (string->utf16 import . core.bytevector-transcoders\x27;string->utf16)
   (utf16->string import . core.bytevector-transcoders\x27;utf16->string)
   (string->utf32 import . core.bytevector-transcoders\x27;string->utf32)
   (utf32->string import . core.bytevector-transcoders\x27;utf32->string))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/bytevector-transcoders.scm" . 25646))

((close
   (1 0)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;get-datum "../stdlib/core/unicode-assistants.scm" . 52237))
 (set.gloc.of \x2E;L705)
 (call
   (push.const core bytevector-transcoders)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/unicode-assistants.scm" . 51211))
 (call
   (push.const core bytevectors)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/unicode-assistants.scm" . 51211))
 (call
   (push.const core lists)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/unicode-assistants.scm" . 51211))
 (call
   (push.const core files)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/unicode-assistants.scm" . 51211))
 (call
   (push.const core io)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/unicode-assistants.scm" . 51211))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/unicode-assistants.scm" . 51211))
 (close
   (2 0 . core.unicode-assistants\x27;load-unicode-table-file)
   (push.iloc.0 . 0)
   (push.subr.gloc.of
     \x2E;open-builtin-data-input-port
     1
     "../stdlib/core/unicode-assistants.scm"
     .
     36875)
   (push.close
     (1 0)
     (push.const . eqv?)
     (push.iloc.1 . 1)
     (push.subr.gloc.of \x2E;make-core-hashtable 2 "../stdlib/core/unicode-assistants.scm" . 38935)
     (extend . 1)
     (call
       (extend.enclose+
         (1 0 . loop)
         (iloc.0 . 0)
         (if.null?.ret.const . #t)
         (push.iloc 2 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of \x2E;caar 1 "../stdlib/core/unicode-assistants.scm" . 43056)
         (push.iloc.0 . 0)
         (push.subr.gloc.of \x2E;cdar 1 "../stdlib/core/unicode-assistants.scm" . 43067)
         (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/unicode-assistants.scm" . 43032)
         (push.cdr.iloc (0 . 0) "../stdlib/core/unicode-assistants.scm" . 44062)
         (apply.iloc+ (1 . 0) "../stdlib/core/unicode-assistants.scm" . 44056))
       (push.iloc 2 . 0)
       (push.subr.gloc.of \x2E;get-datum 1 "../stdlib/core/unicode-assistants.scm" . 39967)
       (apply.iloc+ (0 . 0) "../stdlib/core/unicode-assistants.scm" . 40977))
     (push.iloc.0 . 0)
     (ret.subr.gloc.of \x2E;core-hashtable-copy "../stdlib/core/unicode-assistants.scm" . 45071))
   (apply.gloc.of \x2E;call-with-port "../stdlib/core/unicode-assistants.scm" . 35847))
 (set.gloc.of core.unicode-assistants\x27;load-unicode-table-file)
 (close
   (1 0 . core.unicode-assistants\x27;load-unicode-list-file)
   (push.iloc.0 . 0)
   (push.subr.gloc.of
     \x2E;open-builtin-data-input-port
     1
     "../stdlib/core/unicode-assistants.scm"
     .
     50187)
   (push.gloc.of \x2E;L705)
   (apply.gloc.of \x2E;call-with-port "../stdlib/core/unicode-assistants.scm" . 49159))
 (set.gloc.of core.unicode-assistants\x27;load-unicode-list-file)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 68611))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1884)
 (close
   (0 0 . core.unicode-assistants\x27;general-category-table-1)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 68611)
   (if.true
     (call
       (push.const . "general-category-1")
       (push.const . 1000)
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-table-file
         "../stdlib/core/unicode-assistants.scm"
         .
         70660))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;general-category-table-1) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;general-category-table-1
       "../stdlib/core/unicode-assistants.scm"
       .
       68611)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1884)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1884
       "../stdlib/core/unicode-assistants.scm"
       .
       68611))
   (if.true.ret)
   (call
     (push.const . "general-category-1")
     (push.const . 1000)
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-table-file
       "../stdlib/core/unicode-assistants.scm"
       .
       70660))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1884)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1884
       "../stdlib/core/unicode-assistants.scm"
       .
       68611))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;general-category-table-1)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 72707))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1885)
 (close
   (0 0 . core.unicode-assistants\x27;general-category-table-2)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 72707)
   (if.true
     (call
       (push.const . "general-category-2")
       (push.const . 170000)
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-table-file
         "../stdlib/core/unicode-assistants.scm"
         .
         74756))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;general-category-table-2) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;general-category-table-2
       "../stdlib/core/unicode-assistants.scm"
       .
       72707)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1885)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1885
       "../stdlib/core/unicode-assistants.scm"
       .
       72707))
   (if.true.ret)
   (call
     (push.const . "general-category-2")
     (push.const . 170000)
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-table-file
       "../stdlib/core/unicode-assistants.scm"
       .
       74756))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1885)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1885
       "../stdlib/core/unicode-assistants.scm"
       .
       72707))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;general-category-table-2)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 76803))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1886)
 (close
   (0 0 . core.unicode-assistants\x27;simple-uppercase-table)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 76803)
   (if.true
     (call
       (push.const . "simple-uppercase")
       (push.const . 1500)
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-table-file
         "../stdlib/core/unicode-assistants.scm"
         .
         78852))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;simple-uppercase-table) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;simple-uppercase-table
       "../stdlib/core/unicode-assistants.scm"
       .
       76803)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1886)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1886
       "../stdlib/core/unicode-assistants.scm"
       .
       76803))
   (if.true.ret)
   (call
     (push.const . "simple-uppercase")
     (push.const . 1500)
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-table-file
       "../stdlib/core/unicode-assistants.scm"
       .
       78852))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1886)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1886
       "../stdlib/core/unicode-assistants.scm"
       .
       76803))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;simple-uppercase-table)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 80899))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1887)
 (close
   (0 0 . core.unicode-assistants\x27;simple-lowercase-table)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 80899)
   (if.true
     (call
       (push.const . "simple-lowercase")
       (push.const . 1500)
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-table-file
         "../stdlib/core/unicode-assistants.scm"
         .
         82948))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;simple-lowercase-table) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;simple-lowercase-table
       "../stdlib/core/unicode-assistants.scm"
       .
       80899)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1887)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1887
       "../stdlib/core/unicode-assistants.scm"
       .
       80899))
   (if.true.ret)
   (call
     (push.const . "simple-lowercase")
     (push.const . 1500)
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-table-file
       "../stdlib/core/unicode-assistants.scm"
       .
       82948))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1887)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1887
       "../stdlib/core/unicode-assistants.scm"
       .
       80899))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;simple-lowercase-table)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 84995))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1888)
 (close
   (0 0 . core.unicode-assistants\x27;simple-titlecase-table)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 84995)
   (if.true
     (call
       (push.const . "simple-titlecase")
       (push.const . 1500)
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-table-file
         "../stdlib/core/unicode-assistants.scm"
         .
         87044))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;simple-titlecase-table) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;simple-titlecase-table
       "../stdlib/core/unicode-assistants.scm"
       .
       84995)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1888)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1888
       "../stdlib/core/unicode-assistants.scm"
       .
       84995))
   (if.true.ret)
   (call
     (push.const . "simple-titlecase")
     (push.const . 1500)
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-table-file
       "../stdlib/core/unicode-assistants.scm"
       .
       87044))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1888)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1888
       "../stdlib/core/unicode-assistants.scm"
       .
       84995))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;simple-titlecase-table)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 89091))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1889)
 (close
   (0 0 . core.unicode-assistants\x27;numeric-property-table)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 89091)
   (if.true
     (call
       (push.const . "numeric-property")
       (push.const . 1500)
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-table-file
         "../stdlib/core/unicode-assistants.scm"
         .
         91140))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;numeric-property-table) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;numeric-property-table
       "../stdlib/core/unicode-assistants.scm"
       .
       89091)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1889)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1889
       "../stdlib/core/unicode-assistants.scm"
       .
       89091))
   (if.true.ret)
   (call
     (push.const . "numeric-property")
     (push.const . 1500)
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-table-file
       "../stdlib/core/unicode-assistants.scm"
       .
       91140))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1889)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1889
       "../stdlib/core/unicode-assistants.scm"
       .
       89091))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;numeric-property-table)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 93187))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1890)
 (close
   (0 0 . core.unicode-assistants\x27;special-casing-lower-table)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 93187)
   (if.true
     (call
       (push.const . "special-casing-lower")
       (push.const . 300)
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-table-file
         "../stdlib/core/unicode-assistants.scm"
         .
         95236))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;special-casing-lower-table) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;special-casing-lower-table
       "../stdlib/core/unicode-assistants.scm"
       .
       93187)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1890)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1890
       "../stdlib/core/unicode-assistants.scm"
       .
       93187))
   (if.true.ret)
   (call
     (push.const . "special-casing-lower")
     (push.const . 300)
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-table-file
       "../stdlib/core/unicode-assistants.scm"
       .
       95236))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1890)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1890
       "../stdlib/core/unicode-assistants.scm"
       .
       93187))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;special-casing-lower-table)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 97283))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1891)
 (close
   (0 0 . core.unicode-assistants\x27;special-casing-title-table)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 97283)
   (if.true
     (call
       (push.const . "special-casing-title")
       (push.const . 300)
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-table-file
         "../stdlib/core/unicode-assistants.scm"
         .
         99332))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;special-casing-title-table) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;special-casing-title-table
       "../stdlib/core/unicode-assistants.scm"
       .
       97283)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1891)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1891
       "../stdlib/core/unicode-assistants.scm"
       .
       97283))
   (if.true.ret)
   (call
     (push.const . "special-casing-title")
     (push.const . 300)
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-table-file
       "../stdlib/core/unicode-assistants.scm"
       .
       99332))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1891)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1891
       "../stdlib/core/unicode-assistants.scm"
       .
       97283))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;special-casing-title-table)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 101379))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1892)
 (close
   (0 0 . core.unicode-assistants\x27;special-casing-upper-table)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 101379)
   (if.true
     (call
       (push.const . "special-casing-upper")
       (push.const . 300)
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-table-file
         "../stdlib/core/unicode-assistants.scm"
         .
         103428))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;special-casing-upper-table) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;special-casing-upper-table
       "../stdlib/core/unicode-assistants.scm"
       .
       101379)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1892)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1892
       "../stdlib/core/unicode-assistants.scm"
       .
       101379))
   (if.true.ret)
   (call
     (push.const . "special-casing-upper")
     (push.const . 300)
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-table-file
       "../stdlib/core/unicode-assistants.scm"
       .
       103428))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1892)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1892
       "../stdlib/core/unicode-assistants.scm"
       .
       101379))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;special-casing-upper-table)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 105475))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1893)
 (close
   (0 0 . core.unicode-assistants\x27;case-folding-table)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 105475)
   (if.true
     (call
       (push.const . "case-folding")
       (push.const . 1500)
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-table-file
         "../stdlib/core/unicode-assistants.scm"
         .
         107524))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;case-folding-table) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;case-folding-table
       "../stdlib/core/unicode-assistants.scm"
       .
       105475)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1893)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1893
       "../stdlib/core/unicode-assistants.scm"
       .
       105475))
   (if.true.ret)
   (call
     (push.const . "case-folding")
     (push.const . 1500)
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-table-file
       "../stdlib/core/unicode-assistants.scm"
       .
       107524))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1893)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1893
       "../stdlib/core/unicode-assistants.scm"
       .
       105475))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;case-folding-table)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 109571))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1894)
 (close
   (0 0 . core.unicode-assistants\x27;other-uppercase-list)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 109571)
   (if.true
     (call
       (push.const . "other-uppercase")
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-list-file
         "../stdlib/core/unicode-assistants.scm"
         .
         111620))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;other-uppercase-list) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;other-uppercase-list
       "../stdlib/core/unicode-assistants.scm"
       .
       109571)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1894)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1894
       "../stdlib/core/unicode-assistants.scm"
       .
       109571))
   (if.true.ret)
   (call
     (push.const . "other-uppercase")
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-list-file
       "../stdlib/core/unicode-assistants.scm"
       .
       111620))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1894)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1894
       "../stdlib/core/unicode-assistants.scm"
       .
       109571))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;other-uppercase-list)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 113667))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1895)
 (close
   (0 0 . core.unicode-assistants\x27;other-lowercase-list)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 113667)
   (if.true
     (call
       (push.const . "other-lowercase")
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-list-file
         "../stdlib/core/unicode-assistants.scm"
         .
         115716))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;other-lowercase-list) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;other-lowercase-list
       "../stdlib/core/unicode-assistants.scm"
       .
       113667)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1895)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1895
       "../stdlib/core/unicode-assistants.scm"
       .
       113667))
   (if.true.ret)
   (call
     (push.const . "other-lowercase")
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-list-file
       "../stdlib/core/unicode-assistants.scm"
       .
       115716))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1895)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1895
       "../stdlib/core/unicode-assistants.scm"
       .
       113667))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;other-lowercase-list)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 117763))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1896)
 (close
   (0 0 . core.unicode-assistants\x27;other-alphabetic-list)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 117763)
   (if.true
     (call
       (push.const . "other-alphabetic")
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-list-file
         "../stdlib/core/unicode-assistants.scm"
         .
         119812))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;other-alphabetic-list) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;other-alphabetic-list
       "../stdlib/core/unicode-assistants.scm"
       .
       117763)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1896)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1896
       "../stdlib/core/unicode-assistants.scm"
       .
       117763))
   (if.true.ret)
   (call
     (push.const . "other-alphabetic")
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-list-file
       "../stdlib/core/unicode-assistants.scm"
       .
       119812))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1896)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1896
       "../stdlib/core/unicode-assistants.scm"
       .
       117763))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;other-alphabetic-list)
 (close
   (1 0 . core.unicode-assistants\x27;general-category)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/unicode-assistants.scm" . 123921)
   (extend . 1)
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;general-category-table-1
       "../stdlib/core/unicode-assistants.scm"
       .
       124961))
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/unicode-assistants.scm" . 124941)
   (if.true.ret)
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;general-category-table-2
       "../stdlib/core/unicode-assistants.scm"
       .
       125985))
   (push)
   (push.iloc.0 . 0)
   (push.const . #f)
   (subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/unicode-assistants.scm" . 125965)
   (if.true.ret)
   (push.const . 13312)
   (push.iloc.0 . 0)
   (push.const . 19893)
   (subr.gloc.of \x2E;<= 3 "../stdlib/core/unicode-assistants.scm" . 130063)
   (if.true.ret.const . Lo)
   (push.const . 19968)
   (push.iloc.0 . 0)
   (push.const . 40891)
   (subr.gloc.of \x2E;<= 3 "../stdlib/core/unicode-assistants.scm" . 133135)
   (if.true.ret.const . Lo)
   (push.const . 44032)
   (push.iloc.0 . 0)
   (push.const . 55203)
   (subr.gloc.of \x2E;<= 3 "../stdlib/core/unicode-assistants.scm" . 136207)
   (if.true.ret.const . Lo)
   (push.const . 55296)
   (push.iloc.0 . 0)
   (push.const . 56191)
   (subr.gloc.of \x2E;<= 3 "../stdlib/core/unicode-assistants.scm" . 139279)
   (if.true.ret.const . Cs)
   (push.const . 56192)
   (push.iloc.0 . 0)
   (push.const . 56319)
   (subr.gloc.of \x2E;<= 3 "../stdlib/core/unicode-assistants.scm" . 142351)
   (if.true.ret.const . Cs)
   (push.const . 56320)
   (push.iloc.0 . 0)
   (push.const . 57343)
   (subr.gloc.of \x2E;<= 3 "../stdlib/core/unicode-assistants.scm" . 145423)
   (if.true.ret.const . Cs)
   (push.const . 57344)
   (push.iloc.0 . 0)
   (push.const . 63743)
   (subr.gloc.of \x2E;<= 3 "../stdlib/core/unicode-assistants.scm" . 148495)
   (if.true.ret.const . Co)
   (push.const . 131072)
   (push.iloc.0 . 0)
   (push.const . 173782)
   (subr.gloc.of \x2E;<= 3 "../stdlib/core/unicode-assistants.scm" . 151567)
   (if.true.ret.const . Lo)
   (push.const . 983040)
   (push.iloc.0 . 0)
   (push.const . 1048573)
   (subr.gloc.of \x2E;<= 3 "../stdlib/core/unicode-assistants.scm" . 154639)
   (if.true.ret.const . Co)
   (push.const . 1048576)
   (push.iloc.0 . 0)
   (push.const . 1114109)
   (subr.gloc.of \x2E;<= 3 "../stdlib/core/unicode-assistants.scm" . 157711)
   (if.true.ret.const . Co)
   (ret.const . Cn))
 (set.gloc.of core.unicode-assistants\x27;general-category)
 (close
   (1 0 . core.unicode-assistants\x27;numeric-property?)
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;numeric-property-table
       "../stdlib/core/unicode-assistants.scm"
       .
       162848))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/unicode-assistants.scm" . 162873)
   (push.const . #f)
   (subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/unicode-assistants.scm" . 162828)
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of core.unicode-assistants\x27;numeric-property?)
 (close
   (1 0 . core.unicode-assistants\x27;simple-uppercase)
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;simple-uppercase-table
       "../stdlib/core/unicode-assistants.scm"
       .
       166946))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/unicode-assistants.scm" . 166971)
   (push.const . #f)
   (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/unicode-assistants.scm" . 166926)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (ret.subr.gloc.of \x2E;integer->char "../stdlib/core/unicode-assistants.scm" . 167965))
   (ret.iloc 1 . 0))
 (set.gloc.of core.unicode-assistants\x27;simple-uppercase)
 (close
   (1 0 . core.unicode-assistants\x27;simple-lowercase)
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;simple-lowercase-table
       "../stdlib/core/unicode-assistants.scm"
       .
       173090))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/unicode-assistants.scm" . 173115)
   (push.const . #f)
   (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/unicode-assistants.scm" . 173070)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (ret.subr.gloc.of \x2E;integer->char "../stdlib/core/unicode-assistants.scm" . 174109))
   (ret.iloc 1 . 0))
 (set.gloc.of core.unicode-assistants\x27;simple-lowercase)
 (close
   (1 0 . core.unicode-assistants\x27;simple-titlecase)
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;simple-titlecase-table
       "../stdlib/core/unicode-assistants.scm"
       .
       179234))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/unicode-assistants.scm" . 179259)
   (push.const . #f)
   (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/unicode-assistants.scm" . 179214)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (push.iloc.0 . 0)
     (ret.subr.gloc.of \x2E;integer->char "../stdlib/core/unicode-assistants.scm" . 180253))
   (push.iloc.1 . 0)
   (apply.gloc.of
     core.unicode-assistants\x27;simple-uppercase
     "../stdlib/core/unicode-assistants.scm"
     .
     181267))
 (set.gloc.of core.unicode-assistants\x27;simple-titlecase)
 (close
   (1 0 . core.unicode-assistants\x27;other-uppercase-property?)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/unicode-assistants.scm" . 185361)
   (extend . 1)
   (push.const . 8544)
   (push.iloc.0 . 0)
   (push.const . 9423)
   (subr.gloc.of \x2E;<= 3 "../stdlib/core/unicode-assistants.scm" . 186382)
   (if.false.ret)
   (push.close
     (1 0)
     (push.car.iloc (0 . 0) "../stdlib/core/unicode-assistants.scm" . 187430)
     (push.iloc.1 . 0)
     (push.cdr.iloc (0 . 0) "../stdlib/core/unicode-assistants.scm" . 187441)
     (ret.subr.gloc.of \x2E;<= "../stdlib/core/unicode-assistants.scm" . 187426))
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;other-uppercase-list
       "../stdlib/core/unicode-assistants.scm"
       .
       187451))
   (push)
   (apply.gloc.of core.lists\x27;exists "../stdlib/core/unicode-assistants.scm" . 187406))
 (set.gloc.of core.unicode-assistants\x27;other-uppercase-property?)
 (close
   (1 0 . core.unicode-assistants\x27;other-lowercase-property?)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/unicode-assistants.scm" . 191505)
   (extend . 1)
   (push.const . 688)
   (push.iloc.0 . 0)
   (push.const . 9449)
   (subr.gloc.of \x2E;<= 3 "../stdlib/core/unicode-assistants.scm" . 192526)
   (if.false.ret)
   (push.close
     (1 0)
     (push.car.iloc (0 . 0) "../stdlib/core/unicode-assistants.scm" . 193574)
     (push.iloc.1 . 0)
     (push.cdr.iloc (0 . 0) "../stdlib/core/unicode-assistants.scm" . 193585)
     (ret.subr.gloc.of \x2E;<= "../stdlib/core/unicode-assistants.scm" . 193570))
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;other-lowercase-list
       "../stdlib/core/unicode-assistants.scm"
       .
       193595))
   (push)
   (apply.gloc.of core.lists\x27;exists "../stdlib/core/unicode-assistants.scm" . 193550))
 (set.gloc.of core.unicode-assistants\x27;other-lowercase-property?)
 (close
   (1 0 . core.unicode-assistants\x27;other-alphabetic-property?)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/unicode-assistants.scm" . 197649)
   (extend . 1)
   (push.const . 837)
   (push.iloc.0 . 0)
   (push.const . 68111)
   (subr.gloc.of \x2E;<= 3 "../stdlib/core/unicode-assistants.scm" . 198670)
   (if.false.ret)
   (push.close
     (1 0)
     (push.car.iloc (0 . 0) "../stdlib/core/unicode-assistants.scm" . 199718)
     (push.iloc.1 . 0)
     (push.cdr.iloc (0 . 0) "../stdlib/core/unicode-assistants.scm" . 199729)
     (ret.subr.gloc.of \x2E;<= "../stdlib/core/unicode-assistants.scm" . 199714))
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;other-alphabetic-list
       "../stdlib/core/unicode-assistants.scm"
       .
       199739))
   (push)
   (apply.gloc.of core.lists\x27;exists "../stdlib/core/unicode-assistants.scm" . 199694))
 (set.gloc.of core.unicode-assistants\x27;other-alphabetic-property?)
 (close
   (1 0 . core.unicode-assistants\x27;special-casing-lower)
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;special-casing-lower-table
       "../stdlib/core/unicode-assistants.scm"
       .
       203803))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/unicode-assistants.scm" . 203832)
   (push.const . #f)
   (ret.subr.gloc.of \x2E;core-hashtable-ref "../stdlib/core/unicode-assistants.scm" . 203783))
 (set.gloc.of core.unicode-assistants\x27;special-casing-lower)
 (close
   (1 0 . core.unicode-assistants\x27;special-casing-title)
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;special-casing-title-table
       "../stdlib/core/unicode-assistants.scm"
       .
       207899))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/unicode-assistants.scm" . 207928)
   (push.const . #f)
   (ret.subr.gloc.of \x2E;core-hashtable-ref "../stdlib/core/unicode-assistants.scm" . 207879))
 (set.gloc.of core.unicode-assistants\x27;special-casing-title)
 (close
   (1 0 . core.unicode-assistants\x27;special-casing-upper)
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;special-casing-upper-table
       "../stdlib/core/unicode-assistants.scm"
       .
       211995))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/unicode-assistants.scm" . 212024)
   (push.const . #f)
   (ret.subr.gloc.of \x2E;core-hashtable-ref "../stdlib/core/unicode-assistants.scm" . 211975))
 (set.gloc.of core.unicode-assistants\x27;special-casing-upper)
 (close
   (1 0 . core.unicode-assistants\x27;foldcase)
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;case-folding-table
       "../stdlib/core/unicode-assistants.scm"
       .
       216091))
   (push)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/unicode-assistants.scm" . 216112)
   (push.const . #f)
   (ret.subr.gloc.of \x2E;core-hashtable-ref "../stdlib/core/unicode-assistants.scm" . 216071))
 (set.gloc.of core.unicode-assistants\x27;foldcase)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 218115))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1897)
 (close
   (0 0 . core.unicode-assistants\x27;canonical-class-table)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 218115)
   (if.true
     (call
       (push.const . "canonical-class")
       (push.const . 1500)
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-table-file
         "../stdlib/core/unicode-assistants.scm"
         .
         220164))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;canonical-class-table) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;canonical-class-table
       "../stdlib/core/unicode-assistants.scm"
       .
       218115)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1897)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1897
       "../stdlib/core/unicode-assistants.scm"
       .
       218115))
   (if.true.ret)
   (call
     (push.const . "canonical-class")
     (push.const . 1500)
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-table-file
       "../stdlib/core/unicode-assistants.scm"
       .
       220164))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1897)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1897
       "../stdlib/core/unicode-assistants.scm"
       .
       218115))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;canonical-class-table)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 222211))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1898)
 (close
   (0 0 . core.unicode-assistants\x27;decompose-table)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 222211)
   (if.true
     (call
       (push.const . "decompose")
       (push.const . 80000)
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-table-file
         "../stdlib/core/unicode-assistants.scm"
         .
         224260))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;decompose-table) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;decompose-table
       "../stdlib/core/unicode-assistants.scm"
       .
       222211)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1898)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1898
       "../stdlib/core/unicode-assistants.scm"
       .
       222211))
   (if.true.ret)
   (call
     (push.const . "decompose")
     (push.const . 80000)
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-table-file
       "../stdlib/core/unicode-assistants.scm"
       .
       224260))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1898)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1898
       "../stdlib/core/unicode-assistants.scm"
       .
       222211))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;decompose-table)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 226307))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1899)
 (close
   (0 0 . core.unicode-assistants\x27;compose-table)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 226307)
   (if.true
     (call
       (push.const . "compose")
       (push.const . 5000)
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-table-file
         "../stdlib/core/unicode-assistants.scm"
         .
         228356))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;compose-table) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;compose-table
       "../stdlib/core/unicode-assistants.scm"
       .
       226307)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1899)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1899
       "../stdlib/core/unicode-assistants.scm"
       .
       226307))
   (if.true.ret)
   (call
     (push.const . "compose")
     (push.const . 5000)
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-table-file
       "../stdlib/core/unicode-assistants.scm"
       .
       228356))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1899)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1899
       "../stdlib/core/unicode-assistants.scm"
       .
       226307))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;compose-table)
 (call
   (push.const . #f)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/unicode-assistants.scm" . 230403))
 (set.gloc.of core.unicode-assistants\x27;temp\x60;1900)
 (close
   (0 0 . core.unicode-assistants\x27;compatibility-table)
   (subr.gloc.of \x2E;on-primordial-thread? 0 "../stdlib/core/unicode-assistants.scm" . 230403)
   (if.true
     (call
       (push.const . "compatibility")
       (push.const . 5000)
       (apply.gloc.of
         core.unicode-assistants\x27;load-unicode-table-file
         "../stdlib/core/unicode-assistants.scm"
         .
         232452))
     (push)
     (extend . 1)
     (close (0 0 . core.unicode-assistants\x27;compatibility-table) (ret.iloc 1 . 0))
     (set.gloc.of
       core.unicode-assistants\x27;compatibility-table
       "../stdlib/core/unicode-assistants.scm"
       .
       230403)
     (ret.iloc 0 . 0))
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1900)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1900
       "../stdlib/core/unicode-assistants.scm"
       .
       230403))
   (if.true.ret)
   (call
     (push.const . "compatibility")
     (push.const . 5000)
     (apply.gloc.of
       core.unicode-assistants\x27;load-unicode-table-file
       "../stdlib/core/unicode-assistants.scm"
       .
       232452))
   (push)
   (extend . 1)
   (call
     (touch.gloc.of core.unicode-assistants\x27;temp\x60;1900)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;temp\x60;1900
       "../stdlib/core/unicode-assistants.scm"
       .
       230403))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode-assistants\x27;compatibility-table)
 (const . 44032)
 (set.gloc.of core.unicode-assistants\x27;SBase)
 (const . 4352)
 (set.gloc.of core.unicode-assistants\x27;LBase)
 (const . 4449)
 (set.gloc.of core.unicode-assistants\x27;VBase)
 (const . 4519)
 (set.gloc.of core.unicode-assistants\x27;TBase)
 (const . 19)
 (set.gloc.of core.unicode-assistants\x27;LCount)
 (const . 21)
 (set.gloc.of core.unicode-assistants\x27;VCount)
 (const . 28)
 (set.gloc.of core.unicode-assistants\x27;TCount)
 (push.gloc.of core.unicode-assistants\x27;VCount)
 (push.gloc.of core.unicode-assistants\x27;TCount)
 (subr.gloc.of \x2E;* 2 "../stdlib/core/unicode-assistants.scm" . 241682)
 (set.gloc.of core.unicode-assistants\x27;NCount)
 (push.gloc.of core.unicode-assistants\x27;LCount)
 (push.gloc.of core.unicode-assistants\x27;NCount)
 (subr.gloc.of \x2E;* 2 "../stdlib/core/unicode-assistants.scm" . 242706)
 (set.gloc.of core.unicode-assistants\x27;SCount)
 (close
   (2 0 . core.unicode-assistants\x27;pair-wise-composition)
   (call
     (<n.iloc (0 . 0) 0 "../stdlib/core/unicode-assistants.scm" . 246802)
     (if.true.ret)
     (>n.iloc (0 . 0) 1114111 "../stdlib/core/unicode-assistants.scm" . 246814)
     (if.true.ret)
     (<n.iloc (0 . 1) 0 "../stdlib/core/unicode-assistants.scm" . 246833)
     (if.true.ret)
     (push.iloc.0 . 1)
     (push.const . 1114111)
     (ret.subr.gloc.of \x2E;> "../stdlib/core/unicode-assistants.scm" . 246846))
   (if.true.ret.const . #f)
   (push.iloc.0 . 0)
   (push.gloc.of core.unicode-assistants\x27;LBase)
   (push.subr.gloc.of \x2E;- 2 "../stdlib/core/unicode-assistants.scm" . 248860)
   (push.iloc.0 . 1)
   (push.gloc.of core.unicode-assistants\x27;VBase)
   (push.subr.gloc.of \x2E;- 2 "../stdlib/core/unicode-assistants.scm" . 248885)
   (push.iloc.0 . 0)
   (push.gloc.of core.unicode-assistants\x27;SBase)
   (push.subr.gloc.of \x2E;- 2 "../stdlib/core/unicode-assistants.scm" . 248911)
   (push.iloc.0 . 1)
   (push.gloc.of core.unicode-assistants\x27;TBase)
   (push.subr.gloc.of \x2E;- 2 "../stdlib/core/unicode-assistants.scm" . 248936)
   (extend . 4)
   (call
     (push.const . -1)
     (push.iloc.0 . 0)
     (push.gloc.of core.unicode-assistants\x27;LCount)
     (subr.gloc.of \x2E;< 3 "../stdlib/core/unicode-assistants.scm" . 249884)
     (if.false.ret)
     (push.const . -1)
     (push.iloc.0 . 1)
     (push.gloc.of core.unicode-assistants\x27;VCount)
     (ret.subr.gloc.of \x2E;< "../stdlib/core/unicode-assistants.scm" . 249905))
   (if.true
     (push.gloc.of core.unicode-assistants\x27;SBase)
     (push.gloc.of core.unicode-assistants\x27;TCount)
     (push.iloc.0 . 1)
     (push.iloc.0 . 0)
     (push.gloc.of core.unicode-assistants\x27;VCount)
     (push.subr.gloc.of \x2E;* 2 "../stdlib/core/unicode-assistants.scm" . 250932)
     (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/unicode-assistants.scm" . 250922)
     (push.subr.gloc.of \x2E;* 2 "../stdlib/core/unicode-assistants.scm" . 250912)
     (ret.subr.gloc.of \x2E;+ "../stdlib/core/unicode-assistants.scm" . 250903))
   (call
     (push.const . -1)
     (push.iloc.0 . 2)
     (push.gloc.of core.unicode-assistants\x27;SCount)
     (subr.gloc.of \x2E;< 3 "../stdlib/core/unicode-assistants.scm" . 251932)
     (if.false.ret)
     (push.const . -1)
     (push.iloc.0 . 3)
     (push.gloc.of core.unicode-assistants\x27;TCount)
     (subr.gloc.of \x2E;< 3 "../stdlib/core/unicode-assistants.scm" . 251953)
     (if.false.ret)
     (push.const . 0)
     (call
       (push.iloc.0 . 2)
       (push.gloc.of core.unicode-assistants\x27;TCount)
       (apply.gloc.of \x2E;mod "../stdlib/core/unicode-assistants.scm" . 251979))
     (push)
     (ret.subr.gloc.of \x2E;= "../stdlib/core/unicode-assistants.scm" . 251974))
   (if.true
     (push.iloc.1 . 0)
     (push.iloc.0 . 3)
     (ret.subr.gloc.of \x2E;+ "../stdlib/core/unicode-assistants.scm" . 252951))
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;compose-table
       "../stdlib/core/unicode-assistants.scm"
       .
       255019))
   (push)
   (push.iloc.1 . 0)
   (push.const . 65536)
   (push.subr.gloc.of \x2E;* 2 "../stdlib/core/unicode-assistants.scm" . 255038)
   (push.iloc.1 . 1)
   (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/unicode-assistants.scm" . 255035)
   (push.const . #f)
   (ret.subr.gloc.of \x2E;core-hashtable-ref "../stdlib/core/unicode-assistants.scm" . 254999))
 (set.gloc.of core.unicode-assistants\x27;pair-wise-composition)
 (close
   (3 0 . core.unicode-assistants\x27;recursive-decomposition)
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;decompose-table
       "../stdlib/core/unicode-assistants.scm"
       .
       259110))
   (push)
   (push.iloc.0 . 1)
   (push.const . #f)
   (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/unicode-assistants.scm" . 259090)
   (extend . 1)
   (push.iloc.1 . 1)
   (push.gloc.of core.unicode-assistants\x27;SBase)
   (push.subr.gloc.of \x2E;- 2 "../stdlib/core/unicode-assistants.scm" . 260119)
   (extend . 1)
   (call
     (iloc.1 . 0)
     (if.false.ret)
     (call
       (iloc 2 . 0)
       (if.false.ret)
       (call
         (apply.gloc.of
           core.unicode-assistants\x27;compatibility-table
           "../stdlib/core/unicode-assistants.scm"
           .
           261187))
       (push)
       (push.iloc 2 . 1)
       (push.const . #f)
       (ret.subr.gloc.of \x2E;core-hashtable-ref "../stdlib/core/unicode-assistants.scm" . 261167))
     (push)
     (ret.subr.gloc.of \x2E;not "../stdlib/core/unicode-assistants.scm" . 261147))
   (if.true
     (push.close
       (1 0)
       (push.iloc 3 . 0)
       (push.iloc.0 . 0)
       (push.iloc 3 . 2)
       (apply.gloc.of
         core.unicode-assistants\x27;recursive-decomposition
         "../stdlib/core/unicode-assistants.scm"
         .
         262185))
     (push.iloc.1 . 0)
     (apply.gloc.of \x2E;for-each "../stdlib/core/unicode-assistants.scm" . 262162))
   (push.const . -1)
   (push.iloc.0 . 0)
   (push.gloc.of core.unicode-assistants\x27;SCount)
   (subr.gloc.of \x2E;< 3 "../stdlib/core/unicode-assistants.scm" . 263186)
   (if.true
     (push.gloc.of core.unicode-assistants\x27;VBase)
     (call
       (push.iloc.0 . 0)
       (push.gloc.of core.unicode-assistants\x27;NCount)
       (apply.gloc.of \x2E;mod "../stdlib/core/unicode-assistants.scm" . 265257))
     (push)
     (push.gloc.of core.unicode-assistants\x27;TCount)
     (push.subr.gloc.of \x2E;div 2 "../stdlib/core/unicode-assistants.scm" . 265252)
     (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/unicode-assistants.scm" . 265243)
     (push.gloc.of core.unicode-assistants\x27;TBase)
     (call
       (push.iloc.0 . 0)
       (push.gloc.of core.unicode-assistants\x27;TCount)
       (apply.gloc.of \x2E;mod "../stdlib/core/unicode-assistants.scm" . 266276))
     (push)
     (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/unicode-assistants.scm" . 266267)
     (extend . 2)
     (push.iloc 3 . 2)
     (push.gloc.of core.unicode-assistants\x27;LBase)
     (push.iloc.1 . 0)
     (push.gloc.of core.unicode-assistants\x27;NCount)
     (push.subr.gloc.of \x2E;div 2 "../stdlib/core/unicode-assistants.scm" . 264228)
     (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/unicode-assistants.scm" . 264219)
     (push.subr.gloc.of \x2E;integer->char 1 "../stdlib/core/unicode-assistants.scm" . 267301)
     (subr.gloc.of \x2E;put-char 2 "../stdlib/core/unicode-assistants.scm" . 267284)
     (push.iloc 3 . 2)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;integer->char 1 "../stdlib/core/unicode-assistants.scm" . 268325)
     (subr.gloc.of \x2E;put-char 2 "../stdlib/core/unicode-assistants.scm" . 268308)
     (gloc.of core.unicode-assistants\x27;TBase)
     (=.iloc (0 . 1) "../stdlib/core/unicode-assistants.scm" . 269336)
     (if.true.ret)
     (push.iloc 3 . 2)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;integer->char 1 "../stdlib/core/unicode-assistants.scm" . 269365)
     (ret.subr.gloc.of \x2E;put-char "../stdlib/core/unicode-assistants.scm" . 269348))
   (push.iloc 2 . 2)
   (push.iloc 2 . 1)
   (push.subr.gloc.of \x2E;integer->char 1 "../stdlib/core/unicode-assistants.scm" . 271395)
   (ret.subr.gloc.of \x2E;put-char "../stdlib/core/unicode-assistants.scm" . 271378))
 (set.gloc.of core.unicode-assistants\x27;recursive-decomposition)
 (close
   (2 0 . core.unicode-assistants\x27;decompose)
   (subr.gloc.of \x2E;make-string-output-port 0)
   (push)
   (extend . 1)
   (extend.enclose+
     (1 0 . loop)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;eof-object? 1 "../stdlib/core/unicode-assistants.scm" . 277522)
     (if.true
       (push.iloc 2 . 0)
       (push.subr.gloc.of
         \x2E;extract-accumulated-string
         1
         "../stdlib/core/unicode-assistants.scm"
         .
         278561)
       (subr.gloc.of \x2E;native-endianness 0)
       (push)
       (apply.gloc.of
         core.bytevector-transcoders\x27;string->utf32
         "../stdlib/core/unicode-assistants.scm"
         .
         278546))
     (call
       (push.iloc 3 . 1)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/unicode-assistants.scm" . 280629)
       (push.iloc 2 . 0)
       (apply.gloc.of
         core.unicode-assistants\x27;recursive-decomposition
         "../stdlib/core/unicode-assistants.scm"
         .
         280594))
     (push.iloc 3 . 0)
     (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode-assistants.scm" . 281624)
     (apply.iloc+ (1 . 0) "../stdlib/core/unicode-assistants.scm" . 281618))
   (push.iloc 2 . 0)
   (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode-assistants.scm" . 276504)
   (apply.iloc+ (0 . 0) "../stdlib/core/unicode-assistants.scm" . 277515))
 (set.gloc.of core.unicode-assistants\x27;decompose)
 (close
   (1 0 . core.unicode-assistants\x27;canonical-class)
   (call
     (apply.gloc.of
       core.unicode-assistants\x27;canonical-class-table
       "../stdlib/core/unicode-assistants.scm"
       .
       285723))
   (push)
   (push.iloc.0 . 0)
   (push.const . 0)
   (ret.subr.gloc.of \x2E;core-hashtable-ref "../stdlib/core/unicode-assistants.scm" . 285703))
 (set.gloc.of core.unicode-assistants\x27;canonical-class)
 (close
   (1 0 . core.unicode-assistants\x27;sort-combining-marks!)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;bytevector-length 1 "../stdlib/core/unicode-assistants.scm" . 289814)
   (push.const . 4)
   (push.subr.gloc.of \x2E;- 2 "../stdlib/core/unicode-assistants.scm" . 289811)
   (extend . 1)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (>=.iloc (2 . 0) "../stdlib/core/unicode-assistants.scm" . 291858)
     (if.true (ret.iloc 3 . 0))
     (push.iloc 3 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of
       \x2E;bytevector-u32-native-ref
       2
       "../stdlib/core/unicode-assistants.scm"
       .
       293918)
     (push.iloc 3 . 0)
     (push.n+.iloc (0 . 0) 4 "../stdlib/core/unicode-assistants.scm" . 294972)
     (push.subr.gloc.of
       \x2E;bytevector-u32-native-ref
       2
       "../stdlib/core/unicode-assistants.scm"
       .
       294942)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (apply.gloc.of
         core.unicode-assistants\x27;canonical-class
         "../stdlib/core/unicode-assistants.scm"
         .
         295971))
     (push)
     (call
       (push.iloc.0 . 1)
       (apply.gloc.of
         core.unicode-assistants\x27;canonical-class
         "../stdlib/core/unicode-assistants.scm"
         .
         296995))
     (push)
     (extend . 2)
     (call
       (>n.iloc (0 . 0) 0 "../stdlib/core/unicode-assistants.scm" . 298018)
       (if.false.ret)
       (>n.iloc (0 . 1) 0 "../stdlib/core/unicode-assistants.scm" . 298032)
       (if.false.ret)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of \x2E;> "../stdlib/core/unicode-assistants.scm" . 298046))
     (if.true
       (push.iloc 5 . 0)
       (push.iloc 2 . 0)
       (push.iloc.1 . 1)
       (subr.gloc.of
         \x2E;bytevector-u32-native-set!
         3
         "../stdlib/core/unicode-assistants.scm"
         .
         299037)
       (push.iloc 5 . 0)
       (push.n+.iloc (2 . 0) 4 "../stdlib/core/unicode-assistants.scm" . 300092)
       (push.iloc.1 . 0)
       (subr.gloc.of
         \x2E;bytevector-u32-native-set!
         3
         "../stdlib/core/unicode-assistants.scm"
         .
         300061)
       (call
         (>=n.iloc (2 . 0) 4 "../stdlib/core/unicode-assistants.scm" . 301095)
         (if.true
           (push.iloc 2 . 0)
           (push.const . 4)
           (ret.subr.gloc.of \x2E;- "../stdlib/core/unicode-assistants.scm" . 301104))
         (ret.const . 4))
       (push)
       (apply.iloc+ (3 . 0) "../stdlib/core/unicode-assistants.scm" . 301085))
     (push.n+.iloc (2 . 0) 4 "../stdlib/core/unicode-assistants.scm" . 303139)
     (apply.iloc+ (3 . 0) "../stdlib/core/unicode-assistants.scm" . 303133))
   (push.const . 0)
   (apply.iloc+ (0 . 0) "../stdlib/core/unicode-assistants.scm" . 291851))
 (set.gloc.of core.unicode-assistants\x27;sort-combining-marks!)
 (close
   (1 0 . core.unicode-assistants\x27;compose)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;bytevector-length 1 "../stdlib/core/unicode-assistants.scm" . 307218)
   (extend . 1)
   (push.iloc.1 . 0)
   (push.const . 0)
   (push.subr.gloc.of
     \x2E;bytevector-u32-native-ref
     2
     "../stdlib/core/unicode-assistants.scm"
     .
     308247)
   (extend . 1)
   (extend.enclose+
     (5 0 . loop)
     (iloc.0 . 0)
     (>=.iloc (3 . 0) "../stdlib/core/unicode-assistants.scm" . 311316)
     (if.true
       (push.iloc.0 . 4)
       (push.subr.gloc.of \x2E;make-bytevector 1 "../stdlib/core/unicode-assistants.scm" . 312354)
       (extend . 1)
       (push.iloc 5 . 0)
       (push.const . 0)
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.iloc.1 . 4)
       (subr.gloc.of \x2E;bytevector-copy! 5 "../stdlib/core/unicode-assistants.scm" . 313366)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;native-endianness 0)
       (push)
       (push.const . #t)
       (apply.gloc.of
         core.bytevector-transcoders\x27;utf32->string
         "../stdlib/core/unicode-assistants.scm"
         .
         314390))
     (push.iloc 4 . 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of
       \x2E;bytevector-u32-native-ref
       2
       "../stdlib/core/unicode-assistants.scm"
       .
       316449)
     (extend . 1)
     (call
       (push.iloc.0 . 0)
       (apply.gloc.of
         core.unicode-assistants\x27;canonical-class
         "../stdlib/core/unicode-assistants.scm"
         .
         317476))
     (push)
     (extend . 1)
     (call
       (call
         (=n.iloc (2 . 2) 0 "../stdlib/core/unicode-assistants.scm" . 318502)
         (if.true.ret)
         (push.iloc 2 . 2)
         (push.iloc.0 . 0)
         (ret.subr.gloc.of \x2E;< "../stdlib/core/unicode-assistants.scm" . 318519))
       (if.false.ret)
       (push.iloc 2 . 1)
       (push.iloc.1 . 0)
       (apply.gloc.of
         core.unicode-assistants\x27;pair-wise-composition
         "../stdlib/core/unicode-assistants.scm"
         .
         319522))
     (push)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.iloc 7 . 0)
       (push.iloc 3 . 3)
       (push.iloc.0 . 0)
       (subr.gloc.of
         \x2E;bytevector-u32-native-set!
         3
         "../stdlib/core/unicode-assistants.scm"
         .
         321570)
       (push.n+.iloc (3 . 0) 4 "../stdlib/core/unicode-assistants.scm" . 322600)
       (push.iloc.0 . 0)
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of
           core.unicode-assistants\x27;canonical-class
           "../stdlib/core/unicode-assistants.scm"
           .
           322617))
       (push)
       (push.iloc 3 . 3)
       (push.iloc 3 . 4)
       (apply.iloc+ (4 . 0) "../stdlib/core/unicode-assistants.scm" . 322594))
     (push.iloc 7 . 0)
     (push.iloc 3 . 4)
     (push.iloc 2 . 0)
     (subr.gloc.of
       \x2E;bytevector-u32-native-set!
       3
       "../stdlib/core/unicode-assistants.scm"
       .
       324637)
     (=n.iloc (1 . 0) 0 "../stdlib/core/unicode-assistants.scm" . 325665)
     (if.true
       (push.n+.iloc (3 . 0) 4 "../stdlib/core/unicode-assistants.scm" . 326695)
       (push.iloc 2 . 0)
       (push.iloc.1 . 0)
       (push.iloc 3 . 4)
       (push.n+.iloc (3 . 4) 4 "../stdlib/core/unicode-assistants.scm" . 326725)
       (apply.iloc+ (4 . 0) "../stdlib/core/unicode-assistants.scm" . 326689))
     (push.n+.iloc (3 . 0) 4 "../stdlib/core/unicode-assistants.scm" . 327719)
     (push.iloc 3 . 1)
     (push.iloc.1 . 0)
     (push.iloc 3 . 3)
     (push.n+.iloc (3 . 4) 4 "../stdlib/core/unicode-assistants.scm" . 327755)
     (apply.iloc+ (4 . 0) "../stdlib/core/unicode-assistants.scm" . 327713))
   (push.const . 4)
   (push.iloc.1 . 0)
   (call
     (call
       (push.iloc.1 . 0)
       (apply.gloc.of
         core.unicode-assistants\x27;canonical-class
         "../stdlib/core/unicode-assistants.scm"
         .
         309285))
     (push)
     (subr.gloc.of \x2E;zero? 1 "../stdlib/core/unicode-assistants.scm" . 309278)
     (if.true (ret.const . 0))
     (ret.const . 256))
   (push)
   (push.const . 0)
   (push.const . 4)
   (apply.iloc+ (0 . 0) "../stdlib/core/unicode-assistants.scm" . 311309))
 (set.gloc.of core.unicode-assistants\x27;compose)
 (call
   (push.const . syntax)
   (push.const . core.unicode-assistants\x27;autoload)
   (push.const
     ()
     ("../stdlib/core/unicode-assistants.scm" . 55301)
     ((_ var init)
      (begin
        (define temp (make-parameter #f))
        (define var
          (lambda ()
            (if (on-primordial-thread?)
                (let ((value init)) (set! var (lambda () value)) value)
                (or (temp) (let ((value init)) (temp value) value))))))
      ((init . 0) (var . 0))
      (or set! value let on-primordial-thread? if lambda make-parameter temp define begin)))
   (push.const
     (make-parameter import . \x2E;make-parameter)
     (lambda import . \x2E;lambda)
     (temp unbound)
     (if import . \x2E;if)
     (or import . \x2E;or)
     (_ import . \x2E;_)
     (autoload import . core.unicode-assistants\x27;autoload)
     (define import . \x2E;define)
     (value unbound)
     (let import . \x2E;let)
     (begin import . \x2E;begin)
     (var unbound)
     (on-primordial-thread? import . \x2E;on-primordial-thread?)
     (init unbound)
     (set! import . \x2E;set!))
   (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/unicode-assistants.scm" . 51211))
 (push.const . core.unicode-assistants)
 (push.const . #f)
 (push.const
   (general-category import . core.unicode-assistants\x27;general-category)
   (simple-uppercase import . core.unicode-assistants\x27;simple-uppercase)
   (simple-lowercase import . core.unicode-assistants\x27;simple-lowercase)
   (simple-titlecase import . core.unicode-assistants\x27;simple-titlecase)
   (numeric-property? import . core.unicode-assistants\x27;numeric-property?)
   (other-uppercase-property? import . core.unicode-assistants\x27;other-uppercase-property?)
   (other-lowercase-property? import . core.unicode-assistants\x27;other-lowercase-property?)
   (other-alphabetic-property? import . core.unicode-assistants\x27;other-alphabetic-property?)
   (special-casing-lower import . core.unicode-assistants\x27;special-casing-lower)
   (special-casing-title import . core.unicode-assistants\x27;special-casing-title)
   (special-casing-upper import . core.unicode-assistants\x27;special-casing-upper)
   (foldcase import . core.unicode-assistants\x27;foldcase)
   (pair-wise-composition import . core.unicode-assistants\x27;pair-wise-composition)
   (recursive-decomposition import . core.unicode-assistants\x27;recursive-decomposition)
   (decompose import . core.unicode-assistants\x27;decompose)
   (sort-combining-marks! import . core.unicode-assistants\x27;sort-combining-marks!)
   (compose import . core.unicode-assistants\x27;compose))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/unicode-assistants.scm" . 51211))

((call
   (push.const core bytevector-transcoders)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/unicode.scm" . 6145))
 (call
   (push.const core bytevectors)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/unicode.scm" . 6145))
 (call
   (push.const core unicode-assistants)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/unicode.scm" . 6145))
 (call
   (push.const core io)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/unicode.scm" . 6145))
 (call
   (push.const core lists)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/unicode.scm" . 6145))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/unicode.scm" . 6145))
 (close
   (1 0 . core.unicode\x27;char-upcase)
   (push.iloc.0 . 0)
   (push.const . #\a)
   (subr.gloc.of \x2E;char<? 2 "../stdlib/core/unicode.scm" . 48142)
   (if.true (ret.iloc 0 . 0))
   (push.iloc.0 . 0)
   (push.const . #\z)
   (subr.gloc.of \x2E;char>? 2 "../stdlib/core/unicode.scm" . 49166)
   (if.true
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;simple-uppercase
       "../stdlib/core/unicode.scm"
       .
       50190))
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/unicode.scm" . 52256)
   (push.const . 32)
   (push.subr.gloc.of \x2E;- 2 "../stdlib/core/unicode.scm" . 52253)
   (ret.subr.gloc.of \x2E;integer->char "../stdlib/core/unicode.scm" . 52238))
 (set.gloc.of core.unicode\x27;char-upcase)
 (close
   (1 0 . core.unicode\x27;char-downcase)
   (push.iloc.0 . 0)
   (push.const . #\A)
   (subr.gloc.of \x2E;char<? 2 "../stdlib/core/unicode.scm" . 56334)
   (if.true (ret.iloc 0 . 0))
   (push.iloc.0 . 0)
   (push.const . #\Z)
   (subr.gloc.of \x2E;char<=? 2 "../stdlib/core/unicode.scm" . 57358)
   (if.true
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;char->integer 1 "../stdlib/core/unicode.scm" . 58400)
     (push.const . 32)
     (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/unicode.scm" . 58397)
     (ret.subr.gloc.of \x2E;integer->char "../stdlib/core/unicode.scm" . 58382))
   (push.iloc.0 . 0)
   (push.const . #\z)
   (subr.gloc.of \x2E;char>? 2 "../stdlib/core/unicode.scm" . 59406)
   (if.true
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;simple-lowercase
       "../stdlib/core/unicode.scm"
       .
       60430))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode\x27;char-downcase)
 (close
   (1 0 . core.unicode\x27;char-titlecase)
   (push.iloc.0 . 0)
   (apply.gloc.of
     core.unicode-assistants\x27;simple-titlecase
     "../stdlib/core/unicode.scm"
     .
     65543))
 (set.gloc.of core.unicode\x27;char-titlecase)
 (close
   (1 0 . core.unicode\x27;char-foldcase)
   (push.iloc.0 . 0)
   (push.const . #\z)
   (subr.gloc.of \x2E;char<=? 2 "../stdlib/core/unicode.scm" . 69646)
   (if.true
     (push.iloc.0 . 0)
     (apply.gloc.of core.unicode\x27;char-downcase "../stdlib/core/unicode.scm" . 70670))
   (call
     (push.iloc.0 . 0)
     (push.const . #\)
     (subr.gloc.of \x2E;char=? 2 "../stdlib/core/unicode.scm" . 71698)
     (if.true.ret)
     (push.iloc.0 . 0)
     (push.const . #\)
     (ret.subr.gloc.of \x2E;char=? "../stdlib/core/unicode.scm" . 72722))
   (if.true (ret.iloc 0 . 0))
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.unicode\x27;char-upcase "../stdlib/core/unicode.scm" . 75805))
   (push)
   (apply.gloc.of core.unicode\x27;char-downcase "../stdlib/core/unicode.scm" . 75790))
 (set.gloc.of core.unicode\x27;char-foldcase)
 (close
   (0 1 . core.unicode\x27;char-ci=?)
   (push.gloc.of \x2E;char=?)
   (call
     (push.gloc.of core.unicode\x27;char-foldcase)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;map "../stdlib/core/unicode.scm" . 77871))
   (push)
   (apply.gloc.of \x2E;apply "../stdlib/core/unicode.scm" . 77857))
 (set.gloc.of core.unicode\x27;char-ci=?)
 (close
   (0 1 . core.unicode\x27;char-ci<?)
   (push.gloc.of \x2E;char<?)
   (call
     (push.gloc.of core.unicode\x27;char-foldcase)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;map "../stdlib/core/unicode.scm" . 78895))
   (push)
   (apply.gloc.of \x2E;apply "../stdlib/core/unicode.scm" . 78881))
 (set.gloc.of core.unicode\x27;char-ci<?)
 (close
   (0 1 . core.unicode\x27;char-ci>?)
   (push.gloc.of \x2E;char>?)
   (call
     (push.gloc.of core.unicode\x27;char-foldcase)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;map "../stdlib/core/unicode.scm" . 79919))
   (push)
   (apply.gloc.of \x2E;apply "../stdlib/core/unicode.scm" . 79905))
 (set.gloc.of core.unicode\x27;char-ci>?)
 (close
   (0 1 . core.unicode\x27;char-ci<=?)
   (push.gloc.of \x2E;char<=?)
   (call
     (push.gloc.of core.unicode\x27;char-foldcase)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;map "../stdlib/core/unicode.scm" . 80945))
   (push)
   (apply.gloc.of \x2E;apply "../stdlib/core/unicode.scm" . 80930))
 (set.gloc.of core.unicode\x27;char-ci<=?)
 (close
   (0 1 . core.unicode\x27;char-ci>=?)
   (push.gloc.of \x2E;char>=?)
   (call
     (push.gloc.of core.unicode\x27;char-foldcase)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;map "../stdlib/core/unicode.scm" . 81969))
   (push)
   (apply.gloc.of \x2E;apply "../stdlib/core/unicode.scm" . 81954))
 (set.gloc.of core.unicode\x27;char-ci>=?)
 (close
   (1 0 . core.unicode\x27;char-alphabetic?)
   (call
     (push.const . #\a)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;char<=? 2 "../stdlib/core/unicode.scm" . 86032)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const . #\z)
     (ret.subr.gloc.of \x2E;char<=? "../stdlib/core/unicode.scm" . 86049))
   (if.true.ret)
   (call
     (push.const . #\A)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;char<=? 2 "../stdlib/core/unicode.scm" . 87056)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const . #\Z)
     (ret.subr.gloc.of \x2E;char<=? "../stdlib/core/unicode.scm" . 87073))
   (if.true.ret)
   (push.const . #\)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;char<=? 2 "../stdlib/core/unicode.scm" . 88080)
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;general-category
       "../stdlib/core/unicode.scm"
       .
       89110))
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const Lu Ll Lt Lm Lo Nl)
   (subr.gloc.of \x2E;memq 2 "../stdlib/core/unicode.scm" . 90131)
   (if.true.ret.const . #t)
   (push.iloc.0 . 0)
   (push.const Mn Mc So)
   (subr.gloc.of \x2E;memq 2 "../stdlib/core/unicode.scm" . 90131)
   (if.false.ret)
   (push.iloc.1 . 0)
   (apply.gloc.of
     core.unicode-assistants\x27;other-alphabetic-property?
     "../stdlib/core/unicode.scm"
     .
     92179))
 (set.gloc.of core.unicode\x27;char-alphabetic?)
 (close
   (1 0 . core.unicode\x27;char-numeric?)
   (call
     (push.const . #\0)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;char<=? 2 "../stdlib/core/unicode.scm" . 97296)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const . #\9)
     (ret.subr.gloc.of \x2E;char<=? "../stdlib/core/unicode.scm" . 97313))
   (if.true.ret)
   (push.const . #\)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;char<=? 2 "../stdlib/core/unicode.scm" . 98320)
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;general-category
       "../stdlib/core/unicode.scm"
       .
       99349))
   (push)
   (const . Nd)
   (ret.eq? "../stdlib/core/unicode.scm" . 99344))
 (set.gloc.of core.unicode\x27;char-numeric?)
 (close
   (1 0 . core.unicode\x27;char-upper-case?)
   (call
     (push.const . #\A)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;char<=? 2 "../stdlib/core/unicode.scm" . 103440)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const . #\Z)
     (ret.subr.gloc.of \x2E;char<=? "../stdlib/core/unicode.scm" . 103457))
   (if.true.ret)
   (push.const . #\)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;char<=? 2 "../stdlib/core/unicode.scm" . 104464)
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;general-category
       "../stdlib/core/unicode.scm"
       .
       105494))
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . Lu)
   (if.eq?.ret.const . #t)
   (push.iloc.0 . 0)
   (push.const Nl So)
   (subr.gloc.of \x2E;memq 2 "../stdlib/core/unicode.scm" . 107539)
   (if.false.ret)
   (push.iloc.1 . 0)
   (apply.gloc.of
     core.unicode-assistants\x27;other-uppercase-property?
     "../stdlib/core/unicode.scm"
     .
     108563))
 (set.gloc.of core.unicode\x27;char-upper-case?)
 (close
   (1 0 . core.unicode\x27;char-lower-case?)
   (call
     (push.const . #\a)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;char<=? 2 "../stdlib/core/unicode.scm" . 113680)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.const . #\z)
     (ret.subr.gloc.of \x2E;char<=? "../stdlib/core/unicode.scm" . 113697))
   (if.true.ret)
   (push.const . #\)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;char<=? 2 "../stdlib/core/unicode.scm" . 114704)
   (if.false.ret)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;general-category
       "../stdlib/core/unicode.scm"
       .
       115734))
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (const . Ll)
   (if.eq?.ret.const . #t)
   (push.iloc.0 . 0)
   (push.const Lm Mn Nl So)
   (subr.gloc.of \x2E;memq 2 "../stdlib/core/unicode.scm" . 117779)
   (if.false.ret)
   (push.iloc.1 . 0)
   (apply.gloc.of
     core.unicode-assistants\x27;other-lowercase-property?
     "../stdlib/core/unicode.scm"
     .
     118803))
 (set.gloc.of core.unicode\x27;char-lower-case?)
 (close
   (1 0 . core.unicode\x27;char-title-case?)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;general-category
       "../stdlib/core/unicode.scm"
       .
       123916))
   (push)
   (const . Lt)
   (ret.eq? "../stdlib/core/unicode.scm" . 123911))
 (set.gloc.of core.unicode\x27;char-title-case?)
 (close
   (1 0 . core.unicode\x27;char-general-category)
   (push.iloc.0 . 0)
   (apply.gloc.of
     core.unicode-assistants\x27;general-category
     "../stdlib/core/unicode.scm"
     .
     128007))
 (set.gloc.of core.unicode\x27;char-general-category)
 (close
   (1 0 . core.unicode\x27;string-upcase)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.io\x27;open-string-input-port "../stdlib/core/unicode.scm" . 132116))
   (push)
   (subr.gloc.of \x2E;make-string-output-port 0)
   (push)
   (extend . 2)
   (call
     (extend.enclose+
       (1 0 . loop)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;eof-object? 1 "../stdlib/core/unicode.scm" . 136217)
       (if.true
         (push.iloc 2 . 1)
         (ret.subr.gloc.of \x2E;extract-accumulated-string "../stdlib/core/unicode.scm" . 136234))
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of
           core.unicode-assistants\x27;special-casing-upper
           "../stdlib/core/unicode.scm"
           .
           137241))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (call
           (push.close
             (1 0)
             (push.iloc 4 . 1)
             (call
               (push.iloc.0 . 0)
               (push.subr.gloc.of \x2E;integer->char 1 "../stdlib/core/unicode.scm" . 139346)
               (apply.gloc.of core.unicode\x27;char-upcase "../stdlib/core/unicode.scm" . 139333))
             (push)
             (ret.subr.gloc.of \x2E;put-char "../stdlib/core/unicode.scm" . 139316))
           (push.iloc.0 . 0)
           (apply.gloc.of \x2E;for-each "../stdlib/core/unicode.scm" . 139294))
         (push.iloc 3 . 0)
         (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 140324)
         (apply.iloc+ (2 . 0) "../stdlib/core/unicode.scm" . 140318))
       (push.iloc 3 . 1)
       (call
         (push.iloc.1 . 0)
         (apply.gloc.of core.unicode\x27;char-upcase "../stdlib/core/unicode.scm" . 142378))
       (push)
       (subr.gloc.of \x2E;put-char 2 "../stdlib/core/unicode.scm" . 142361)
       (push.iloc 3 . 0)
       (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 143391)
       (apply.iloc+ (2 . 0) "../stdlib/core/unicode.scm" . 143385))
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 135199)
     (apply.iloc+ (0 . 0) "../stdlib/core/unicode.scm" . 136210))
   (push)
   (extend . 1)
   (push.iloc 2 . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;string=? 2 "../stdlib/core/unicode.scm" . 144399)
   (if.true (ret.iloc 2 . 0))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode\x27;string-upcase)
 (close
   (2 0 . core.unicode\x27;final-sigma?)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;lookahead-char 1 "../stdlib/core/unicode.scm" . 148497)
   (extend . 1)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;eof-object? 1 "../stdlib/core/unicode.scm" . 149520)
   (if.true
     (push.iloc.1 . 1)
     (push.subr.gloc.of \x2E;port-position 1 "../stdlib/core/unicode.scm" . 150552)
     (push.const . 0)
     (push.subr.gloc.of \x2E;= 2 "../stdlib/core/unicode.scm" . 150549)
     (ret.subr.gloc.of \x2E;not "../stdlib/core/unicode.scm" . 150544))
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.unicode\x27;char-alphabetic? "../stdlib/core/unicode.scm" . 151568))
   (if.true.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;char-whitespace? 1 "../stdlib/core/unicode.scm" . 152592)
   (if.true.ret.const . #t)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.unicode-assistants\x27;general-category
       "../stdlib/core/unicode.scm"
       .
       153621))
   (push)
   (const . Pd)
   (if.eq?.ret.const . #t)
   (push.iloc.1 . 0)
   (push.subr.gloc.of \x2E;port-position 1 "../stdlib/core/unicode.scm" . 155675)
   (extend . 1)
   (push.iloc 2 . 0)
   (subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 156690)
   (call
     (extend.enclose+
       (1 0 . loop)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;eof-object? 1 "../stdlib/core/unicode.scm" . 159778)
       (if.true
         (push.iloc 4 . 1)
         (push.subr.gloc.of \x2E;port-position 1 "../stdlib/core/unicode.scm" . 160810)
         (push.const . 0)
         (push.subr.gloc.of \x2E;= 2 "../stdlib/core/unicode.scm" . 160807)
         (ret.subr.gloc.of \x2E;not "../stdlib/core/unicode.scm" . 160802))
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of core.unicode\x27;char-alphabetic? "../stdlib/core/unicode.scm" . 161826))
       (if.true.ret.const . #f)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;char-whitespace? 1 "../stdlib/core/unicode.scm" . 162850)
       (if.true.ret.const . #t)
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of
           core.unicode-assistants\x27;general-category
           "../stdlib/core/unicode.scm"
           .
           163879))
       (push)
       (const . Pd)
       (if.eq?.ret.const . #t)
       (push.iloc 4 . 0)
       (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 165928)
       (apply.iloc+ (1 . 0) "../stdlib/core/unicode.scm" . 165922))
     (push.iloc 3 . 0)
     (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 158760)
     (apply.iloc+ (0 . 0) "../stdlib/core/unicode.scm" . 159771))
   (push)
   (extend . 1)
   (push.iloc 3 . 0)
   (push.iloc.1 . 0)
   (subr.gloc.of \x2E;set-port-position! 2 "../stdlib/core/unicode.scm" . 166932)
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode\x27;final-sigma?)
 (close
   (1 0 . core.unicode\x27;string-downcase)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.io\x27;open-string-input-port "../stdlib/core/unicode.scm" . 172052))
   (push)
   (subr.gloc.of \x2E;make-string-output-port 0)
   (push)
   (extend . 2)
   (call
     (extend.enclose+
       (2 0 . loop)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;eof-object? 1 "../stdlib/core/unicode.scm" . 176153)
       (if.true
         (push.iloc 2 . 1)
         (ret.subr.gloc.of \x2E;extract-accumulated-string "../stdlib/core/unicode.scm" . 176170))
       (push.iloc.0 . 0)
       (push.const . #\)
       (subr.gloc.of \x2E;char=? 2 "../stdlib/core/unicode.scm" . 177177)
       (if.true
         (push.iloc.0 . 1)
         (subr.gloc.of \x2E;char-whitespace? 1 "../stdlib/core/unicode.scm" . 178208)
         (if.true
           (push.iloc 2 . 1)
           (push.const . #\)
           (subr.gloc.of \x2E;put-char 2 "../stdlib/core/unicode.scm" . 179232)
           (push.iloc 2 . 0)
           (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 180262)
           (push.iloc.0 . 0)
           (apply.iloc+ (1 . 0) "../stdlib/core/unicode.scm" . 180256))
         (call
           (call
             (push.iloc 2 . 0)
             (push.iloc 2 . 1)
             (apply.gloc.of core.unicode\x27;final-sigma? "../stdlib/core/unicode.scm" . 182308))
           (if.true
             (push.iloc 2 . 1)
             (push.const . #\)
             (ret.subr.gloc.of \x2E;put-char "../stdlib/core/unicode.scm" . 183332))
           (push.iloc 2 . 1)
           (push.const . #\)
           (ret.subr.gloc.of \x2E;put-char "../stdlib/core/unicode.scm" . 184356))
         (push.iloc 2 . 0)
         (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 185382)
         (push.iloc.0 . 0)
         (apply.iloc+ (1 . 0) "../stdlib/core/unicode.scm" . 185376))
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of
           core.unicode-assistants\x27;special-casing-lower
           "../stdlib/core/unicode.scm"
           .
           186393))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (call
           (push.close
             (1 0)
             (push.iloc 4 . 1)
             (call
               (push.iloc.0 . 0)
               (push.subr.gloc.of \x2E;integer->char 1 "../stdlib/core/unicode.scm" . 188500)
               (apply.gloc.of core.unicode\x27;char-downcase "../stdlib/core/unicode.scm" . 188485))
             (push)
             (ret.subr.gloc.of \x2E;put-char "../stdlib/core/unicode.scm" . 188468))
           (push.iloc.0 . 0)
           (apply.gloc.of \x2E;for-each "../stdlib/core/unicode.scm" . 188446))
         (push.iloc 3 . 0)
         (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 189476)
         (push.iloc.1 . 0)
         (apply.iloc+ (2 . 0) "../stdlib/core/unicode.scm" . 189470))
       (push.iloc 3 . 1)
       (call
         (push.iloc.1 . 0)
         (apply.gloc.of core.unicode\x27;char-downcase "../stdlib/core/unicode.scm" . 191530))
       (push)
       (subr.gloc.of \x2E;put-char 2 "../stdlib/core/unicode.scm" . 191513)
       (push.iloc 3 . 0)
       (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 192543)
       (push.iloc.1 . 0)
       (apply.iloc+ (2 . 0) "../stdlib/core/unicode.scm" . 192537))
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 175135)
     (push.const . #\space)
     (apply.iloc+ (0 . 0) "../stdlib/core/unicode.scm" . 176146))
   (push)
   (extend . 1)
   (push.iloc 2 . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;string=? 2 "../stdlib/core/unicode.scm" . 193551)
   (if.true (ret.iloc 2 . 0))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode\x27;string-downcase)
 (close
   (1 0 . core.unicode\x27;string-foldcase)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.io\x27;open-string-input-port "../stdlib/core/unicode.scm" . 197652))
   (push)
   (subr.gloc.of \x2E;make-string-output-port 0)
   (push)
   (extend . 2)
   (call
     (extend.enclose+
       (1 0 . loop)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;eof-object? 1 "../stdlib/core/unicode.scm" . 201753)
       (if.true
         (push.iloc 2 . 1)
         (ret.subr.gloc.of \x2E;extract-accumulated-string "../stdlib/core/unicode.scm" . 201770))
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of core.unicode-assistants\x27;foldcase "../stdlib/core/unicode.scm" . 202777))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (call
           (push.close
             (1 0)
             (push.iloc 4 . 1)
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;integer->char 1 "../stdlib/core/unicode.scm" . 204869)
             (ret.subr.gloc.of \x2E;put-char "../stdlib/core/unicode.scm" . 204852))
           (push.iloc.0 . 0)
           (apply.gloc.of \x2E;for-each "../stdlib/core/unicode.scm" . 204830))
         (push.iloc 3 . 0)
         (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 205860)
         (apply.iloc+ (2 . 0) "../stdlib/core/unicode.scm" . 205854))
       (push.iloc 3 . 1)
       (push.iloc.1 . 0)
       (subr.gloc.of \x2E;put-char 2 "../stdlib/core/unicode.scm" . 207897)
       (push.iloc 3 . 0)
       (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 208927)
       (apply.iloc+ (2 . 0) "../stdlib/core/unicode.scm" . 208921))
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 200735)
     (apply.iloc+ (0 . 0) "../stdlib/core/unicode.scm" . 201746))
   (push)
   (extend . 1)
   (push.iloc 2 . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;string=? 2 "../stdlib/core/unicode.scm" . 209935)
   (if.true (ret.iloc 2 . 0))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode\x27;string-foldcase)
 (close
   (1 0 . core.unicode\x27;string-titlecase)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.io\x27;open-string-input-port "../stdlib/core/unicode.scm" . 214036))
   (push)
   (subr.gloc.of \x2E;make-string-output-port 0)
   (push)
   (extend . 2)
   (extend.unbound . 2)
   (push.close
     (0 0 . titlecase-first-char)
     (extend.enclose+
       (1 0 . loop)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;eof-object? 1 "../stdlib/core/unicode.scm" . 219166)
       (if.true
         (push.iloc 4 . 1)
         (ret.subr.gloc.of \x2E;extract-accumulated-string "../stdlib/core/unicode.scm" . 220190))
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of
           core.unicode-assistants\x27;general-category
           "../stdlib/core/unicode.scm"
           .
           222244))
       (push)
       (push.const Ll Lu Lt)
       (subr.gloc.of \x2E;memq 2 "../stdlib/core/unicode.scm" . 223265)
       (if.true
         (push.iloc 4 . 1)
         (call
           (push.iloc.0 . 0)
           (apply.gloc.of core.unicode\x27;char-titlecase "../stdlib/core/unicode.scm" . 224306))
         (push)
         (subr.gloc.of \x2E;put-char 2 "../stdlib/core/unicode.scm" . 224289)
         (apply.iloc (3 . 1) "../stdlib/core/unicode.scm" . 225313))
       (push.iloc 4 . 1)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;put-char 2 "../stdlib/core/unicode.scm" . 227361)
       (push.iloc 4 . 0)
       (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 228391)
       (apply.iloc+ (1 . 0) "../stdlib/core/unicode.scm" . 228385))
     (push.iloc 3 . 0)
     (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 218148)
     (apply.iloc+ (0 . 0) "../stdlib/core/unicode.scm" . 219159))
   (push.close
     (0 0 . downcase-subsequence)
     (extend.enclose+
       (1 0 . loop)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;eof-object? 1 "../stdlib/core/unicode.scm" . 232478)
       (if.true
         (push.iloc 4 . 1)
         (ret.subr.gloc.of \x2E;extract-accumulated-string "../stdlib/core/unicode.scm" . 233502))
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of
           core.unicode-assistants\x27;general-category
           "../stdlib/core/unicode.scm"
           .
           235556))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (push.const Ll Lu Lt)
       (subr.gloc.of \x2E;memq 2 "../stdlib/core/unicode.scm" . 236577)
       (if.true
         (push.iloc 5 . 1)
         (call
           (push.iloc.1 . 0)
           (apply.gloc.of core.unicode\x27;char-downcase "../stdlib/core/unicode.scm" . 237618))
         (push)
         (subr.gloc.of \x2E;put-char 2 "../stdlib/core/unicode.scm" . 237601)
         (push.iloc 5 . 0)
         (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 238631)
         (apply.iloc+ (2 . 0) "../stdlib/core/unicode.scm" . 238625))
       (push.iloc.0 . 0)
       (push.const Po Pf)
       (subr.gloc.of \x2E;memq 2 "../stdlib/core/unicode.scm" . 236577)
       (if.true
         (push.iloc.1 . 0)
         (push.const #\' #\: #\ #\ #\ #\)
         (subr.gloc.of \x2E;memq 2 "../stdlib/core/unicode.scm" . 241700)
         (if.true
           (push.iloc 5 . 1)
           (push.iloc.1 . 0)
           (subr.gloc.of \x2E;put-char 2 "../stdlib/core/unicode.scm" . 248868)
           (push.iloc 5 . 0)
           (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 249898)
           (apply.iloc+ (2 . 0) "../stdlib/core/unicode.scm" . 249892))
         (push.iloc 5 . 1)
         (push.iloc.1 . 0)
         (subr.gloc.of \x2E;put-char 2 "../stdlib/core/unicode.scm" . 251940)
         (apply.iloc (4 . 0) "../stdlib/core/unicode.scm" . 252964))
       (push.iloc.0 . 0)
       (const . Nd)
       (if.eq?
         (push.iloc 5 . 1)
         (push.iloc.1 . 0)
         (subr.gloc.of \x2E;put-char 2 "../stdlib/core/unicode.scm" . 255009)
         (push.iloc 5 . 0)
         (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 256039)
         (apply.iloc+ (2 . 0) "../stdlib/core/unicode.scm" . 256033))
       (push.iloc 5 . 1)
       (push.iloc.1 . 0)
       (subr.gloc.of \x2E;put-char 2 "../stdlib/core/unicode.scm" . 258081)
       (apply.iloc (4 . 0) "../stdlib/core/unicode.scm" . 259105))
     (push.iloc 3 . 0)
     (push.subr.gloc.of \x2E;get-char 1 "../stdlib/core/unicode.scm" . 231460)
     (apply.iloc+ (0 . 0) "../stdlib/core/unicode.scm" . 232471))
   (enclose . 2)
   (call (apply.iloc (0 . 0) "../stdlib/core/unicode.scm" . 260118))
   (push)
   (extend . 1)
   (push.iloc 3 . 0)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;string=? 2 "../stdlib/core/unicode.scm" . 261137)
   (if.true (ret.iloc 3 . 0))
   (ret.iloc 0 . 0))
 (set.gloc.of core.unicode\x27;string-titlecase)
 (close
   (0 1 . core.unicode\x27;string-ci=?)
   (push.gloc.of \x2E;string=?)
   (call
     (push.gloc.of core.unicode\x27;string-foldcase)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;map "../stdlib/core/unicode.scm" . 265239))
   (push)
   (apply.gloc.of \x2E;apply "../stdlib/core/unicode.scm" . 265223))
 (set.gloc.of core.unicode\x27;string-ci=?)
 (close
   (0 1 . core.unicode\x27;string-ci<?)
   (push.gloc.of \x2E;string<?)
   (call
     (push.gloc.of core.unicode\x27;string-foldcase)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;map "../stdlib/core/unicode.scm" . 269335))
   (push)
   (apply.gloc.of \x2E;apply "../stdlib/core/unicode.scm" . 269319))
 (set.gloc.of core.unicode\x27;string-ci<?)
 (close
   (0 1 . core.unicode\x27;string-ci>?)
   (push.gloc.of \x2E;string>?)
   (call
     (push.gloc.of core.unicode\x27;string-foldcase)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;map "../stdlib/core/unicode.scm" . 273431))
   (push)
   (apply.gloc.of \x2E;apply "../stdlib/core/unicode.scm" . 273415))
 (set.gloc.of core.unicode\x27;string-ci>?)
 (close
   (0 1 . core.unicode\x27;string-ci<=?)
   (push.gloc.of \x2E;string<=?)
   (call
     (push.gloc.of core.unicode\x27;string-foldcase)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;map "../stdlib/core/unicode.scm" . 277528))
   (push)
   (apply.gloc.of \x2E;apply "../stdlib/core/unicode.scm" . 277511))
 (set.gloc.of core.unicode\x27;string-ci<=?)
 (close
   (0 1 . core.unicode\x27;string-ci>=?)
   (push.gloc.of \x2E;string>=?)
   (call
     (push.gloc.of core.unicode\x27;string-foldcase)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;map "../stdlib/core/unicode.scm" . 281624))
   (push)
   (apply.gloc.of \x2E;apply "../stdlib/core/unicode.scm" . 281607))
 (set.gloc.of core.unicode\x27;string-ci>=?)
 (close
   (1 0 . core.unicode\x27;string-normalize-nfd)
   (call
     (call
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of core.io\x27;open-string-input-port "../stdlib/core/unicode.scm" . 286762))
       (push)
       (push.const . #t)
       (apply.gloc.of core.unicode-assistants\x27;decompose "../stdlib/core/unicode.scm" . 286751))
     (push)
     (apply.gloc.of
       core.unicode-assistants\x27;sort-combining-marks!
       "../stdlib/core/unicode.scm"
       .
       286728))
   (push)
   (subr.gloc.of \x2E;native-endianness 0)
   (push)
   (push.const . #t)
   (apply.gloc.of
     core.bytevector-transcoders\x27;utf32->string
     "../stdlib/core/unicode.scm"
     .
     285703))
 (set.gloc.of core.unicode\x27;string-normalize-nfd)
 (close
   (1 0 . core.unicode\x27;string-normalize-nfkd)
   (call
     (call
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of core.io\x27;open-string-input-port "../stdlib/core/unicode.scm" . 292906))
       (push)
       (push.const . #f)
       (apply.gloc.of core.unicode-assistants\x27;decompose "../stdlib/core/unicode.scm" . 292895))
     (push)
     (apply.gloc.of
       core.unicode-assistants\x27;sort-combining-marks!
       "../stdlib/core/unicode.scm"
       .
       292872))
   (push)
   (subr.gloc.of \x2E;native-endianness 0)
   (push)
   (push.const . #t)
   (apply.gloc.of
     core.bytevector-transcoders\x27;utf32->string
     "../stdlib/core/unicode.scm"
     .
     291847))
 (set.gloc.of core.unicode\x27;string-normalize-nfkd)
 (close
   (1 0 . core.unicode\x27;string-normalize-nfc)
   (call
     (call
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of core.io\x27;open-string-input-port "../stdlib/core/unicode.scm" . 300052))
       (push)
       (push.const . #t)
       (apply.gloc.of core.unicode-assistants\x27;decompose "../stdlib/core/unicode.scm" . 300041))
     (push)
     (apply.gloc.of
       core.unicode-assistants\x27;sort-combining-marks!
       "../stdlib/core/unicode.scm"
       .
       299016))
   (push)
   (apply.gloc.of core.unicode-assistants\x27;compose "../stdlib/core/unicode.scm" . 297991))
 (set.gloc.of core.unicode\x27;string-normalize-nfc)
 (close
   (1 0 . core.unicode\x27;string-normalize-nfkc)
   (call
     (call
       (call
         (push.iloc.0 . 0)
         (apply.gloc.of core.io\x27;open-string-input-port "../stdlib/core/unicode.scm" . 306196))
       (push)
       (push.const . #f)
       (apply.gloc.of core.unicode-assistants\x27;decompose "../stdlib/core/unicode.scm" . 306185))
     (push)
     (apply.gloc.of
       core.unicode-assistants\x27;sort-combining-marks!
       "../stdlib/core/unicode.scm"
       .
       305160))
   (push)
   (apply.gloc.of core.unicode-assistants\x27;compose "../stdlib/core/unicode.scm" . 304135))
 (set.gloc.of core.unicode\x27;string-normalize-nfkc)
 (push.const . core.unicode)
 (push.const . #f)
 (push.const
   (char-upcase import . core.unicode\x27;char-upcase)
   (char-downcase import . core.unicode\x27;char-downcase)
   (char-titlecase import . core.unicode\x27;char-titlecase)
   (char-foldcase import . core.unicode\x27;char-foldcase)
   (char-ci=? import . core.unicode\x27;char-ci=?)
   (char-ci<? import . core.unicode\x27;char-ci<?)
   (char-ci>? import . core.unicode\x27;char-ci>?)
   (char-ci<=? import . core.unicode\x27;char-ci<=?)
   (char-ci>=? import . core.unicode\x27;char-ci>=?)
   (char-alphabetic? import . core.unicode\x27;char-alphabetic?)
   (char-numeric? import . core.unicode\x27;char-numeric?)
   (char-whitespace? import . \x2E;char-whitespace?)
   (char-upper-case? import . core.unicode\x27;char-upper-case?)
   (char-lower-case? import . core.unicode\x27;char-lower-case?)
   (char-title-case? import . core.unicode\x27;char-title-case?)
   (char-general-category import . core.unicode\x27;char-general-category)
   (string-upcase import . core.unicode\x27;string-upcase)
   (string-downcase import . core.unicode\x27;string-downcase)
   (string-foldcase import . core.unicode\x27;string-foldcase)
   (string-titlecase import . core.unicode\x27;string-titlecase)
   (string-ci=? import . core.unicode\x27;string-ci=?)
   (string-ci<? import . core.unicode\x27;string-ci<?)
   (string-ci>? import . core.unicode\x27;string-ci>?)
   (string-ci<=? import . core.unicode\x27;string-ci<=?)
   (string-ci>=? import . core.unicode\x27;string-ci>=?)
   (string-normalize-nfd import . core.unicode\x27;string-normalize-nfd)
   (string-normalize-nfkd import . core.unicode\x27;string-normalize-nfkd)
   (string-normalize-nfc import . core.unicode\x27;string-normalize-nfc)
   (string-normalize-nfkc import . core.unicode\x27;string-normalize-nfkc))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/unicode.scm" . 6145))

((close
   (1 0)
   (push.car.iloc (0 . 0) "../stdlib/core/hashtables.scm" . 118849)
   (cdr.iloc (0 . 0) "../stdlib/core/hashtables.scm" . 118857)
   (ret.cons "../stdlib/core/hashtables.scm" . 118843))
 (set.gloc.of \x2E;L880)
 (close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (touch.gloc.of loop\x60;2395*)
   (push.cdr.iloc (0 . 0) "../stdlib/core/hashtables.scm" . 138266)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;cdar 1 "../stdlib/core/hashtables.scm" . 138284)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;append 2 "../stdlib/core/hashtables.scm" . 138276)
   (apply.gloc.of loop\x60;2395* "../stdlib/core/hashtables.scm" . 138260))
 (set.gloc.of loop\x60;2395*)
 (call
   (push.const core optargs)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/hashtables.scm" . 118831))
 (call
   (push.const core unicode)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/hashtables.scm" . 118831))
 (call
   (push.const core lists)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/hashtables.scm" . 118831))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/hashtables.scm" . 118831))
 (call
   (push.const core intrinsics)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/hashtables.scm" . 118831))
 (close
   (5 0 . core.hashtables\x27;make-generic-hashtable)
   (extend.unbound . 11)
   (push.close (1 0 . generic-hashtable-size) (ret.iloc 2 . 3))
   (push.close
     (3 0 . generic-hashtable-ref)
     (push.close
       (1 0 . equiv?)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.iloc (3 . 1) "../stdlib/core/hashtables.scm" . 65573))
     (extend . 1)
     (push.iloc 3 . 2)
     (call (push.iloc.1 . 1) (apply.iloc (3 . 0) "../stdlib/core/hashtables.scm" . 64535))
     (push)
     (push.const . #f)
     (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/hashtables.scm" . 66580)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of core.lists\x27;assp "../stdlib/core/hashtables.scm" . 68640))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true (push.iloc.0 . 0) (ret.subr.gloc.of \x2E;cdr (\x2E;cdr \x2E;L864\x60;2335*)))
       (ret.iloc 3 . 2))
     (ret.iloc 2 . 2))
   (push.close
     (3 0 . generic-hashtable-set!)
     (iloc 2 . 4)
     (if.false.call
       (push.const . hashtable-set!)
       (push.const . "expected mutable hashtable, but ~s is not")
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/hashtables.scm" . 74813)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.iloc.0 . 2)
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/hashtables.scm" . 74876)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/hashtables.scm" . 74776))
     (call (push.iloc.0 . 1) (apply.iloc (2 . 0) "../stdlib/core/hashtables.scm" . 75799))
     (push)
     (push.close
       (1 0 . equiv?)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.iloc (3 . 1) "../stdlib/core/hashtables.scm" . 76837))
     (extend . 2)
     (push.iloc 3 . 2)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/hashtables.scm" . 77844)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (call
         (push.iloc.1 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of core.lists\x27;assp "../stdlib/core/hashtables.scm" . 79904))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (push.iloc.0 . 0)
         (push.iloc 3 . 2)
         (ret.subr.gloc.of \x2E;set-cdr! "../stdlib/core/hashtables.scm" . 80943))
       (n+.iloc (5 . 3) 1 "../stdlib/core/hashtables.scm" . 82987)
       (set.iloc (5 . 3) "../stdlib/core/hashtables.scm" . 82976)
       (push.iloc 5 . 2)
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (iloc 3 . 2)
       (push.cons)
       (iloc.1 . 0)
       (push.cons)
       (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/hashtables.scm" . 84000))
     (n+.iloc (4 . 3) 1 "../stdlib/core/hashtables.scm" . 86047)
     (set.iloc (4 . 3) "../stdlib/core/hashtables.scm" . 86036)
     (push.iloc 4 . 2)
     (push.iloc.1 . 0)
     (push.iloc 2 . 1)
     (iloc 2 . 2)
     (push.cons)
     (push.subr.gloc.of \x2E;list 1 "../stdlib/core/hashtables.scm" . 87094)
     (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/hashtables.scm" . 87060))
   (push.close
     (2 0 . generic-hashtable-delete!)
     (iloc 2 . 4)
     (if.false.call
       (push.const . hashtable-delete!)
       (push.const . "expected mutable hashtable, but ~s is not")
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/hashtables.scm" . 91200)
       (push.iloc.0 . 0)
       (push.iloc.0 . 1)
       (push.subr.gloc.of \x2E;list 2 "../stdlib/core/hashtables.scm" . 91263)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/hashtables.scm" . 91160))
     (call
       (call (push.iloc.0 . 1) (apply.iloc (2 . 0) "../stdlib/core/hashtables.scm" . 92183))
       (push)
       (push.close
         (1 0 . equiv?)
         (push.iloc.0 . 0)
         (push.iloc.1 . 1)
         (apply.iloc (3 . 1) "../stdlib/core/hashtables.scm" . 93221))
       (extend . 2)
       (push.iloc 3 . 2)
       (push.iloc.0 . 0)
       (push.const . #f)
       (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/hashtables.scm" . 94228)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (call
           (push.iloc.1 . 1)
           (push.iloc.0 . 0)
           (apply.gloc.of core.lists\x27;assp "../stdlib/core/hashtables.scm" . 96288))
         (push)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc 5 . 2)
           (push.iloc 2 . 0)
           (call
             (push.iloc.0 . 0)
             (push.iloc.1 . 0)
             (apply.gloc.of core.lists\x27;remq "../stdlib/core/hashtables.scm" . 98375))
           (push)
           (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/hashtables.scm" . 98341))
         (ret.const.unspec))
       (ret.const.unspec))
     (ret.const.unspec))
   (push.close
     (2 0 . generic-hashtable-contains?)
     (push.close
       (1 0 . equiv?)
       (push.iloc.0 . 0)
       (push.iloc.1 . 1)
       (apply.iloc (3 . 1) "../stdlib/core/hashtables.scm" . 104485))
     (extend . 1)
     (push.iloc 3 . 2)
     (call (push.iloc.1 . 1) (apply.iloc (3 . 0) "../stdlib/core/hashtables.scm" . 103447))
     (push)
     (push.const . #f)
     (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/hashtables.scm" . 105492)
     (extend . 1)
     (iloc.0 . 0)
     (if.false.ret)
     (call
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of core.lists\x27;assp "../stdlib/core/hashtables.scm" . 107550))
     (if.false.ret)
     (ret.const . #t))
   (push.close
     (1 1 . generic-hashtable-copy)
     (call
       (iloc.0 . 1)
       (if.not.pair?.ret.const . #f)
       (push.iloc.0 . 1)
       (ret.subr.gloc.of \x2E;car (\x2E;car opt\x60;2375*)))
     (push)
     (extend . 1)
     (iloc 3 . 4)
     (if.true
       (subr.gloc.of \x2E;make-core-hashtable 0)
       (push)
       (extend . 1)
       (call
         (push.close
           (1 0)
           (push.iloc.1 . 0)
           (push.car.iloc (0 . 0) "../stdlib/core/hashtables.scm" . 117802)
           (call
             (push.gloc.of \x2E;L880)
             (push.cdr.iloc (0 . 0) "../stdlib/core/hashtables.scm" . 118867)
             (apply.gloc.of \x2E;map "../stdlib/core/hashtables.scm" . 118826))
           (push)
           (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/hashtables.scm" . 115753))
         (push.iloc 4 . 2)
         (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/hashtables.scm" . 119837)
         (apply.gloc.of \x2E;for-each "../stdlib/core/hashtables.scm" . 115731))
       (iloc.1 . 0)
       (if.true
         (push.iloc 4 . 0)
         (push.iloc 4 . 1)
         (push.iloc.0 . 0)
         (push.iloc 4 . 3)
         (push.iloc.1 . 0)
         (apply.gloc.of
           core.hashtables\x27;make-generic-hashtable
           "../stdlib/core/hashtables.scm"
           .
           121879))
       (push.iloc 4 . 0)
       (push.iloc 4 . 1)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;core-hashtable-copy 1 "../stdlib/core/hashtables.scm" . 122956)
       (push.iloc 4 . 3)
       (push.iloc.1 . 0)
       (apply.gloc.of
         core.hashtables\x27;make-generic-hashtable
         "../stdlib/core/hashtables.scm"
         .
         122903))
     (push.iloc 3 . 0)
     (push.iloc 3 . 1)
     (push.iloc 3 . 2)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;core-hashtable-copy 2 "../stdlib/core/hashtables.scm" . 123974)
     (push.iloc 3 . 3)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.hashtables\x27;make-generic-hashtable
       "../stdlib/core/hashtables.scm"
       .
       123921))
   (push.close
     (1 1 . generic-hashtable-clear!)
     (call
       (iloc.0 . 1)
       (if.pair? (push.iloc.0 . 1) (ret.subr.gloc.of \x2E;car (\x2E;car opt\x60;2386*)))
       (ret.const . 0))
     (push)
     (extend . 1)
     (iloc 3 . 4)
     (if.false.call
       (push.const . hashtable-clear!)
       (push.const . "expected mutable hashtable, but ~s is not")
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/hashtables.scm" . 129089)
       (push.iloc.1 . 0)
       (iloc.1 . 1)
       (push.cons)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/hashtables.scm" . 129050))
     (push.iloc 3 . 2)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;core-hashtable-clear! 2 "../stdlib/core/hashtables.scm" . 130061)
     (const . 0)
     (set.iloc (3 . 3) "../stdlib/core/hashtables.scm" . 131085)
     (ret.const.unspec))
   (push.close
     (1 0 . generic-hashtable->alist)
     (touch.gloc.of loop\x60;2395*)
     (push.iloc 2 . 2)
     (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/hashtables.scm" . 135195)
     (push.const)
     (apply.gloc.of loop\x60;2395* "../stdlib/core/hashtables.scm" . 136205))
   (push.close (1 0 . generic-hashtable-equivalence-function) (ret.iloc 2 . 1))
   (push.close (1 0 . generic-hashtable-hash-function) (ret.iloc 2 . 0))
   (push.close (1 0 . generic-hashtable-mutable?) (ret.iloc 2 . 4))
   (enclose . 11)
   (push.const . generic)
   (push.const . hashtable-handler)
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.iloc.0 . 2)
   (push.iloc.0 . 3)
   (push.iloc.0 . 4)
   (push.iloc.0 . 5)
   (push.iloc.0 . 6)
   (push.iloc.0 . 9)
   (push.iloc.0 . 8)
   (push.iloc.0 . 10)
   (push.iloc.0 . 7)
   (push.subr.gloc.of \x2E;vector 14 "../stdlib/core/hashtables.scm" . 147484)
   (ret.subr.gloc.of \x2E;make-core-hashtable "../stdlib/core/hashtables.scm" . 146439))
 (set.gloc.of core.hashtables\x27;make-generic-hashtable)
 (close
   (2 1 . core.hashtables\x27;make-hashtable)
   (call
     (iloc.0 . 2)
     (if.pair? (push.iloc.0 . 2) (ret.subr.gloc.of \x2E;car (\x2E;car opt\x60;2405*)))
     (ret.const . 0))
   (push)
   (extend . 1)
   (push.iloc.1 . 0)
   (subr.gloc.of \x2E;procedure? 1 "../stdlib/core/hashtables.scm" . 165901)
   (if.false.call
     (push.const . make-hashtable)
     (push.const . "expected procedure, but got ~r, as argument 1")
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/hashtables.scm" . 166962)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/hashtables.scm" . 166925))
   (push.iloc.1 . 1)
   (subr.gloc.of \x2E;procedure? 1 "../stdlib/core/hashtables.scm" . 167949)
   (if.false.call
     (push.const . make-hashtable)
     (push.const . "expected procedure, but got ~r, as argument 2")
     (push.iloc.1 . 1)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/hashtables.scm" . 169010)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/hashtables.scm" . 168973))
   (push.iloc.1 . 0)
   (push.iloc.1 . 1)
   (push.const . eq?)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;make-core-hashtable 2 "../stdlib/core/hashtables.scm" . 170046)
   (push.const . 0)
   (push.const . #t)
   (apply.gloc.of
     core.hashtables\x27;make-generic-hashtable
     "../stdlib/core/hashtables.scm"
     .
     169993))
 (set.gloc.of core.hashtables\x27;make-hashtable)
 (close
   (0 1 . core.hashtables\x27;make-eq-hashtable)
   (push.const . eq?)
   (call
     (iloc.0 . 0)
     (if.pair? (push.iloc.0 . 0) (ret.subr.gloc.of \x2E;car (\x2E;car opt\x60;2410*)))
     (ret.const . 0))
   (push)
   (ret.subr.gloc.of \x2E;make-shared-core-hashtable "../stdlib/core/hashtables.scm" . 175113))
 (set.gloc.of core.hashtables\x27;make-eq-hashtable)
 (close
   (0 1 . core.hashtables\x27;make-eqv-hashtable)
   (push.const . eqv?)
   (call
     (iloc.0 . 0)
     (if.pair? (push.iloc.0 . 0) (ret.subr.gloc.of \x2E;car (\x2E;car opt\x60;2415*)))
     (ret.const . 0))
   (push)
   (ret.subr.gloc.of \x2E;make-shared-core-hashtable "../stdlib/core/hashtables.scm" . 180233))
 (set.gloc.of core.hashtables\x27;make-eqv-hashtable)
 (close
   (0 1 . core.hashtables\x27;make-string-hashtable)
   (push.const . string=?)
   (call
     (iloc.0 . 0)
     (if.pair? (push.iloc.0 . 0) (ret.subr.gloc.of \x2E;car (\x2E;car opt\x60;2420*)))
     (ret.const . 0))
   (push)
   (ret.subr.gloc.of \x2E;make-shared-core-hashtable "../stdlib/core/hashtables.scm" . 185353))
 (set.gloc.of core.hashtables\x27;make-string-hashtable)
 (close
   (4 0 . core.hashtables\x27;hashtable-update!)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;core-hashtable-mutable? 1 "../stdlib/core/hashtables.scm" . 189451)
   (if.false.call
     (push.const . hashtable-update!)
     (push.const . "expected mutable hashtable")
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 2)
     (push.iloc.0 . 3)
     (push.subr.gloc.of \x2E;list 4 "../stdlib/core/hashtables.scm" . 190544)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/hashtables.scm" . 190475))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (push.iloc.0 . 3)
     (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/hashtables.scm" . 191529)
     (apply.iloc (0 . 2) "../stdlib/core/hashtables.scm" . 191523))
   (push)
   (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/hashtables.scm" . 191495))
 (set.gloc.of core.hashtables\x27;hashtable-update!)
 (close
   (1 0 . core.hashtables\x27;hashtable-keys)
   (call
     (push.gloc.of \x2E;car)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/hashtables.scm" . 195614)
     (apply.gloc.of \x2E;map "../stdlib/core/hashtables.scm" . 195605))
   (push)
   (ret.subr.gloc.of \x2E;list->vector "../stdlib/core/hashtables.scm" . 195591))
 (set.gloc.of core.hashtables\x27;hashtable-keys)
 (close
   (1 0 . core.hashtables\x27;hashtable-entries)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/hashtables.scm" . 199698)
   (extend . 1)
   (call
     (push.gloc.of \x2E;car)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;map "../stdlib/core/hashtables.scm" . 200735))
   (push)
   (push.subr.gloc.of \x2E;list->vector 1 "../stdlib/core/hashtables.scm" . 200721)
   (call
     (push.gloc.of \x2E;cdr)
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;map "../stdlib/core/hashtables.scm" . 201759))
   (push)
   (push.subr.gloc.of \x2E;list->vector 1 "../stdlib/core/hashtables.scm" . 201745)
   (ret.subr.gloc.of \x2E;values "../stdlib/core/hashtables.scm" . 200713))
 (set.gloc.of core.hashtables\x27;hashtable-entries)
 (close
   (1 0 . core.hashtables\x27;string-ci-hash)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.unicode\x27;string-foldcase "../stdlib/core/hashtables.scm" . 205844))
   (push)
   (ret.subr.gloc.of \x2E;string-hash "../stdlib/core/hashtables.scm" . 205831))
 (set.gloc.of core.hashtables\x27;string-ci-hash)
 (push.const . core.hashtables)
 (push.const . #f)
 (push.const
   (make-eq-hashtable import . core.hashtables\x27;make-eq-hashtable)
   (make-eqv-hashtable import . core.hashtables\x27;make-eqv-hashtable)
   (make-string-hashtable import . core.hashtables\x27;make-string-hashtable)
   (make-hashtable import . core.hashtables\x27;make-hashtable)
   (weak-hashtable? import . \x2E;weak-core-hashtable?)
   (make-weak-hashtable import . \x2E;make-weak-shared-core-hashtable)
   (hashtable-contains? import . \x2E;core-hashtable-contains?)
   (hashtable-delete! import . \x2E;core-hashtable-delete!)
   (hashtable-set! import . \x2E;core-hashtable-set!)
   (hashtable-ref import . \x2E;core-hashtable-ref)
   (hashtable-size import . \x2E;core-hashtable-size)
   (hashtable? import . \x2E;core-hashtable?)
   (hashtable-update! import . core.hashtables\x27;hashtable-update!)
   (hashtable-clear! import . \x2E;core-hashtable-clear!)
   (hashtable-copy import . \x2E;core-hashtable-copy)
   (hashtable-keys import . core.hashtables\x27;hashtable-keys)
   (hashtable-entries import . core.hashtables\x27;hashtable-entries)
   (hashtable-mutable? import . \x2E;core-hashtable-mutable?)
   (hashtable-hash-function import . \x2E;core-hashtable-hash-function)
   (hashtable-equivalence-function import . \x2E;core-hashtable-equivalence-function)
   (equal-hash import . \x2E;equal-hash)
   (string-hash import . \x2E;string-hash)
   (string-ci-hash import . core.hashtables\x27;string-ci-hash)
   (symbol-hash import . \x2E;symbol-hash)
   (hashtable->alist import . \x2E;core-hashtable->alist))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/hashtables.scm" . 118831))

((close
   (1 0)
   (push.iloc.0 . 0)
   (push.const
     begin
     (define-syntax ?make-name ?make-rules)
     (define-syntax ?pred-name ?pred-rules)
     (define-syntax ?getter-name ?getter-rules)
     ...
     (define-syntax ?setter-name ?setter-rules)
     ...)
   (push.const
     (?setter-rules . 1)
     (?setter-name . 1)
     (?getter-rules . 1)
     (?getter-name . 1)
     (?pred-rules . 0)
     (?pred-name . 0)
     (?make-rules . 0)
     (?make-name . 0))
   (apply.gloc.of \x2E;syntax/c1n "../stdlib/core/struct.scm" . 34832))
 (set.gloc.of \x2E;L894)
 (close
   (1 0)
   (push.gloc.of \x2E;vars)
   (push.iloc.0 . 0)
   (push.const)
   (push.const ?_ ?struct-name ?field-names)
   (push.const . #f)
   (push.close
     (1 0)
     (call
       (call
         (push.iloc.0 . 0)
         (push.const . ?struct-name)
         (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/struct.scm" . 18461))
       (push)
       (apply.gloc.of \x2E;syntax->datum "../stdlib/core/struct.scm" . 18461))
     (push)
     (call
       (call
         (push.iloc.0 . 0)
         (push.const . ?field-names)
         (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/struct.scm" . 19485))
       (push)
       (apply.gloc.of \x2E;syntax->datum "../stdlib/core/struct.scm" . 19485))
     (push)
     (extend . 2)
     (call
       (iloc.0 . 0)
       (if.symbol?.ret.const . #t)
       (push.const . define-struct)
       (push.const . "expected symbol for struct name")
       (push.iloc 2 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of \x2E;syntax-violation "../stdlib/core/struct.scm" . 21520))
     (call
       (extend.enclose+
         (1 0 . loop)
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (car.iloc (0 . 0) "../stdlib/core/struct.scm" . 24608)
         (if.symbol?
           (push.car.iloc (0 . 0) "../stdlib/core/struct.scm" . 25633)
           (push.cdr.iloc (0 . 0) "../stdlib/core/struct.scm" . 25645)
           (subr.gloc.of \x2E;memq 2 "../stdlib/core/struct.scm" . 25627)
           (if.true
             (push.const . define-struct)
             (push.const . "duplicate field name")
             (push.iloc 4 . 0)
             (push.iloc 2 . 1)
             (apply.gloc.of \x2E;syntax-violation "../stdlib/core/struct.scm" . 26651))
           (push.cdr.iloc (0 . 0) "../stdlib/core/struct.scm" . 27681)
           (apply.iloc+ (1 . 0) "../stdlib/core/struct.scm" . 27675))
         (push.const . define-struct)
         (push.const . "expected symbol for field name")
         (push.iloc 4 . 0)
         (push.iloc 2 . 1)
         (apply.gloc.of \x2E;syntax-violation "../stdlib/core/struct.scm" . 28695))
       (push.iloc.1 . 1)
       (apply.iloc+ (0 . 0) "../stdlib/core/struct.scm" . 23566))
     (push.const . "make-~a")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/struct.scm" . 29741)
     (push.subr.gloc.of \x2E;string->symbol 1 "../stdlib/core/struct.scm" . 29725)
     (push.const . "~a?")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/struct.scm" . 30765)
     (push.subr.gloc.of \x2E;string->symbol 1 "../stdlib/core/struct.scm" . 30749)
     (push.const . "type:~a")
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/struct.scm" . 31789)
     (push.subr.gloc.of \x2E;string->symbol 1 "../stdlib/core/struct.scm" . 31773)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;length 1 "../stdlib/core/struct.scm" . 32799)
     (extend . 4)
     (call
       (push.iloc.0 . 3)
       (push.const . 1)
       (apply.gloc.of core.lists\x27;iota "../stdlib/core/struct.scm" . 33824))
     (push)
     (extend . 1)
     (push.iloc 3 . 0)
     (call
       (call
         (push.iloc 3 . 0)
         (push.const . ?_)
         (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/struct.scm" . 34832))
       (push)
       (push.iloc.1 . 0)
       (apply.gloc.of \x2E;datum->syntax "../stdlib/core/struct.scm" . 34832))
     (push)
     (call
       (call
         (push.iloc 3 . 0)
         (push.const . ?_)
         (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/struct.scm" . 34832))
       (push)
       (push.iloc.1 . 1)
       (apply.gloc.of \x2E;datum->syntax "../stdlib/core/struct.scm" . 34832))
     (push)
     (call
       (call
         (push.iloc 3 . 0)
         (push.const . k)
         (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/struct.scm" . 34832))
       (push)
       (push.const . syntax-rules)
       (push.const)
       (push.const . _)
       (iloc 2 . 1)
       (push.cons)
       (push.const . tuple)
       (push.const . quote)
       (push.iloc.1 . 2)
       (push.subr.gloc.of \x2E;list 2 "../stdlib/core/struct.scm" . 34832)
       (push.iloc 2 . 1)
       (push.subr.gloc.of \x2E;cons* 3 "../stdlib/core/struct.scm" . 34832)
       (push.subr.gloc.of \x2E;list 2 "../stdlib/core/struct.scm" . 34832)
       (push.const _)
       (push.const . tuple)
       (push.const . quote)
       (push.iloc.1 . 2)
       (push.subr.gloc.of \x2E;list 2 "../stdlib/core/struct.scm" . 34832)
       (call
         (push.iloc.1 . 3)
         (push.const unspecified)
         (apply.gloc.of core.lists\x27;make-list "../stdlib/core/struct.scm" . 34832))
       (push)
       (push.subr.gloc.of \x2E;cons* 3 "../stdlib/core/struct.scm" . 34832)
       (push.subr.gloc.of \x2E;list 2 "../stdlib/core/struct.scm" . 34832)
       (push.subr.gloc.of \x2E;list 4 "../stdlib/core/struct.scm" . 34832)
       (apply.gloc.of \x2E;datum->syntax "../stdlib/core/struct.scm" . 34832))
     (push)
     (call
       (call
         (push.iloc 3 . 0)
         (push.const . k)
         (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/struct.scm" . 34832))
       (push)
       (push.const . syntax-rules)
       (push.const)
       (push.const _ obj)
       (push.const . eq?)
       (push.const tuple-ref obj 0)
       (push.const . quote)
       (push.iloc.1 . 2)
       (push.subr.gloc.of \x2E;list 2 "../stdlib/core/struct.scm" . 34832)
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/struct.scm" . 34832)
       (push.subr.gloc.of \x2E;list 2 "../stdlib/core/struct.scm" . 34832)
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/struct.scm" . 34832)
       (apply.gloc.of \x2E;datum->syntax "../stdlib/core/struct.scm" . 34832))
     (push)
     (call
       (push.close
         (1 0)
         (call
           (push.iloc 4 . 0)
           (push.const . ?_)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/struct.scm" . 34832))
         (push)
         (push.const . "~a-~a")
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of \x2E;format 3 "../stdlib/core/struct.scm" . 34832)
         (push.subr.gloc.of \x2E;string->symbol 1 "../stdlib/core/struct.scm" . 34832)
         (apply.gloc.of \x2E;datum->syntax "../stdlib/core/struct.scm" . 34832))
       (push.iloc 2 . 1)
       (apply.gloc.of \x2E;map "../stdlib/core/struct.scm" . 34832))
     (push)
     (call
       (push.close
         (1 0)
         (call
           (push.iloc 4 . 0)
           (push.const . ?_)
           (apply.gloc.of \x2E;syntax/i1n "../stdlib/core/struct.scm" . 34832))
         (push)
         (push.const . "~a-~a-set!")
         (push.iloc 3 . 0)
         (push.iloc.0 . 0)
         (push.subr.gloc.of \x2E;format 3 "../stdlib/core/struct.scm" . 34832)
         (push.subr.gloc.of \x2E;string->symbol 1 "../stdlib/core/struct.scm" . 34832)
         (apply.gloc.of \x2E;datum->syntax "../stdlib/core/struct.scm" . 34832))
       (push.iloc 2 . 1)
       (apply.gloc.of \x2E;map "../stdlib/core/struct.scm" . 34832))
     (push)
     (call
       (push.close
         (1 0)
         (call
           (push.iloc 4 . 0)
           (push.const . k)
           (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/struct.scm" . 34832))
         (push)
         (push.const . syntax-rules)
         (push.const)
         (push.const _ obj)
         (push.const . tuple-ref)
         (push.const . obj)
         (push.iloc.0 . 0)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/struct.scm" . 34832)
         (push.subr.gloc.of \x2E;list 2 "../stdlib/core/struct.scm" . 34832)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/struct.scm" . 34832)
         (apply.gloc.of \x2E;datum->syntax "../stdlib/core/struct.scm" . 34832))
       (push.iloc.0 . 0)
       (apply.gloc.of \x2E;map "../stdlib/core/struct.scm" . 34832))
     (push)
     (call
       (push.close
         (1 0)
         (call
           (push.iloc 4 . 0)
           (push.const . k)
           (apply.gloc.of \x2E;syntax/i0n "../stdlib/core/struct.scm" . 34832))
         (push)
         (push.const . syntax-rules)
         (push.const)
         (push.const _ obj value)
         (push.const . tuple-set!)
         (push.const . obj)
         (push.iloc.0 . 0)
         (push.const value)
         (push.subr.gloc.of \x2E;cons* 4 "../stdlib/core/struct.scm" . 34832)
         (push.subr.gloc.of \x2E;list 2 "../stdlib/core/struct.scm" . 34832)
         (push.subr.gloc.of \x2E;list 3 "../stdlib/core/struct.scm" . 34832)
         (apply.gloc.of \x2E;datum->syntax "../stdlib/core/struct.scm" . 34832))
       (push.iloc.0 . 0)
       (apply.gloc.of \x2E;map "../stdlib/core/struct.scm" . 34832))
     (push)
     (push.subr.gloc.of \x2E;list 8 "../stdlib/core/struct.scm" . 34832)
     (push.const)
     (push.const
       ?make-name
       ?pred-name
       ?make-rules
       ?pred-rules
       (?getter-name ...)
       (?setter-name ...)
       (?getter-rules ...)
       (?setter-rules ...))
     (push.const . #f)
     (push.gloc.of \x2E;L894)
     (push.subr.gloc.of \x2E;list 3 "../stdlib/core/struct.scm" . 34832)
     (push.const . _)
     (push.const . #f)
     (push.gloc.of \x2E;L895)
     (push.subr.gloc.of \x2E;list 3 "../stdlib/core/struct.scm" . 34832)
     (apply.gloc.of \x2E;syntax-dispatch "../stdlib/core/struct.scm" . 34832))
   (push.subr.gloc.of
     \x2E;list
     3
     (\x2E;list
       '(?_ ?struct-name ?field-names)
       #f
       (lambda (\x2E;vars\x60;2437*)
         (let ((struct-name\x60;2439*
                 (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;2437* '?struct-name)))
               (field-names\x60;2439*
                 (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;2437* '?field-names))))
           (or (\x2E;symbol? struct-name\x60;2439*)
               (\x2E;syntax-violation
                 'define-struct
                 "expected symbol for struct name"
                 x\x60;2435*
                 struct-name\x60;2439*))
           (letrec* ((loop\x60;2443*
                       (lambda (names\x60;2444*)
                         (and (\x2E;pair? names\x60;2444*)
                              (if (\x2E;symbol? (\x2E;car names\x60;2444*))
                                  (if (\x2E;memq
                                        (\x2E;car names\x60;2444*)
                                        (\x2E;cdr names\x60;2444*))
                                      (\x2E;syntax-violation
                                        'define-struct
                                        "duplicate field name"
                                        x\x60;2435*
                                        field-names\x60;2439*)
                                      (loop\x60;2443* (\x2E;cdr names\x60;2444*)))
                                  (\x2E;syntax-violation
                                    'define-struct
                                    "expected symbol for field name"
                                    x\x60;2435*
                                    field-names\x60;2439*))))))
             (loop\x60;2443* field-names\x60;2439*))
           (let ((make-name\x60;2447*
                   (\x2E;string->symbol (\x2E;format "make-~a" struct-name\x60;2439*)))
                 (pred-name\x60;2447*
                   (\x2E;string->symbol (\x2E;format "~a?" struct-name\x60;2439*)))
                 (desc-name\x60;2447*
                   (\x2E;string->symbol (\x2E;format "type:~a" struct-name\x60;2439*)))
                 (field-count\x60;2447* (\x2E;length field-names\x60;2439*)))
             (let ((field-refs\x60;2449* (core.lists\x27;iota field-count\x60;2447* 1)))
               (\x2E;syntax-dispatch
                 \x2E;vars\x60;2437*
                 (\x2E;list
                   (\x2E;datum->syntax
                     (\x2E;syntax/i1n \x2E;vars\x60;2437* '?_)
                     make-name\x60;2447*)
                   (\x2E;datum->syntax
                     (\x2E;syntax/i1n \x2E;vars\x60;2437* '?_)
                     pred-name\x60;2447*)
                   (\x2E;datum->syntax
                     (\x2E;syntax/i0n \x2E;vars\x60;2437* 'k)
                     (\x2E;list
                       'syntax-rules
                       '()
                       (\x2E;list
                         (\x2E;cons '_ field-names\x60;2439*)
                         (\x2E;cons*
                           'tuple
                           (\x2E;list 'quote desc-name\x60;2447*)
                           field-names\x60;2439*))
                       (\x2E;list
                         '(_)
                         (\x2E;cons*
                           'tuple
                           (\x2E;list 'quote desc-name\x60;2447*)
                           (core.lists\x27;make-list field-count\x60;2447* '(unspecified))))))
                   (\x2E;datum->syntax
                     (\x2E;syntax/i0n \x2E;vars\x60;2437* 'k)
                     (\x2E;list
                       'syntax-rules
                       '()
                       (\x2E;list
                         '(_ obj)
                         (\x2E;list
                           'eq?
                           '(tuple-ref obj 0)
                           (\x2E;list 'quote desc-name\x60;2447*)))))
                   (\x2E;map
                     (lambda (field-name\x60;2452*)
                       (\x2E;datum->syntax
                         (\x2E;syntax/i1n \x2E;vars\x60;2437* '?_)
                         (\x2E;string->symbol
                           (\x2E;format "~a-~a" struct-name\x60;2439* field-name\x60;2452*))))
                     field-names\x60;2439*)
                   (\x2E;map
                     (lambda (field-name\x60;2454*)
                       (\x2E;datum->syntax
                         (\x2E;syntax/i1n \x2E;vars\x60;2437* '?_)
                         (\x2E;string->symbol
                           (\x2E;format "~a-~a-set!" struct-name\x60;2439* field-name\x60;2454*))))
                     field-names\x60;2439*)
                   (\x2E;map
                     (lambda (field-ref\x60;2456*)
                       (\x2E;datum->syntax
                         (\x2E;syntax/i0n \x2E;vars\x60;2437* 'k)
                         (\x2E;list
                           'syntax-rules
                           '()
                           (\x2E;list '(_ obj) (\x2E;list 'tuple-ref 'obj field-ref\x60;2456*)))))
                     field-refs\x60;2449*)
                   (\x2E;map
                     (lambda (field-ref\x60;2458*)
                       (\x2E;datum->syntax
                         (\x2E;syntax/i0n \x2E;vars\x60;2437* 'k)
                         (\x2E;list
                           'syntax-rules
                           '()
                           (\x2E;list
                             '(_ obj value)
                             (\x2E;cons* 'tuple-set! 'obj field-ref\x60;2458* '(value))))))
                     field-refs\x60;2449*))
                 '()
                 (\x2E;list
                   '(?make-name
                      ?pred-name
                      ?make-rules
                      ?pred-rules
                      (?getter-name ...)
                      (?setter-name ...)
                      (?getter-rules ...)
                      (?setter-rules ...))
                   #f
                   \x2E;L894)
                 (\x2E;list '_ #f \x2E;L895))))))))
   (apply.gloc.of
     \x2E;syntax-dispatch
     (\x2E;syntax-dispatch
       \x2E;vars
       x\x60;2435*
       '()
       (\x2E;list
         '(?_ ?struct-name ?field-names)
         #f
         (lambda (\x2E;vars\x60;2437*)
           (let ((struct-name\x60;2439*
                   (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;2437* '?struct-name)))
                 (field-names\x60;2439*
                   (\x2E;syntax->datum (\x2E;syntax/i1n \x2E;vars\x60;2437* '?field-names))))
             (or (\x2E;symbol? struct-name\x60;2439*)
                 (\x2E;syntax-violation
                   'define-struct
                   "expected symbol for struct name"
                   x\x60;2435*
                   struct-name\x60;2439*))
             (letrec* ((loop\x60;2443*
                         (lambda (names\x60;2444*)
                           (and (\x2E;pair? names\x60;2444*)
                                (if (\x2E;symbol? (\x2E;car names\x60;2444*))
                                    (if (\x2E;memq
                                          (\x2E;car names\x60;2444*)
                                          (\x2E;cdr names\x60;2444*))
                                        (\x2E;syntax-violation
                                          'define-struct
                                          "duplicate field name"
                                          x\x60;2435*
                                          field-names\x60;2439*)
                                        (loop\x60;2443* (\x2E;cdr names\x60;2444*)))
                                    (\x2E;syntax-violation
                                      'define-struct
                                      "expected symbol for field name"
                                      x\x60;2435*
                                      field-names\x60;2439*))))))
               (loop\x60;2443* field-names\x60;2439*))
             (let ((make-name\x60;2447*
                     (\x2E;string->symbol (\x2E;format "make-~a" struct-name\x60;2439*)))
                   (pred-name\x60;2447*
                     (\x2E;string->symbol (\x2E;format "~a?" struct-name\x60;2439*)))
                   (desc-name\x60;2447*
                     (\x2E;string->symbol (\x2E;format "type:~a" struct-name\x60;2439*)))
                   (field-count\x60;2447* (\x2E;length field-names\x60;2439*)))
               (let ((field-refs\x60;2449* (core.lists\x27;iota field-count\x60;2447* 1)))
                 (\x2E;syntax-dispatch
                   \x2E;vars\x60;2437*
                   (\x2E;list
                     (\x2E;datum->syntax
                       (\x2E;syntax/i1n \x2E;vars\x60;2437* '?_)
                       make-name\x60;2447*)
                     (\x2E;datum->syntax
                       (\x2E;syntax/i1n \x2E;vars\x60;2437* '?_)
                       pred-name\x60;2447*)
                     (\x2E;datum->syntax
                       (\x2E;syntax/i0n \x2E;vars\x60;2437* 'k)
                       (\x2E;list
                         'syntax-rules
                         '()
                         (\x2E;list
                           (\x2E;cons '_ field-names\x60;2439*)
                           (\x2E;cons*
                             'tuple
                             (\x2E;list 'quote desc-name\x60;2447*)
                             field-names\x60;2439*))
                         (\x2E;list
                           '(_)
                           (\x2E;cons*
                             'tuple
                             (\x2E;list 'quote desc-name\x60;2447*)
                             (core.lists\x27;make-list field-count\x60;2447* '(unspecified))))))
                     (\x2E;datum->syntax
                       (\x2E;syntax/i0n \x2E;vars\x60;2437* 'k)
                       (\x2E;list
                         'syntax-rules
                         '()
                         (\x2E;list
                           '(_ obj)
                           (\x2E;list
                             'eq?
                             '(tuple-ref obj 0)
                             (\x2E;list 'quote desc-name\x60;2447*)))))
                     (\x2E;map
                       (lambda (field-name\x60;2452*)
                         (\x2E;datum->syntax
                           (\x2E;syntax/i1n \x2E;vars\x60;2437* '?_)
                           (\x2E;string->symbol
                             (\x2E;format "~a-~a" struct-name\x60;2439* field-name\x60;2452*))))
                       field-names\x60;2439*)
                     (\x2E;map
                       (lambda (field-name\x60;2454*)
                         (\x2E;datum->syntax
                           (\x2E;syntax/i1n \x2E;vars\x60;2437* '?_)
                           (\x2E;string->symbol
                             (\x2E;format
                               "~a-~a-set!"
                               struct-name\x60;2439*
                               field-name\x60;2454*))))
                       field-names\x60;2439*)
                     (\x2E;map
                       (lambda (field-ref\x60;2456*)
                         (\x2E;datum->syntax
                           (\x2E;syntax/i0n \x2E;vars\x60;2437* 'k)
                           (\x2E;list
                             'syntax-rules
                             '()
                             (\x2E;list '(_ obj) (\x2E;list 'tuple-ref 'obj field-ref\x60;2456*)))))
                       field-refs\x60;2449*)
                     (\x2E;map
                       (lambda (field-ref\x60;2458*)
                         (\x2E;datum->syntax
                           (\x2E;syntax/i0n \x2E;vars\x60;2437* 'k)
                           (\x2E;list
                             'syntax-rules
                             '()
                             (\x2E;list
                               '(_ obj value)
                               (\x2E;cons* 'tuple-set! 'obj field-ref\x60;2458* '(value))))))
                       field-refs\x60;2449*))
                   '()
                   (\x2E;list
                     '(?make-name
                        ?pred-name
                        ?make-rules
                        ?pred-rules
                        (?getter-name ...)
                        (?setter-name ...)
                        (?getter-rules ...)
                        (?setter-rules ...))
                     #f
                     \x2E;L894)
                   (\x2E;list '_ #f \x2E;L895))))))))))
 (set.gloc.of \x2E;L893)
 (close
   (1 0)
   (push.const . with-syntax)
   (push.const . "value does not match to pattern")
   (push.const
     (?make-name (datum->syntax (syntax ?_) make-name))
     (?pred-name (datum->syntax (syntax ?_) pred-name))
     (?make-rules
       (datum->syntax
         (syntax k)
         `(syntax-rules ()
            ((_ ,@field-names) (tuple ',desc-name ,@field-names))
            ((_) (tuple ',desc-name ,@(make-list field-count '(unspecified)))))))
     (?pred-rules
       (datum->syntax (syntax k) `(syntax-rules () ((_ obj) (eq? (tuple-ref obj 0) ',desc-name)))))
     ((?getter-name ...)
      (map (lambda (field-name)
             (datum->syntax (syntax ?_) (string->symbol (format "~a-~a" struct-name field-name))))
           field-names))
     ((?setter-name ...)
      (map (lambda (field-name)
             (datum->syntax
               (syntax ?_)
               (string->symbol (format "~a-~a-set!" struct-name field-name))))
           field-names))
     ((?getter-rules ...)
      (map (lambda (field-ref)
             (datum->syntax (syntax k) `(syntax-rules () ((_ obj) (tuple-ref obj ,field-ref)))))
           field-refs))
     ((?setter-rules ...)
      (map (lambda (field-ref)
             (datum->syntax
               (syntax k)
               `(syntax-rules () ((_ obj value) (tuple-set! obj ,field-ref value)))))
           field-refs)))
   (apply.gloc.of \x2E;syntax-violation "../stdlib/core/struct.scm" . 34832))
 (set.gloc.of \x2E;L895)
 (call
   (push.const core lists)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/struct.scm" . 34832))
 (call
   (push.const core syntax-case)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/struct.scm" . 34832))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/struct.scm" . 34832))
 (call
   (push.const . syntax)
   (push.const . core.struct\x27;define-struct)
   (call
     (push.gloc.of \x2E;L893)
     (apply.gloc.of \x2E;transformer-thunk "../stdlib/core/struct.scm" . 15365))
   (push)
   (push.const
     (?pred-name unbound)
     (or import . \x2E;or)
     (?struct-name unbound)
     (?setter-rules unbound)
     (tuple import . \x2E;tuple)
     (field-name unbound)
     (core.lists\x27;iota unbound)
     (unspecified import . \x2E;unspecified)
     (core.lists\x27;make-list unbound)
     (letrec* import . \x2E;letrec*)
     (string->symbol import . \x2E;string->symbol)
     (?make-rules unbound)
     (format import . \x2E;format)
     (make-list import . core.lists\x27;make-list)
     (with-syntax import . core.syntax-case\x27;with-syntax)
     (field-refs unbound)
     (obj unbound)
     (make-name unbound)
     (k unbound)
     (?pred-rules unbound)
     (if import . \x2E;if)
     (tuple-ref import . \x2E;tuple-ref)
     (define-struct import . core.struct\x27;define-struct)
     (unquote-splicing import . \x2E;unquote-splicing)
     (field-count unbound)
     (map import . \x2E;map)
     (quasiquote import . \x2E;quasiquote)
     (eq? import . \x2E;eq?)
     (begin import . \x2E;begin)
     (_ import . \x2E;_)
     (lambda import . \x2E;lambda)
     (?setter-name unbound)
     (desc-name unbound)
     (value unbound)
     (tuple-set! import . \x2E;tuple-set!)
     (field-names unbound)
     (and import . \x2E;and)
     (?getter-name unbound)
     (let import . \x2E;let)
     (quote import . \x2E;quote)
     (?make-name unbound)
     (datum->syntax import . \x2E;datum->syntax)
     (?field-names unbound)
     (struct-name unbound)
     (?_ unbound)
     (?getter-rules unbound)
     (syntax import . \x2E;syntax)
     (... import . \x2E;...)
     (syntax-rules import . \x2E;syntax-rules)
     (field-ref unbound)
     (define-syntax import . \x2E;define-syntax)
     (unquote import . \x2E;unquote)
     (pred-name unbound))
   (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/struct.scm" . 15365))
 (push.const . core.struct)
 (push.const . #f)
 (push.const (define-struct import . core.struct\x27;define-struct))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/struct.scm" . 34832))

((close
   (2 0 . list-elts=?)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;length 1 "../stdlib/core/optimize.scm" . 578583)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;length 1 "../stdlib/core/optimize.scm" . 578597)
   (subr.gloc.of \x2E;= 2 "../stdlib/core/optimize.scm" . 578580)
   (if.false.ret)
   (push.close
     (1 0)
     (push.iloc.0 . 0)
     (push.iloc.1 . 1)
     (ret.subr.gloc.of \x2E;memq "../stdlib/core/optimize.scm" . 579625))
   (push.iloc.0 . 0)
   (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 579604))
 (set.gloc.of list-elts=?\x60;2655*)
 (close
   (1 0)
   (push.gloc.of core.optimize\x27;ht-variable-binding)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 577549)
   (if.true.ret)
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;top-level-bound? 1 "../stdlib/core/optimize.scm" . 577549)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;top-level-value 1 "../stdlib/core/optimize.scm" . 577549)
     (gloc.of core.optimize\x27;denote-call/cc)
     (ret.eq? "../stdlib/core/optimize.scm" . 577549))
   (push)
   (ret.subr.gloc.of \x2E;not "../stdlib/core/optimize.scm" . 577549))
 (set.gloc.of \x2E;L1016)
 (close
   (1 0)
   (car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1209416)
   (if.symbol?
     (push.gloc.of core.optimize\x27;ht-variable-refc)
     (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1209416)
     (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 1223752)
     (if.false.ret)
     (push.const . define)
     (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1209416)
     (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1209430)
     (ret.subr.gloc.of \x2E;list "../stdlib/core/optimize.scm" . 1223747))
   (push.const . define)
   (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1209430)
   (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1209416)
   (ret.subr.gloc.of \x2E;list "../stdlib/core/optimize.scm" . 1222719))
 (set.gloc.of \x2E;L951)
 (close
   (1 0 . lift-variables)
   (push.gloc.of \x2E;L997)
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 541711))
 (set.gloc.of lift-variables\x60;2655*)
 (close
   (1 0)
   (push.const . #t)
   (push.const . "  expr: ~s~%")
   (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 248877)
   (subr.gloc.of \x2E;format 3 "../stdlib/core/optimize.scm" . 248851)
   (push.const . #t)
   (push.const . "  free: ~s~%---~%")
   (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 249906)
   (ret.subr.gloc.of \x2E;format "../stdlib/core/optimize.scm" . 249875))
 (set.gloc.of \x2E;L1015)
 (close
   (1 0 . concatenate?)
   (car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 380951)
   (if.not.pair?.ret.const . #f)
   (call
     (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 381979)
     (subr.gloc.of \x2E;list? 1 "../stdlib/core/optimize.scm" . 381972)
     (if.true.ret)
     (push.const . #f)
     (push.const . "expression is not a proper list")
     (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 383051)
     (apply.gloc.of \x2E;syntax-violation "../stdlib/core/optimize.scm" . 382996))
   (if.false.ret)
   (push.const . begin)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;caar 1 "../stdlib/core/optimize.scm" . 384028)
   (ret.eq? "../stdlib/core/optimize.scm" . 384016))
 (set.gloc.of concatenate?\x60;2549*)
 (close
   (1 0)
   (push.gloc.of core.optimize\x27;ht-variable-refc)
   (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1198180)
   (push.subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 1198137)
   (ret.subr.gloc.of \x2E;not "../stdlib/core/optimize.scm" . 1198132))
 (set.gloc.of \x2E;L1013)
 (close
   (1 0)
   (push.gloc.of core.optimize\x27;ht-variable-operands-refc)
   (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1104985)
   (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 1104933)
   (if.true.ret)
   (push.gloc.of core.optimize\x27;ht-variable-defined)
   (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1106003)
   (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 1105957)
   (if.true.ret)
   (push.gloc.of core.optimize\x27;ht-variable-pinned)
   (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1107026)
   (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 1106981)
   (if.true.ret)
   (push.gloc.of core.optimize\x27;ht-variable-letrec)
   (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1108055)
   (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 1108010)
   (if.false.ret.const . #t)
   (push.gloc.of core.optimize\x27;ht-lambda-node)
   (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1109076)
   (push.const . #f)
   (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 1109041)
   (subr.gloc.of \x2E;list? 1 "../stdlib/core/optimize.scm" . 1109034)
   (if.false.ret.const . #t)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;caddr 1 "../stdlib/core/optimize.scm" . 1110065)
   (subr.gloc.of \x2E;list? 1 "../stdlib/core/optimize.scm" . 1110058)
   (if.false.ret.const . #t)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;caddr 1 "../stdlib/core/optimize.scm" . 1111099)
   (push.subr.gloc.of \x2E;length 1 "../stdlib/core/optimize.scm" . 1111091)
   (push.const . 1)
   (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/optimize.scm" . 1111088)
   (extend . 1)
   (push.close
     (1 0)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;length 1 "../stdlib/core/optimize.scm" . 1112131)
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;= 2 "../stdlib/core/optimize.scm" . 1112128)
     (ret.subr.gloc.of \x2E;not "../stdlib/core/optimize.scm" . 1112123))
   (push.gloc.of core.optimize\x27;ht-variable-callsites)
   (push.car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 1113177)
   (push.const)
   (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 1113135)
   (apply.gloc.of core.lists\x27;exists "../stdlib/core/optimize.scm" . 1112103))
 (set.gloc.of \x2E;L984)
 (close
   (4 0 . make-mutual-list)
   (push.iloc.0 . 0)
   (push.iloc.0 . 2)
   (subr.gloc.of \x2E;memq 2 "../stdlib/core/optimize.scm" . 561174)
   (if.true (ret.iloc 0 . 3))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (push.subr.gloc.of \x2E;assq 2 "../stdlib/core/optimize.scm" . 562198)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 567341)
       (extend . 1)
       (push.iloc 4 . 0)
       (iloc.0 . 0)
       (if.eq?
         (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 569395)
         (push.iloc.1 . 1)
         (apply.iloc+ (2 . 0) "../stdlib/core/optimize.scm" . 569389))
       (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 571443)
       (call
         (touch.gloc.of make-mutual-list\x60;2655*)
         (push.iloc.0 . 0)
         (push.iloc 4 . 1)
         (push.iloc 4 . 0)
         (iloc 4 . 2)
         (push.cons)
         (push.iloc.0 . 0)
         (iloc.1 . 1)
         (push.cons)
         (apply.gloc.of make-mutual-list\x60;2655* "../stdlib/core/optimize.scm" . 572467))
       (push)
       (apply.iloc+ (2 . 0) "../stdlib/core/optimize.scm" . 571437))
     (push.iloc.1 . 0)
     (push.iloc 2 . 3)
     (apply.iloc+ (0 . 0) "../stdlib/core/optimize.scm" . 565277))
   (push.iloc.1 . 0)
   (iloc.1 . 3)
   (ret.cons "../stdlib/core/optimize.scm" . 574486))
 (set.gloc.of make-mutual-list\x60;2655*)
 (close
   (1 0)
   (push.gloc.of core.optimize\x27;ht-variable-pinned)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 577549))
 (set.gloc.of \x2E;L1012)
 (close
   (1 0)
   (push.const . \x2E;list)
   (iloc.0 . 0)
   (ret.cons "../stdlib/core/optimize.scm" . 948272))
 (set.gloc.of \x2E;L988)
 (close
   (1 0)
   (cadr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 577549)
   (if.true.ret)
   (ret.const begin #f))
 (set.gloc.of \x2E;L1014)
 (close
   (0 0 . resolve-mutual-recursion)
   (call
     (push.gloc.of \x2E;values)
     (call
       (push.gloc.of \x2E;L958)
       (push.gloc.of core.optimize\x27;ht-variable-binding)
       (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/optimize.scm" . 585759)
       (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 584730))
     (push)
     (apply.gloc.of core.lists\x27;filter "../stdlib/core/optimize.scm" . 583698))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (call
     (push.close
       (1 0)
       (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 590886)
       (call
         (call
           (touch.gloc.of make-mutual-list\x60;2655*)
           (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 592953)
           (push.iloc.1 . 0)
           (push.const)
           (push.const)
           (apply.gloc.of make-mutual-list\x60;2655* "../stdlib/core/optimize.scm" . 592935))
         (push)
         (apply.gloc.of
           core.lists\x27;remove-duplicate-symbols
           "../stdlib/core/optimize.scm"
           .
           591910))
       (ret.cons "../stdlib/core/optimize.scm" . 590880))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 589849))
   (push)
   (extend . 1)
   (push.close
     (1 0)
     (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 597032)
     (extend . 1)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (call
       (push.close
         (1 0)
         (push.iloc.0 . 0)
         (push.iloc 3 . 0)
         (push.subr.gloc.of \x2E;assq 2 "../stdlib/core/optimize.scm" . 600126)
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (touch.gloc.of list-elts=?\x60;2655*)
           (push.iloc 2 . 0)
           (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 600180)
           (apply.gloc.of list-elts=?\x60;2655* "../stdlib/core/optimize.scm" . 600164))
         (push.iloc.1 . 0)
         (apply.gloc.of
           core.optimize\x27;variable-top-level?
           "../stdlib/core/optimize.scm"
           .
           601155))
       (push.iloc.0 . 0)
       (apply.gloc.of
         core.lists\x27;for-all
         (core.lists\x27;for-all
           (lambda (id\x60;2698*)
             (let ((\x2E;L913\x60;2700* (\x2E;assq id\x60;2698* mutual-list\x60;2692*)))
               (if \x2E;L913\x60;2700*
                   (list-elts=?\x60;2655* c1\x60;2696* (\x2E;cdr \x2E;L913\x60;2700*))
                   (core.optimize\x27;variable-top-level? id\x60;2698*))))
           c1\x60;2696*)))
     (if.false.ret)
     (call
       (touch.gloc.of lift-variables\x60;2655*)
       (push.iloc.0 . 0)
       (apply.gloc.of lift-variables\x60;2655* "../stdlib/core/optimize.scm" . 604211))
     (ret.const . #t))
   (push.iloc.0 . 0)
   (apply.gloc.of
     core.lists\x27;exists
     (core.lists\x27;exists
       (lambda (m\x60;2694*)
         (let ((c1\x60;2696* (\x2E;cdr m\x60;2694*)))
           (and (\x2E;pair? c1\x60;2696*)
                (core.lists\x27;for-all
                  (lambda (id\x60;2698*)
                    (let ((\x2E;L913\x60;2700* (\x2E;assq id\x60;2698* mutual-list\x60;2692*)))
                      (if \x2E;L913\x60;2700*
                          (list-elts=?\x60;2655* c1\x60;2696* (\x2E;cdr \x2E;L913\x60;2700*))
                          (core.optimize\x27;variable-top-level? id\x60;2698*))))
                  c1\x60;2696*)
                (begin (lift-variables\x60;2655* c1\x60;2696*) #t))))
       mutual-list\x60;2692*)))
 (set.gloc.of resolve-mutual-recursion\x60;2629*)
 (close
   (2 0 . loop)
   (iloc.0 . 0)
   (if.null? (ret.iloc 0 . 1))
   (call
     (touch.gloc.of concatenate?\x60;2549*)
     (push.iloc.0 . 0)
     (apply.gloc.of concatenate?\x60;2549* "../stdlib/core/optimize.scm" . 389137))
   (if.true
     (touch.gloc.of loop\x60;2554*)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cdar 1 "../stdlib/core/optimize.scm" . 390167)
     (call
       (touch.gloc.of loop\x60;2554*)
       (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 391197)
       (push.iloc.0 . 1)
       (apply.gloc.of loop\x60;2554* "../stdlib/core/optimize.scm" . 391191))
     (push)
     (apply.gloc.of loop\x60;2554* "../stdlib/core/optimize.scm" . 390161))
   (iloc.0 . 1)
   (if.null? (ret.iloc 0 . 0))
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (ret.subr.gloc.of \x2E;append "../stdlib/core/optimize.scm" . 395288))
 (set.gloc.of loop\x60;2554*)
 (close
   (0 0 . traverse-variable-binding)
   (push.gloc.of \x2E;L993)
   (push.const . #f)
   (push.gloc.of core.optimize\x27;ht-variable-binding)
   (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/optimize.scm" . 520214)
   (apply.gloc.of core.lists\x27;fold-left "../stdlib/core/optimize.scm" . 500758))
 (set.gloc.of traverse-variable-binding\x60;2629*)
 (close
   (1 0)
   (push.gloc.of core.optimize\x27;ht-variable-binding)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 577549)
   (if.true.ret)
   (call
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;top-level-bound? 1 "../stdlib/core/optimize.scm" . 577549)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;top-level-value 1 "../stdlib/core/optimize.scm" . 577549)
     (gloc.of core.optimize\x27;denote-call/cc)
     (ret.eq? "../stdlib/core/optimize.scm" . 577549))
   (push)
   (ret.subr.gloc.of \x2E;not "../stdlib/core/optimize.scm" . 577549))
 (set.gloc.of \x2E;L998)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (apply.gloc.of core.optimize\x27;variable-functional? "../stdlib/core/optimize.scm" . 530496))
 (set.gloc.of \x2E;L1003)
 (close
   (1 0)
   (call
     (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1142833)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;cdddr 1 "../stdlib/core/optimize.scm" . 1142841)
     (push.const . #t)
     (apply.gloc.of core.optimize\x27;check-stackable-seq "../stdlib/core/optimize.scm" . 1142812))
   (if.false.ret)
   (call
     (push.gloc.of core.optimize\x27;ht-binding-body-mutual)
     (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1143886)
     (push.const . #f)
     (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 1143843)
     (extend . 1)
     (iloc.0 . 0)
     (if.true
       (push.close
         (1 0)
         (push.car.iloc (2 . 0) "../stdlib/core/optimize.scm" . 1145937)
         (push.iloc.0 . 0)
         (push.const . #f)
         (apply.gloc.of core.optimize\x27;check-stackable "../stdlib/core/optimize.scm" . 1145920))
       (call
         (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 1146935)
         (push.iloc.0 . 0)
         (apply.gloc.of core.lists\x27;remq "../stdlib/core/optimize.scm" . 1146929))
       (push)
       (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 1145896))
     (ret.const . #t))
   (if.false.ret)
   (call
     (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1148977)
     (push.gloc.of core.optimize\x27;ht-binding-body-common)
     (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1149028)
     (push.const)
     (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 1148985)
     (push.const . #t)
     (apply.gloc.of core.optimize\x27;check-stackable-seq "../stdlib/core/optimize.scm" . 1148956))
   (if.false.ret)
   (push.gloc.of core.optimize\x27;ht-variable-stackables)
   (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1152074)
   (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1152082)
   (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 1152030))
 (set.gloc.of \x2E;L985)
 (close
   (2 0)
   (push.gloc.of core.optimize\x27;ht-lambda-node)
   (push.cdr.iloc (0 . 1) "../stdlib/core/optimize.scm" . 501826)
   (push.const . #f)
   (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 501791)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (iloc.0 . 0)
     (if.null?
       (push.gloc.of core.optimize\x27;ht-lambda-node)
       (push.cdr.iloc (1 . 1) "../stdlib/core/optimize.scm" . 504911)
       (push.const . functable)
       (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/optimize.scm" . 504875)
       (ret.const . #t))
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;pair? 1 "../stdlib/core/optimize.scm" . 506928)
     (subr.gloc.of \x2E;not 1 "../stdlib/core/optimize.scm" . 506923)
     (if.true (ret.iloc 1 . 0))
     (call
       (cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 507959)
       (if.not.null?.ret.const . #f)
       (push.car.iloc (1 . 1) "../stdlib/core/optimize.scm" . 507976)
       (car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 507984)
       (ret.eq? "../stdlib/core/optimize.scm" . 507971))
     (if.true
       (push.gloc.of core.optimize\x27;ht-lambda-node)
       (push.cdr.iloc (1 . 1) "../stdlib/core/optimize.scm" . 509007)
       (push.const . functable)
       (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/optimize.scm" . 508971)
       (ret.const . #t))
     (call
       (push.close
         (1 0)
         (push.car.iloc (2 . 1) "../stdlib/core/optimize.scm" . 511050)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.iloc.0 . 0)
         (apply.gloc.of
           core.optimize\x27;variable-functional?
           "../stdlib/core/optimize.scm"
           .
           511062))
       (push.iloc.0 . 0)
       (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 511019))
     (if.true
       (push.gloc.of core.optimize\x27;ht-lambda-node)
       (push.cdr.iloc (1 . 1) "../stdlib/core/optimize.scm" . 512079)
       (push.const . functable)
       (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/optimize.scm" . 512043)
       (ret.const . #t))
     (call
       (push.close
         (1 0)
         (push.car.iloc (2 . 1) "../stdlib/core/optimize.scm" . 514122)
         (iloc.0 . 0)
         (if.eq?.ret.const . #t)
         (push.iloc.0 . 0)
         (apply.gloc.of
           core.optimize\x27;variable-top-level?
           "../stdlib/core/optimize.scm"
           .
           514134))
       (push.iloc.0 . 0)
       (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 514091))
     (if.true
       (push.gloc.of core.optimize\x27;ht-lambda-node)
       (push.cdr.iloc (1 . 1) "../stdlib/core/optimize.scm" . 515151)
       (push.const . liftable)
       (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/optimize.scm" . 515115)
       (ret.const . #t))
     (ret.iloc 1 . 0))
   (ret.iloc 1 . 0))
 (set.gloc.of \x2E;L993)
 (close
   (1 0)
   (push.iloc.0 . 0)
   (apply.gloc.of core.optimize\x27;variable-top-level? "../stdlib/core/optimize.scm" . 532544))
 (set.gloc.of \x2E;L947)
 (close
   (1 0)
   (push.gloc.of core.optimize\x27;ht-lambda-node)
   (push.cadr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1071218)
   (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 1071177)
   (if.false.ret)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;car "../stdlib/core/optimize.scm" . 1071228))
 (set.gloc.of \x2E;L986)
 (close (3 0) (ret.iloc 0 . 0))
 (set.gloc.of \x2E;L961)
 (close
   (1 0)
   (push.const . #t)
   (push.const . "  variable: ~s~%")
   (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 257073)
   (subr.gloc.of \x2E;format 3 "../stdlib/core/optimize.scm" . 257043)
   (push.const . #t)
   (push.const . "  expr: ~s~%")
   (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 258093)
   (subr.gloc.of \x2E;format 3 "../stdlib/core/optimize.scm" . 258067)
   (push.const . #t)
   (push.const . "  stat: ~s~%---~%")
   (push.gloc.of core.optimize\x27;ht-lambda-node)
   (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 259157)
   (push.const . #f)
   (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 259122)
   (ret.subr.gloc.of \x2E;format "../stdlib/core/optimize.scm" . 259091))
 (set.gloc.of \x2E;L995)
 (close
   (1 0)
   (push.const . \x2E;list)
   (iloc.0 . 0)
   (ret.cons "../stdlib/core/optimize.scm" . 949316))
 (set.gloc.of \x2E;L1007)
 (close
   (2 0 . flatten-expression)
   (call
     (extend.enclose+
       (2 0 . loop)
       (iloc.0 . 0)
       (if.null? (ret.iloc 0 . 1))
       (call
         (car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 926753)
         (if.not.pair?.ret.const . #f)
         (push.iloc 2 . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of \x2E;caar 1 "../stdlib/core/optimize.scm" . 926773)
         (ret.eq? "../stdlib/core/optimize.scm" . 926764))
       (if.true
         (push.iloc.0 . 0)
         (push.subr.gloc.of \x2E;cdar 1 "../stdlib/core/optimize.scm" . 927771)
         (call
           (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 928801)
           (push.iloc.0 . 1)
           (apply.iloc+ (1 . 0) "../stdlib/core/optimize.scm" . 928795))
         (push)
         (apply.iloc+ (1 . 0) "../stdlib/core/optimize.scm" . 927765))
       (call
         (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 930853)
         (push.iloc.0 . 1)
         (apply.iloc+ (1 . 0) "../stdlib/core/optimize.scm" . 930847))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 931875)
       (if.eq? (ret.iloc 1 . 0))
       (push.car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 933921)
       (iloc.0 . 0)
       (ret.cons "../stdlib/core/optimize.scm" . 933915))
     (push.iloc.1 . 0)
     (push.const)
     (apply.iloc+ (0 . 0) "../stdlib/core/optimize.scm" . 925710))
   (push)
   (push.iloc.0 . 0)
   (call (apply.gloc.of core.optimize\x27;annotate-hook "../stdlib/core/optimize.scm" . 923660))
   (apply))
 (set.gloc.of flatten-expression\x60;2905*)
 (close
   (1 0)
   (push.gloc.of core.optimize\x27;ht-lambda-node)
   (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 525377)
   (push.const . #f)
   (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 525342)
   (extend . 1)
   (iloc.0 . 0)
   (if.true
     (iloc.0 . 0)
     (if.null?
       (push.gloc.of core.optimize\x27;ht-lambda-node)
       (push.car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 528462)
       (push.const . functable)
       (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 528426))
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #t)
     (call
       (push.gloc.of \x2E;L1003)
       (push.iloc.0 . 0)
       (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 530474))
     (if.true
       (push.gloc.of core.optimize\x27;ht-lambda-node)
       (push.car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 531534)
       (push.const . functable)
       (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 531498))
     (call
       (push.gloc.of \x2E;L947)
       (push.iloc.0 . 0)
       (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 532522))
     (if.true
       (push.gloc.of core.optimize\x27;ht-lambda-node)
       (push.car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 533582)
       (push.const . liftable)
       (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 533546))
     (ret.const.unspec))
   (ret.const.unspec))
 (set.gloc.of \x2E;L996)
 (close
   (1 0 . make-depend-list)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.optimize\x27;get-free-variables "../stdlib/core/optimize.scm" . 550934))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.false.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;list? 1 "../stdlib/core/optimize.scm" . 552992)
   (if.false.ret)
   (call
     (push.gloc.of core.optimize\x27;variable-top-level?)
     (push.iloc.0 . 0)
     (apply.gloc.of core.lists\x27;remp "../stdlib/core/optimize.scm" . 554028))
   (push)
   (extend . 1)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #f)
   (push.iloc 2 . 0)
   (iloc.0 . 0)
   (ret.cons "../stdlib/core/optimize.scm" . 556071))
 (set.gloc.of make-depend-list\x60;2655*)
 (close (2 0) (ret.iloc 0 . 0))
 (set.gloc.of \x2E;L1006)
 (close (2 0) (ret.iloc 0 . 0))
 (set.gloc.of \x2E;L992)
 (close
   (0 0 . loop)
   (call
     (touch.gloc.of traverse-variable-binding\x60;2629*)
     (apply.gloc.of traverse-variable-binding\x60;2629* "../stdlib/core/optimize.scm" . 626704))
   (if.true
     (touch.gloc.of loop\x60;2719*)
     (apply.gloc.of loop\x60;2719* "../stdlib/core/optimize.scm" . 626732))
   (call
     (touch.gloc.of resolve-mutual-recursion\x60;2629*)
     (apply.gloc.of resolve-mutual-recursion\x60;2629* "../stdlib/core/optimize.scm" . 627728))
   (if.true
     (touch.gloc.of loop\x60;2719*)
     (apply.gloc.of loop\x60;2719* "../stdlib/core/optimize.scm" . 627755))
   (ret.const.unspec))
 (set.gloc.of loop\x60;2719*)
 (close
   (1 0)
   (push.gloc.of core.optimize\x27;ht-lambda-node)
   (push.gloc.of core.optimize\x27;ht-variable-binding)
   (push.iloc.0 . 0)
   (push.const . #f)
   (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 544796)
   (push.const . liftable)
   (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 542747))
 (set.gloc.of \x2E;L997)
 (close
   (1 0 . loop)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.optimize\x27;pretty "../stdlib/core/optimize.scm" . 1243156))
   (push)
   (extend . 1)
   (push.iloc.0 . 0)
   (iloc.1 . 0)
   (if.eq? (ret.iloc 1 . 0))
   (touch.gloc.of loop\x60;3182*)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;3182* "../stdlib/core/optimize.scm" . 1245207))
 (set.gloc.of loop\x60;3182*)
 (close
   (1 0 . post-transform)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.optimize\x27;process-stackable "../stdlib/core/optimize.scm" . 1161227))
   (call
     (push.gloc.of \x2E;L941)
     (push.gloc.of core.optimize\x27;ht-variable-stackables)
     (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/optimize.scm" . 1163285)
     (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 1162251))
   (ret.iloc 0 . 0))
 (set.gloc.of post-transform\x60;3142*)
 (close
   (2 0 . loop)
   (call (apply.gloc.of core.optimize\x27;clear-context "../stdlib/core/optimize.scm" . 1177609))
   (call
     (push.iloc.0 . 0)
     (push.const)
     (push.const)
     (push.const . #f)
     (apply.gloc.of core.optimize\x27;collect-context "../stdlib/core/optimize.scm" . 1178633))
   (call
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (apply.gloc.of core.optimize\x27;crawl-lambda-lifting "../stdlib/core/optimize.scm" . 1179678))
   (push)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.optimize\x27;crawl-beta-subst "../stdlib/core/optimize.scm" . 1180708))
   (push)
   (extend . 2)
   (call
     (gloc.of core.optimize\x27;max-transform-pass)
     (>=.iloc (1 . 1) "../stdlib/core/optimize.scm" . 1194007)
     (if.false.ret)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;core-hashtable-size 1 "../stdlib/core/optimize.scm" . 1195038)
     (push.const . 0)
     (subr.gloc.of \x2E;> 2 "../stdlib/core/optimize.scm" . 1195035)
     (if.true.ret)
     (push.iloc.0 . 1)
     (push.subr.gloc.of \x2E;core-hashtable-size 1 "../stdlib/core/optimize.scm" . 1196062)
     (push.const . 0)
     (subr.gloc.of \x2E;> 2 "../stdlib/core/optimize.scm" . 1196059)
     (if.true.ret)
     (=n.iloc (1 . 1) 1 "../stdlib/core/optimize.scm" . 1197088)
     (if.false.ret)
     (push.gloc.of \x2E;L1013)
     (push.gloc.of core.optimize\x27;ht-variable-binding)
     (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/optimize.scm" . 1199144)
     (apply.gloc.of core.lists\x27;exists "../stdlib/core/optimize.scm" . 1198112))
   (if.true
     (touch.gloc.of loop\x60;3151*)
     (push.const . begin)
     (call
       (push.close
         (1 0)
         (extend.enclose+
           (1 0 . loop)
           (call
             (push.iloc.0 . 0)
             (push.iloc 3 . 0)
             (push.iloc 3 . 1)
             (apply.gloc.of core.optimize\x27;transcribe "../stdlib/core/optimize.scm" . 1231930))
           (push)
           (extend . 1)
           (push.iloc.0 . 0)
           (iloc.1 . 0)
           (if.eq? (ret.iloc 1 . 0))
           (push.iloc.0 . 0)
           (apply.iloc+ (2 . 0) "../stdlib/core/optimize.scm" . 1233981))
         (push.iloc.1 . 0)
         (apply.iloc+ (0 . 0) "../stdlib/core/optimize.scm" . 1231919))
       (call
         (push.const . begin)
         (call
           (push.gloc.of \x2E;values)
           (call
             (push.gloc.of \x2E;L951)
             (push.iloc.0 . 0)
             (push.subr.gloc.of
               \x2E;core-hashtable->alist
               1
               "../stdlib/core/optimize.scm"
               .
               1226811)
             (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 1208374))
           (push)
           (apply.gloc.of core.lists\x27;filter "../stdlib/core/optimize.scm" . 1207342))
         (push.cons)
         (push.iloc.1 . 0)
         (push.subr.gloc.of \x2E;list 2 "../stdlib/core/optimize.scm" . 1234987)
         (apply.gloc.of core.optimize\x27;flatten-begin "../stdlib/core/optimize.scm" . 1234987))
       (push)
       (apply.gloc.of
         \x2E;map
         (\x2E;map
           (lambda (e\x60;3165*)
             (letrec* ((loop\x60;3169*
                         (lambda (e\x60;3170*)
                           (let ((new\x60;3172*
                                   (core.optimize\x27;transcribe
                                     e\x60;3170*
                                     ht-lift-table\x60;3154*
                                     ht-bata-subst-table\x60;3154*)))
                             (if (\x2E;eq? new\x60;3172* e\x60;3170*)
                                 e\x60;3170*
                                 (loop\x60;3169* new\x60;3172*))))))
               (loop\x60;3169* e\x60;3165*)))
           (core.optimize\x27;flatten-begin
             (\x2E;list
               (\x2E;cons
                 'begin
                 (core.lists\x27;filter
                   \x2E;values
                   (\x2E;map \x2E;L951 (\x2E;core-hashtable->alist ht-lift-table\x60;3154*))))
               form\x60;3152*)))))
     (push.cons)
     (push.n+.iloc (1 . 1) 1 "../stdlib/core/optimize.scm" . 1236001)
     (apply.gloc.of
       loop\x60;3151*
       (loop\x60;3151*
         (\x2E;cons
           'begin
           (\x2E;map
             (lambda (e\x60;3165*)
               (letrec* ((loop\x60;3169*
                           (lambda (e\x60;3170*)
                             (let ((new\x60;3172*
                                     (core.optimize\x27;transcribe
                                       e\x60;3170*
                                       ht-lift-table\x60;3154*
                                       ht-bata-subst-table\x60;3154*)))
                               (if (\x2E;eq? new\x60;3172* e\x60;3170*)
                                   e\x60;3170*
                                   (loop\x60;3169* new\x60;3172*))))))
                 (loop\x60;3169* e\x60;3165*)))
             (core.optimize\x27;flatten-begin
               (\x2E;list
                 (\x2E;cons
                   'begin
                   (core.lists\x27;filter
                     \x2E;values
                     (\x2E;map \x2E;L951 (\x2E;core-hashtable->alist ht-lift-table\x60;3154*))))
                 form\x60;3152*))))
         (\x2E;+ pass\x60;3152* 1))))
   (touch.gloc.of post-transform\x60;3142*)
   (push.iloc.1 . 0)
   (apply.gloc.of post-transform\x60;3142* "../stdlib/core/optimize.scm" . 1238034))
 (set.gloc.of loop\x60;3151*)
 (close
   (0 0 . make-table)
   (subr.gloc.of \x2E;make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 611377)
       (if.not.symbol?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 611410)
       (call (apply.gloc.of \x2E;generate-temporary-symbol "../stdlib/core/optimize.scm" . 611418))
       (push)
       (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 611386))
     (push.gloc.of core.optimize\x27;ht-lambda-node)
     (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/optimize.scm" . 612375)
     (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 611341))
   (call
     (push.close
       (1 0)
       (push.gloc.of core.optimize\x27;ht-lambda-node)
       (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 614467)
       (push.const . #f)
       (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 614432)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (iloc.0 . 0)
         (if.symbol?
           (push.iloc 2 . 0)
           (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 617543)
           (subr.gloc.of \x2E;core-hashtable-delete! 2 "../stdlib/core/optimize.scm" . 617516)
           (push.iloc 2 . 0)
           (push.car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 618564)
           (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 618572)
           (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 618540))
         (ret.const.unspec))
       (ret.const.unspec))
     (push.gloc.of core.optimize\x27;ht-variable-binding)
     (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/optimize.scm" . 619543)
     (apply.gloc.of
       \x2E;for-each
       (\x2E;for-each
         (lambda (b\x60;2710*)
           (let ((\x2E;L914\x60;2712*
                   (\x2E;core-hashtable-ref
                     core.optimize\x27;ht-lambda-node
                     (\x2E;cdr b\x60;2710*)
                     #f)))
             (if \x2E;L914\x60;2712*
                 (if (\x2E;symbol? \x2E;L914\x60;2712*)
                     (begin
                       (\x2E;core-hashtable-delete! ht\x60;2706* (\x2E;cdr b\x60;2710*))
                       (\x2E;core-hashtable-set!
                         ht\x60;2706*
                         (\x2E;car b\x60;2710*)
                         (\x2E;cdr b\x60;2710*)))
                     (\x2E;unspecified))
                 (\x2E;unspecified))))
         (\x2E;core-hashtable->alist core.optimize\x27;ht-variable-binding))))
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 621620)
       (ret.subr.gloc.of \x2E;core-hashtable-delete! "../stdlib/core/optimize.scm" . 621593))
     (push.gloc.of core.optimize\x27;ht-variable-defined)
     (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/optimize.scm" . 622615)
     (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 620557))
   (ret.iloc 0 . 0))
 (set.gloc.of make-table\x60;2629*)
 (close
   (1 0)
   (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1162297)
   (push.const . stack)
   (apply.gloc.of core.optimize\x27;closure-attribute-set! "../stdlib/core/optimize.scm" . 1162273))
 (set.gloc.of \x2E;L941)
 (close
   (0 0 . traverse-lambda-node)
   (push.gloc.of \x2E;L996)
   (push.gloc.of core.optimize\x27;ht-lambda-node)
   (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/optimize.scm" . 534549)
   (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 524309))
 (set.gloc.of traverse-lambda-node\x60;2629*)
 (close
   (1 0)
   (push.gloc.of core.optimize\x27;ht-variable-pinned)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 577549))
 (set.gloc.of \x2E;L991)
 (close
   (1 0)
   (push.gloc.of core.optimize\x27;ht-variable-formals)
   (push.iloc.0 . 0)
   (push.const . #t)
   (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 577549))
 (set.gloc.of \x2E;L953)
 (close
   (1 0)
   (push.gloc.of core.optimize\x27;ht-variable-stackables)
   (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1139806)
   (ret.subr.gloc.of \x2E;core-hashtable-contains? "../stdlib/core/optimize.scm" . 1139757))
 (set.gloc.of \x2E;L949)
 (close
   (1 0)
   (touch.gloc.of make-depend-list\x60;2655*)
   (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 584765)
   (apply.gloc.of make-depend-list\x60;2655* "../stdlib/core/optimize.scm" . 584747))
 (set.gloc.of \x2E;L958)
 (close
   (1 0 . loop)
   (iloc.0 . 0)
   (if.null?.ret.const)
   (call
     (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 903202)
     (apply.gloc.of core.optimize\x27;pretty "../stdlib/core/optimize.scm" . 903194))
   (push)
   (call
     (touch.gloc.of loop\x60;2898*)
     (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 903224)
     (apply.gloc.of loop\x60;2898* "../stdlib/core/optimize.scm" . 903218))
   (push)
   (extend . 2)
   (call
     (push.iloc.0 . 0)
     (car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 904227)
     (if.not.eq?.ret.const . #f)
     (push.iloc.0 . 1)
     (cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 904246)
     (ret.eq? "../stdlib/core/optimize.scm" . 904238))
   (if.true (ret.iloc 1 . 0))
   (push.iloc.0 . 0)
   (iloc.0 . 1)
   (ret.cons "../stdlib/core/optimize.scm" . 906262))
 (set.gloc.of loop\x60;2898*)
 (close
   (1 0)
   (push.gloc.of core.optimize\x27;ht-variable-stackables)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;core-hashtable-contains? "../stdlib/core/optimize.scm" . 1094709))
 (set.gloc.of \x2E;L943)
 (close
   (1 0)
   (call
     (push.iloc.0 . 0)
     (const . #f)
     (if.eq?
       (push.gloc.of \x2E;L961)
       (apply.gloc.of \x2E;current-after-expansion-hook "../stdlib/core/optimize.scm" . 1270800))
     (push.gloc.of core.optimize\x27;optimize)
     (apply.gloc.of \x2E;current-after-expansion-hook "../stdlib/core/optimize.scm" . 1271824))
   (ret.iloc 0 . 0))
 (set.gloc.of \x2E;L975)
 (call
   (push.const core parameters)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/optimize.scm" . 577549))
 (call
   (push.const core destructuring)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/optimize.scm" . 577549))
 (call
   (push.const core lists)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/optimize.scm" . 577549))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library "../stdlib/core/optimize.scm" . 577549))
 (const . 5)
 (set.gloc.of core.optimize\x27;max-transform-pass)
 (const . 200)
 (set.gloc.of core.optimize\x27;limit-arguments)
 (call
   (subr.gloc.of \x2E;make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;top-level-value 1 "../stdlib/core/optimize.scm" . 42037)
       (push.const . #t)
       (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 42013))
     (push.const
       \x2E;eq?
       \x2E;eqv?
       \x2E;equal?
       \x2E;procedure?
       \x2E;number?
       \x2E;complex?
       \x2E;real?
       \x2E;rational?
       \x2E;integer?
       \x2E;real-valued?
       \x2E;rational-valued?
       \x2E;integer-valued?
       \x2E;exact?
       \x2E;inexact?
       \x2E;=
       \x2E;<
       \x2E;>
       \x2E;<=
       \x2E;>=
       \x2E;zero?
       \x2E;positive?
       \x2E;negative?
       \x2E;odd?
       \x2E;even?
       \x2E;finite?
       \x2E;infinite?
       \x2E;nan?
       \x2E;not
       \x2E;boolean?
       \x2E;boolean=?
       \x2E;pair?
       \x2E;null?
       \x2E;list?
       \x2E;symbol?
       \x2E;symbol=?
       \x2E;char?
       \x2E;char=?
       \x2E;char<?
       \x2E;char>?
       \x2E;char<=?
       \x2E;char>=?
       \x2E;string?
       \x2E;string=?
       \x2E;string<?
       \x2E;string>?
       \x2E;string<=?
       \x2E;string>=?
       \x2E;vector?
       \x2E;flonum?
       \x2E;fl=?
       \x2E;fl<?
       \x2E;fl>?
       \x2E;fl<=?
       \x2E;fl>=?
       \x2E;flinteger?
       \x2E;flzero?
       \x2E;flpositive?
       \x2E;flnegative?
       \x2E;flodd?
       \x2E;fleven?
       \x2E;flfinite?
       \x2E;flinfinite?
       \x2E;flnan?
       \x2E;fixnum?
       \x2E;fx=?
       \x2E;fx<?
       \x2E;fx>?
       \x2E;fx<=?
       \x2E;fx>=?
       \x2E;fxzero?
       \x2E;fxpositive?
       \x2E;fxnegative?
       \x2E;fxodd?
       \x2E;fxeven?
       \x2E;identifier?
       \x2E;bound-identifier=?
       \x2E;free-identifier=?
       \x2E;record?
       \x2E;record-type-generative?
       \x2E;record-type-sealed?
       \x2E;record-type-opaque?
       \x2E;record-field-mutable?
       \x2E;record-type-descriptor?
       \x2E;record-type?
       \x2E;condition?
       \x2E;message-condition?
       \x2E;warning?
       \x2E;serious-condition?
       \x2E;error?
       \x2E;violation?
       \x2E;assertion-violation?
       \x2E;irritants-condition?
       \x2E;who-condition?
       \x2E;non-continuable-violation?
       \x2E;implementation-restriction-violation?
       \x2E;lexical-violation?
       \x2E;syntax-violation?
       \x2E;undefined-violation?
       \x2E;char-whitespace?
       \x2E;eof-object?
       \x2E;input-port?
       \x2E;output-port?
       \x2E;port?
       \x2E;nonblock-byte-ready?
       \x2E;port-has-port-position?
       \x2E;port-has-set-port-position!?
       \x2E;port-eof?
       \x2E;i/o-error?
       \x2E;i/o-read-error?
       \x2E;i/o-write-error?
       \x2E;i/o-invalid-position-error?
       \x2E;i/o-filename-error?
       \x2E;i/o-file-protection-error?
       \x2E;i/o-file-is-read-only-error?
       \x2E;i/o-file-already-exists-error?
       \x2E;i/o-file-does-not-exist-error?
       \x2E;i/o-port-error?
       \x2E;i/o-decoding-error?
       \x2E;i/o-encoding-error?
       \x2E;file-exists?
       \x2E;bytevector?
       \x2E;bytevector=?
       \x2E;unspecified?
       \x2E;tuple?
       \x2E;weak-mapping?
       \x2E;core-hashtable?
       \x2E;weak-core-hashtable?
       \x2E;core-hashtable-contains?
       \x2E;core-hashtable-mutable?
       \x2E;top-level-bound?
       \x2E;subr?
       \x2E;inexact
       \x2E;exact
       \x2E;max
       \x2E;min
       \x2E;+
       \x2E;*
       \x2E;-
       \x2E;/
       \x2E;abs
       \x2E;div-and-mod
       \x2E;div
       \x2E;mod
       \x2E;div0-and-mod0
       \x2E;div0
       \x2E;mod0
       \x2E;gcd
       \x2E;lcm
       \x2E;numerator
       \x2E;denominator
       \x2E;floor
       \x2E;ceiling
       \x2E;truncate
       \x2E;round
       \x2E;rationalize
       \x2E;exp
       \x2E;log
       \x2E;sin
       \x2E;cos
       \x2E;tan
       \x2E;asin
       \x2E;acos
       \x2E;atan
       \x2E;sqrt
       \x2E;exact-integer-sqrt
       \x2E;expt
       \x2E;make-rectangular
       \x2E;make-polar
       \x2E;real-part
       \x2E;imag-part
       \x2E;magnitude
       \x2E;angle
       \x2E;number->string
       \x2E;string->number
       \x2E;cons
       \x2E;car
       \x2E;cdr
       \x2E;caar
       \x2E;cadr
       \x2E;cdar
       \x2E;cddr
       \x2E;caaar
       \x2E;caadr
       \x2E;cadar
       \x2E;caddr
       \x2E;cdaar
       \x2E;cdadr
       \x2E;cddar
       \x2E;cdddr
       \x2E;caaaar
       \x2E;caaadr
       \x2E;caadar
       \x2E;caaddr
       \x2E;cadaar
       \x2E;cadadr
       \x2E;caddar
       \x2E;cadddr
       \x2E;cdaaar
       \x2E;cdaadr
       \x2E;cdadar
       \x2E;cdaddr
       \x2E;cddaar
       \x2E;cddadr
       \x2E;cdddar
       \x2E;cddddr
       \x2E;list
       \x2E;length
       \x2E;append
       \x2E;reverse
       \x2E;list-tail
       \x2E;list-ref
       \x2E;symbol->string
       \x2E;string->symbol
       \x2E;char->integer
       \x2E;integer->char
       \x2E;make-string
       \x2E;string
       \x2E;string-length
       \x2E;string-ref
       \x2E;substring
       \x2E;string-append
       \x2E;string->list
       \x2E;list->string
       \x2E;string-copy
       \x2E;make-vector
       \x2E;vector
       \x2E;vector-length
       \x2E;vector-ref
       \x2E;vector->list
       \x2E;list->vector
       \x2E;values
       \x2E;cons*
       \x2E;memq
       \x2E;memv
       \x2E;member
       \x2E;assq
       \x2E;assv
       \x2E;assoc
       \x2E;list-head
       \x2E;list-copy
       \x2E;circular-list?
       \x2E;cyclic-object?
       \x2E;vector-copy
       \x2E;datum->syntax
       \x2E;syntax->datum
       \x2E;syntax/i0n
       \x2E;syntax/i1n
       \x2E;syntax/i2n
       \x2E;syntax/i3n
       \x2E;syntax/c0n
       \x2E;syntax/c1n
       \x2E;syntax/c2n
       \x2E;syntax/c3n
       \x2E;syntax/i0e
       \x2E;syntax/i1e
       \x2E;syntax/i2e
       \x2E;syntax/i3e
       \x2E;syntax/c0e
       \x2E;syntax/c1e
       \x2E;syntax/c2e
       \x2E;syntax/c3e
       \x2E;string-contains
       \x2E;symbol-contains
       \x2E;top-level-value
       \x2E;unspecified
       \x2E;tuple
       \x2E;make-tuple
       \x2E;tuple-ref
       \x2E;tuple-length
       \x2E;tuple-index
       \x2E;tuple->list
       \x2E;make-core-hashtable
       \x2E;make-weak-core-hashtable
       \x2E;core-hashtable-ref
       \x2E;core-hashtable->alist
       \x2E;core-hashtable-size
       \x2E;core-hashtable-copy
       \x2E;core-hashtable-equivalence-function
       \x2E;core-hashtable-hash-function
       \x2E;current-library-infix
       \x2E;current-library-suffix
       \x2E;current-primitive-prefix
       \x2E;current-rename-delimiter
       \x2E;native-endianness
       \x2E;bytevector?
       \x2E;make-bytevector
       \x2E;bytevector-length
       \x2E;bytevector=?
       \x2E;bytevector-copy
       \x2E;bytevector->u8-list
       \x2E;u8-list->bytevector
       \x2E;bytevector-u8-ref
       \x2E;bytevector-s8-ref
       \x2E;bytevector-u16-ref
       \x2E;bytevector-s16-ref
       \x2E;bytevector-u16-native-ref
       \x2E;bytevector-s16-native-ref
       \x2E;bytevector-u32-ref
       \x2E;bytevector-s32-ref
       \x2E;bytevector-u32-native-ref
       \x2E;bytevector-s32-native-ref
       \x2E;bytevector-u64-ref
       \x2E;bytevector-s64-ref
       \x2E;bytevector-u64-native-ref
       \x2E;bytevector-s64-native-ref
       \x2E;bytevector-ieee-single-ref
       \x2E;bytevector-ieee-single-native-ref
       \x2E;bytevector-ieee-double-ref
       \x2E;bytevector-ieee-double-native-ref
       \x2E;bytevector-c-short-ref
       \x2E;bytevector-c-int-ref
       \x2E;bytevector-c-long-ref
       \x2E;bytevector-c-long-long-ref
       \x2E;bytevector-c-void*-ref
       \x2E;bytevector-c-unsigned-short-ref
       \x2E;bytevector-c-unsigned-int-ref
       \x2E;bytevector-c-unsigned-long-ref
       \x2E;bytevector-c-unsigned-long-long-ref
       \x2E;bytevector-c-int8-ref
       \x2E;bytevector-c-int16-ref
       \x2E;bytevector-c-int32-ref
       \x2E;bytevector-c-int64-ref
       \x2E;bytevector-c-uint8-ref
       \x2E;bytevector-c-uint16-ref
       \x2E;bytevector-c-uint32-ref
       \x2E;bytevector-c-uint64-ref
       \x2E;bytevector-c-float-ref
       \x2E;bytevector-c-double-ref
       \x2E;bytevector-c-strlen
       \x2E;string->utf8/nul)
     (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 41991))
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;core-hashtable-copy "../stdlib/core/optimize.scm" . 192519))
 (set.gloc.of core.optimize\x27;ht-primitive-functions)
 (call
   (subr.gloc.of \x2E;make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;top-level-value 1 "../stdlib/core/optimize.scm" . 196661)
       (push.const . #t)
       (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 196637))
     (push.const \x2E;car \x2E;cdr \x2E;cadr \x2E;cddr)
     (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 196615))
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;core-hashtable-copy "../stdlib/core/optimize.scm" . 198663))
 (set.gloc.of core.optimize\x27;ht-inlinable-primitive-functions)
 (call
   (subr.gloc.of \x2E;make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.subr.gloc.of \x2E;top-level-value 1 "../stdlib/core/optimize.scm" . 203829)
       (push.const . #t)
       (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 203805))
     (push.const \x2E;map \x2E;for-each)
     (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 203783))
   (call
     (push.close
       (1 0)
       (push.iloc.1 . 0)
       (push.iloc.0 . 0)
       (push.const . #t)
       (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 205853))
     (push.gloc.of core.lists\x27;find)
     (push.gloc.of core.lists\x27;for-all)
     (push.gloc.of core.lists\x27;exists)
     (push.gloc.of core.lists\x27;filter)
     (push.gloc.of core.lists\x27;partition)
     (push.gloc.of core.lists\x27;fold-left)
     (push.gloc.of core.lists\x27;fold-right)
     (push.gloc.of core.lists\x27;assp)
     (push.gloc.of core.lists\x27;memp)
     (push.gloc.of core.lists\x27;remp)
     (push.subr.gloc.of \x2E;list 10 "../stdlib/core/optimize.scm" . 206865)
     (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 205831))
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;core-hashtable-copy "../stdlib/core/optimize.scm" . 207879))
 (set.gloc.of core.optimize\x27;ht-special-list-functions)
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 209948)
 (set.gloc.of core.optimize\x27;ht-variable-refc)
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 210975)
 (set.gloc.of core.optimize\x27;ht-variable-binding)
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 211998)
 (set.gloc.of core.optimize\x27;ht-variable-letrec)
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 213023)
 (set.gloc.of core.optimize\x27;ht-variable-defined)
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 214047)
 (set.gloc.of core.optimize\x27;ht-variable-formals)
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 215072)
 (set.gloc.of core.optimize\x27;ht-variable-assigned)
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 216101)
 (set.gloc.of core.optimize\x27;ht-variable-operands-refc)
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 217121)
 (set.gloc.of core.optimize\x27;ht-variable-callsites)
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 218142)
 (set.gloc.of core.optimize\x27;ht-variable-pinned)
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 219168)
 (set.gloc.of core.optimize\x27;ht-variable-privates)
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 220194)
 (set.gloc.of core.optimize\x27;ht-variable-stackables)
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 221210)
 (set.gloc.of core.optimize\x27;ht-lambda-node)
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 222242)
 (set.gloc.of core.optimize\x27;ht-binding-body-common)
 (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 223266)
 (set.gloc.of core.optimize\x27;ht-binding-body-mutual)
 (close
   (0 0 . core.optimize\x27;clear-context)
   (push.gloc.of core.optimize\x27;ht-variable-refc)
   (subr.gloc.of \x2E;core-hashtable-clear! 1 "../stdlib/core/optimize.scm" . 227335)
   (push.gloc.of core.optimize\x27;ht-variable-binding)
   (subr.gloc.of \x2E;core-hashtable-clear! 1 "../stdlib/core/optimize.scm" . 228359)
   (push.gloc.of core.optimize\x27;ht-variable-letrec)
   (subr.gloc.of \x2E;core-hashtable-clear! 1 "../stdlib/core/optimize.scm" . 229383)
   (push.gloc.of core.optimize\x27;ht-variable-defined)
   (subr.gloc.of \x2E;core-hashtable-clear! 1 "../stdlib/core/optimize.scm" . 230407)
   (push.gloc.of core.optimize\x27;ht-variable-formals)
   (subr.gloc.of \x2E;core-hashtable-clear! 1 "../stdlib/core/optimize.scm" . 231431)
   (push.gloc.of core.optimize\x27;ht-variable-assigned)
   (subr.gloc.of \x2E;core-hashtable-clear! 1 "../stdlib/core/optimize.scm" . 232455)
   (push.gloc.of core.optimize\x27;ht-variable-operands-refc)
   (subr.gloc.of \x2E;core-hashtable-clear! 1 "../stdlib/core/optimize.scm" . 233479)
   (push.gloc.of core.optimize\x27;ht-variable-callsites)
   (subr.gloc.of \x2E;core-hashtable-clear! 1 "../stdlib/core/optimize.scm" . 234503)
   (push.gloc.of core.optimize\x27;ht-variable-pinned)
   (subr.gloc.of \x2E;core-hashtable-clear! 1 "../stdlib/core/optimize.scm" . 235527)
   (push.gloc.of core.optimize\x27;ht-variable-privates)
   (subr.gloc.of \x2E;core-hashtable-clear! 1 "../stdlib/core/optimize.scm" . 236551)
   (push.gloc.of core.optimize\x27;ht-variable-stackables)
   (subr.gloc.of \x2E;core-hashtable-clear! 1 "../stdlib/core/optimize.scm" . 237575)
   (push.gloc.of core.optimize\x27;ht-lambda-node)
   (subr.gloc.of \x2E;core-hashtable-clear! 1 "../stdlib/core/optimize.scm" . 238599)
   (push.gloc.of core.optimize\x27;ht-binding-body-common)
   (subr.gloc.of \x2E;core-hashtable-clear! 1 "../stdlib/core/optimize.scm" . 239623)
   (push.gloc.of core.optimize\x27;ht-binding-body-mutual)
   (ret.subr.gloc.of \x2E;core-hashtable-clear! "../stdlib/core/optimize.scm" . 240647))
 (set.gloc.of core.optimize\x27;clear-context)
 (push.const . \x2E;call-with-current-continuation)
 (subr.gloc.of \x2E;top-level-value 1 "../stdlib/core/optimize.scm" . 242714)
 (set.gloc.of core.optimize\x27;denote-call/cc)
 (close
   (0 0 . core.optimize\x27;dump-lambda-node)
   (push.const . #t)
   (push.const . ">>> dump ht-lambda-node~%")
   (subr.gloc.of \x2E;format 2 "../stdlib/core/optimize.scm" . 246791)
   (push.gloc.of \x2E;L1015)
   (push.gloc.of core.optimize\x27;ht-lambda-node)
   (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/optimize.scm" . 250897)
   (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 247815))
 (set.gloc.of core.optimize\x27;dump-lambda-node)
 (close
   (0 0 . core.optimize\x27;dump-variable-binding)
   (push.const . #t)
   (push.const . ">>> dump ht-variable-binding~%")
   (subr.gloc.of \x2E;format 2 "../stdlib/core/optimize.scm" . 254983)
   (push.gloc.of \x2E;L995)
   (push.gloc.of core.optimize\x27;ht-variable-binding)
   (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/optimize.scm" . 260113)
   (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 256007))
 (set.gloc.of core.optimize\x27;dump-variable-binding)
 (close
   (1 0 . core.optimize\x27;get-free-variables)
   (push.gloc.of core.optimize\x27;ht-variable-binding)
   (push.iloc.0 . 0)
   (push.const . #f)
   (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 264206)
   (extend . 1)
   (iloc.0 . 0)
   (if.false.ret)
   (push.gloc.of core.optimize\x27;ht-lambda-node)
   (push.iloc.0 . 0)
   (push.const . #f)
   (ret.subr.gloc.of \x2E;core-hashtable-ref "../stdlib/core/optimize.scm" . 265245))
 (set.gloc.of core.optimize\x27;get-free-variables)
 (close
   (1 0 . core.optimize\x27;primitive-function?)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;top-level-bound? 1 "../stdlib/core/optimize.scm" . 270348)
   (if.false.ret)
   (push.gloc.of core.optimize\x27;ht-primitive-functions)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;top-level-value 1 "../stdlib/core/optimize.scm" . 271421)
   (ret.subr.gloc.of \x2E;core-hashtable-contains? "../stdlib/core/optimize.scm" . 271372))
 (set.gloc.of core.optimize\x27;primitive-function?)
 (close
   (1 0 . core.optimize\x27;special-list-function?)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;top-level-bound? 1 "../stdlib/core/optimize.scm" . 275468)
   (if.false.ret)
   (push.gloc.of core.optimize\x27;ht-special-list-functions)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;top-level-value 1 "../stdlib/core/optimize.scm" . 276544)
   (ret.subr.gloc.of \x2E;core-hashtable-contains? "../stdlib/core/optimize.scm" . 276492))
 (set.gloc.of core.optimize\x27;special-list-function?)
 (close
   (1 0 . core.optimize\x27;inlinable-primitive-function?)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;top-level-bound? 1 "../stdlib/core/optimize.scm" . 281612)
   (if.false.ret)
   (push.gloc.of core.optimize\x27;ht-inlinable-primitive-functions)
   (push.iloc.0 . 0)
   (push.subr.gloc.of \x2E;top-level-value 1 "../stdlib/core/optimize.scm" . 282695)
   (ret.subr.gloc.of \x2E;core-hashtable-contains? "../stdlib/core/optimize.scm" . 282636))
 (set.gloc.of core.optimize\x27;inlinable-primitive-function?)
 (close
   (1 0 . core.optimize\x27;variable-top-level?)
   (push.gloc.of core.optimize\x27;ht-variable-defined)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 286731)
   (if.true.ret)
   (call
     (push.gloc.of core.optimize\x27;ht-variable-binding)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 287765)
     (if.true.ret.const . #f)
     (push.gloc.of core.optimize\x27;ht-variable-formals)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 288789)
     (ret.subr.gloc.of \x2E;not "../stdlib/core/optimize.scm" . 288784))
   (if.true.ret)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.optimize\x27;get-free-variables "../stdlib/core/optimize.scm" . 289812))
   (push)
   (ret.subr.gloc.of \x2E;symbol? "../stdlib/core/optimize.scm" . 289803))
 (set.gloc.of core.optimize\x27;variable-top-level?)
 (close
   (1 0 . core.optimize\x27;variable-private?)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;uninterned-symbol? 1 "../stdlib/core/optimize.scm" . 293899)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;current-library-suffix 0)
   (push)
   (subr.gloc.of \x2E;symbol-contains 2 "../stdlib/core/optimize.scm" . 294928)
   (if.false.ret)
   (ret.const . #t))
 (set.gloc.of core.optimize\x27;variable-private?)
 (close
   (1 0 . core.optimize\x27;variable-functional?)
   (call
     (push.gloc.of core.optimize\x27;ht-variable-privates)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 305168)
     (if.true.ret)
     (push.gloc.of core.optimize\x27;ht-variable-defined)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 306197)
     (ret.subr.gloc.of \x2E;not "../stdlib/core/optimize.scm" . 306192))
   (if.false.ret)
   (push.gloc.of core.optimize\x27;ht-variable-binding)
   (push.iloc.0 . 0)
   (push.const . #f)
   (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 307219)
   (extend . 1)
   (iloc.0 . 0)
   (if.false.ret)
   (push.gloc.of core.optimize\x27;ht-lambda-node)
   (push.iloc.0 . 0)
   (push.const . #f)
   (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 308263)
   (const . functable)
   (ret.eq? "../stdlib/core/optimize.scm" . 308258))
 (set.gloc.of core.optimize\x27;variable-functional?)
 (close
   (1 0 . core.optimize\x27;variable-iloc?)
   (push.gloc.of core.optimize\x27;ht-variable-formals)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 313358)
   (if.true.ret)
   (push.gloc.of core.optimize\x27;ht-variable-binding)
   (push.iloc.0 . 0)
   (push.const . #f)
   (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 314382)
   (extend . 1)
   (iloc.0 . 0)
   (if.false.ret)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;symbol? "../stdlib/core/optimize.scm" . 314382))
 (set.gloc.of core.optimize\x27;variable-iloc?)
 (close
   (1 0 . core.optimize\x27;function?)
   (iloc.0 . 0)
   (if.not.pair?.ret.const . #t)
   (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 320535)
   (extend . 1)
   (push.iloc.0 . 0)
   (push.const quote lambda)
   (subr.gloc.of \x2E;memq 2 "../stdlib/core/optimize.scm" . 321553)
   (if.true.ret)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (call
     (push.gloc.of core.optimize\x27;ht-variable-privates)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 323610)
     (if.true.ret)
     (push.gloc.of core.optimize\x27;ht-variable-defined)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 324639)
     (ret.subr.gloc.of \x2E;not "../stdlib/core/optimize.scm" . 324634))
   (if.false.ret)
   (call
     (call
       (push.iloc.0 . 0)
       (apply.gloc.of core.optimize\x27;primitive-function? "../stdlib/core/optimize.scm" . 325658))
     (if.true.ret)
     (call
       (push.iloc.0 . 0)
       (apply.gloc.of
         core.optimize\x27;variable-functional?
         "../stdlib/core/optimize.scm"
         .
         326682))
     (if.true.ret)
     (push.iloc.0 . 0)
     (push.const begin if and or)
     (ret.subr.gloc.of \x2E;memq "../stdlib/core/optimize.scm" . 327706))
   (if.false.ret)
   (push.gloc.of core.optimize\x27;function?)
   (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 328745)
   (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 328726))
 (set.gloc.of core.optimize\x27;function?)
 (close
   (1 0 . core.optimize\x27;constant?)
   (iloc.0 . 0)
   (if.pair?
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) (cdr form\x60;2519*))
       (if.not.pair?.ret.const . #f)
       (cddr.iloc (0 . 0) (cddr form\x60;2519*))
       (ret.null? (null? (cddr form\x60;2519*))))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.car.iloc (1 . 0) (car form\x60;2519*))
       (const . begin)
       (ret.eq? (eq? (car form\x60;2519*) 'begin)))
     (if.true
       (push.cadr.iloc (1 . 0) (cadr form\x60;2519*))
       (apply.gloc.of
         core.optimize\x27;constant?
         (core.optimize\x27;constant? (cadr form\x60;2519*))))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.car.iloc (1 . 0) (car form\x60;2519*))
       (const . quote)
       (ret.eq? (eq? (car form\x60;2519*) 'quote)))
     (if.true.ret.const . #t)
     (push.gloc.of core.optimize\x27;constant?)
     (push.iloc.1 . 0)
     (apply.gloc.of
       core.lists\x27;for-all
       (core.lists\x27;for-all core.optimize\x27;constant? form\x60;2519*)))
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;number? 1 "../stdlib/core/optimize.scm" . 339986)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;boolean? 1 "../stdlib/core/optimize.scm" . 341010)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;char? 1 "../stdlib/core/optimize.scm" . 342034)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;string? 1 "../stdlib/core/optimize.scm" . 343058)
   (if.true.ret)
   (iloc.0 . 0)
   (if.not.symbol?.ret.const . #f)
   (call
     (call
       (push.iloc.0 . 0)
       (apply.gloc.of core.optimize\x27;primitive-function? "../stdlib/core/optimize.scm" . 345115))
     (if.true.ret)
     (push.gloc.of core.optimize\x27;ht-variable-binding)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 346144)
     (if.false.ret)
     (push.gloc.of core.optimize\x27;ht-variable-assigned)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 347173)
     (if.true.ret.const . #f)
     (push.gloc.of core.optimize\x27;ht-variable-privates)
     (push.iloc.0 . 0)
     (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 348196)
     (if.true.ret)
     (push.gloc.of core.optimize\x27;ht-variable-defined)
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 349225)
     (ret.subr.gloc.of \x2E;not "../stdlib/core/optimize.scm" . 349220))
   (if.false.ret)
   (push.gloc.of core.optimize\x27;ht-variable-operands-refc)
   (push.iloc.0 . 0)
   (push.const . 0)
   (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 350234)
   (push.const . 1)
   (ret.subr.gloc.of \x2E;= "../stdlib/core/optimize.scm" . 350231))
 (set.gloc.of core.optimize\x27;constant?)
 (close
   (1 0 . core.optimize\x27;inlinable-expression?)
   (iloc.0 . 0)
   (if.pair?
     (call
       (iloc.0 . 0)
       (if.not.pair?.ret.const . #f)
       (cdr.iloc (0 . 0) (cdr form\x60;2531*))
       (if.not.pair?.ret.const . #f)
       (cddr.iloc (0 . 0) (cddr form\x60;2531*))
       (ret.null? (null? (cddr form\x60;2531*))))
     (push)
     (extend . 1)
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.car.iloc (1 . 0) (car form\x60;2531*))
       (const . begin)
       (ret.eq? (eq? (car form\x60;2531*) 'begin)))
     (if.true
       (push.cadr.iloc (1 . 0) (cadr form\x60;2531*))
       (apply.gloc.of
         core.optimize\x27;inlinable-expression?
         (core.optimize\x27;inlinable-expression? (cadr form\x60;2531*))))
     (call
       (iloc.0 . 0)
       (if.false.ret)
       (push.car.iloc (1 . 0) (car form\x60;2531*))
       (const . quote)
       (ret.eq? (eq? (car form\x60;2531*) 'quote)))
     (if.true
       (cadr.iloc (1 . 0) (cadr form\x60;2531*))
       (if.pair?.ret.const . #f)
       (cadr.iloc (1 . 0) (cadr form\x60;2531*))
       (if.symbol?.ret.const . #t)
       (push.cadr.iloc (1 . 0) (cadr form\x60;2531*))
       (subr.gloc.of \x2E;fixnum? 1 (\x2E;fixnum? (cadr form\x60;2531*)))
       (if.true.ret)
       (push.cadr.iloc (1 . 0) (cadr form\x60;2531*))
       (subr.gloc.of \x2E;boolean? 1 (\x2E;boolean? (cadr form\x60;2531*)))
       (if.true.ret)
       (push.cadr.iloc (1 . 0) (cadr form\x60;2531*))
       (subr.gloc.of \x2E;char? 1 (\x2E;char? (cadr form\x60;2531*)))
       (if.true.ret)
       (push.cadr.iloc (1 . 0) (cadr form\x60;2531*))
       (ret.subr.gloc.of \x2E;string? (\x2E;string? (cadr form\x60;2531*))))
     (iloc.0 . 0)
     (if.false.ret)
     (push.cadr.iloc (1 . 0) (cadr form\x60;2531*))
     (extend . 1)
     (call
       (push.car.iloc (2 . 0) (car form\x60;2531*))
       (apply.gloc.of
         core.optimize\x27;inlinable-primitive-function?
         (core.optimize\x27;inlinable-primitive-function? (car form\x60;2531*))))
     (if.false.ret)
     (push.iloc.0 . 0)
     (apply.gloc.of
       core.optimize\x27;variable-iloc?
       (core.optimize\x27;variable-iloc? arg\x60;2543*)))
   (iloc.0 . 0)
   (if.symbol?.ret.const . #t)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;fixnum? 1 "../stdlib/core/optimize.scm" . 366625)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;boolean? 1 "../stdlib/core/optimize.scm" . 366640)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;char? 1 "../stdlib/core/optimize.scm" . 366656)
   (if.true.ret)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;string? "../stdlib/core/optimize.scm" . 366669))
 (set.gloc.of core.optimize\x27;inlinable-expression?)
 (close
   (1 0 . core.optimize\x27;formals->list)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 371729)
     (call
       (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 371754)
       (apply.gloc.of core.optimize\x27;formals->list "../stdlib/core/optimize.scm" . 371739))
     (ret.cons "../stdlib/core/optimize.scm" . 371723))
   (iloc.0 . 0)
   (if.null?.ret.const)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;list "../stdlib/core/optimize.scm" . 373783))
 (set.gloc.of core.optimize\x27;formals->list)
 (close
   (1 0 . core.optimize\x27;flatten-begin)
   (call
     (touch.gloc.of loop\x60;2554*)
     (push.iloc.0 . 0)
     (push.const)
     (apply.gloc.of loop\x60;2554* "../stdlib/core/optimize.scm" . 388106))
   (push)
   (push.iloc.0 . 0)
   (call (apply.gloc.of core.optimize\x27;annotate-hook "../stdlib/core/optimize.scm" . 386056))
   (apply))
 (set.gloc.of core.optimize\x27;flatten-begin)
 (close
   (3 0 . core.optimize\x27;collect-context-each)
   (extend.enclose+
     (3 0 . loop)
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 403489)
     (push.iloc 2 . 1)
     (call
       (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 403511)
       (push.iloc.0 . 1)
       (push.const . #t)
       (apply.iloc+ (1 . 0) "../stdlib/core/optimize.scm" . 403505))
     (push)
     (push.iloc.0 . 2)
     (apply.gloc.of core.optimize\x27;collect-context "../stdlib/core/optimize.scm" . 403472))
   (push.iloc.1 . 0)
   (push.iloc.1 . 2)
   (push.const . #f)
   (apply.iloc+ (0 . 0) (loop\x60;2562* form\x60;2558* free\x60;2558* #f)))
 (set.gloc.of core.optimize\x27;collect-context-each)
 (close
   (3 0 . core.optimize\x27;collect-context-seq)
   (extend.enclose+
     (2 0 . loop)
     (iloc.0 . 0)
     (if.null? (ret.iloc 0 . 1))
     (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 410657)
     (push.iloc 2 . 1)
     (call
       (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 410679)
       (push.iloc.0 . 1)
       (apply.iloc+ (1 . 0) "../stdlib/core/optimize.scm" . 410673))
     (push)
     (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 410702)
     (push.subr.gloc.of \x2E;null? 1 "../stdlib/core/optimize.scm" . 410695)
     (apply.gloc.of core.optimize\x27;collect-context "../stdlib/core/optimize.scm" . 410640))
   (push.iloc.1 . 0)
   (push.iloc.1 . 2)
   (apply.iloc+ (0 . 0) "../stdlib/core/optimize.scm" . 408585))
 (set.gloc.of core.optimize\x27;collect-context-seq)
 (close
   (4 0 . core.optimize\x27;collect-context)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 416788)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const quote define lambda let letrec*)
     (subr.gloc.of \x2E;memq 2 "../stdlib/core/optimize.scm" . 417809)
     (if.true
       (call
         (iloc.1 . 0)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 577549)
         (ret.pair? "../stdlib/core/optimize.scm" . 577549))
       (push)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (cddr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 577549)
         (if.not.null?.ret.const . #f)
         (push.car.iloc (2 . 0) "../stdlib/core/optimize.scm" . 577549)
         (const . quote)
         (ret.eq? "../stdlib/core/optimize.scm" . 577549))
       (if.true (ret.iloc 2 . 2))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (cddr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 577549)
         (if.not.pair?.ret.const . #f)
         (push.iloc 2 . 0)
         (subr.gloc.of cdddr 1 "../stdlib/core/optimize.scm" . 577549)
         (if.not.null?.ret.const . #f)
         (push.car.iloc (2 . 0) "../stdlib/core/optimize.scm" . 577549)
         (const . define)
         (ret.eq? "../stdlib/core/optimize.scm" . 577549))
       (if.true
         (push.iloc 2 . 0)
         (push.subr.gloc.of caddr 1 "../stdlib/core/optimize.scm" . 577549)
         (push.cadr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 577549)
         (extend . 2)
         (push.gloc.of core.optimize\x27;ht-variable-defined)
         (push.iloc.0 . 1)
         (push.const . #t)
         (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/optimize.scm" . 577549)
         (call
           (call
             (push.iloc.0 . 1)
             (apply.gloc.of
               core.optimize\x27;variable-private?
               "../stdlib/core/optimize.scm"
               .
               577549))
           (if.false.ret)
           (push.gloc.of core.optimize\x27;ht-variable-privates)
           (push.iloc.0 . 1)
           (push.const . #t)
           (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 577549))
         (push.gloc.of core.optimize\x27;ht-variable-binding)
         (push.iloc.0 . 1)
         (call (iloc.0 . 0) (if.true.ret) (ret.const begin #f))
         (push)
         (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/optimize.scm" . 577549)
         (push.iloc.0 . 0)
         (push.iloc 3 . 1)
         (push.iloc 3 . 2)
         (push.iloc 3 . 3)
         (apply.gloc.of core.optimize\x27;collect-context "../stdlib/core/optimize.scm" . 577549))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (2 . 0) "../stdlib/core/optimize.scm" . 577549)
         (const . lambda)
         (ret.eq? "../stdlib/core/optimize.scm" . 577549))
       (if.true
         (push.cddr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 577549)
         (extend . 1)
         (call
           (push.cadr.iloc (3 . 0) "../stdlib/core/optimize.scm" . 577549)
           (apply.gloc.of core.optimize\x27;formals->list "../stdlib/core/optimize.scm" . 577549))
         (push)
         (extend . 1)
         (call
           (push.gloc.of \x2E;L953)
           (push.iloc.0 . 0)
           (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 577549))
         (call
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (push.const)
           (apply.gloc.of
             core.optimize\x27;collect-context-seq
             "../stdlib/core/optimize.scm"
             .
             577549))
         (push)
         (extend . 1)
         (push.gloc.of core.optimize\x27;ht-lambda-node)
         (push.iloc 5 . 0)
         (call
           (push.iloc.0 . 0)
           (apply.gloc.of
             core.lists\x27;remove-duplicate-symbols
             "../stdlib/core/optimize.scm"
             .
             577549))
         (push)
         (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/optimize.scm" . 577549)
         (call
           (push.close
             (1 0)
             (push.iloc.0 . 0)
             (push.iloc 6 . 1)
             (push.subr.gloc.of \x2E;memq 2 "../stdlib/core/optimize.scm" . 577549)
             (ret.subr.gloc.of \x2E;not "../stdlib/core/optimize.scm" . 577549))
           (push.iloc.0 . 0)
           (apply.gloc.of core.lists\x27;filter "../stdlib/core/optimize.scm" . 577549))
         (push)
         (push.iloc 5 . 2)
         (ret.subr.gloc.of \x2E;append "../stdlib/core/optimize.scm" . 577549))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (2 . 0) "../stdlib/core/optimize.scm" . 577549)
         (const . let)
         (ret.eq? "../stdlib/core/optimize.scm" . 577549))
       (if.true
         (push.cddr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 577549)
         (push.cadr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 577549)
         (extend . 2)
         (call
           (push.close
             (1 0)
             (push.gloc.of core.optimize\x27;ht-variable-binding)
             (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 577549)
             (call
               (cadr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 577549)
               (if.true.ret)
               (ret.const begin #f))
             (push)
             (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/optimize.scm" . 577549)
             (push.gloc.of core.optimize\x27;ht-binding-body-common)
             (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 577549)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 577549))
           (push.iloc.0 . 1)
           (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 577549))
         (call
           (call
             (push.gloc.of \x2E;cadr)
             (push.iloc.0 . 1)
             (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 577549))
           (push)
           (push.iloc 3 . 1)
           (push.iloc 3 . 2)
           (apply.gloc.of
             core.optimize\x27;collect-context-each
             "../stdlib/core/optimize.scm"
             .
             577549))
         (push)
         (extend . 1)
         (call
           (call
             (push.gloc.of \x2E;L998)
             (push.iloc.0 . 0)
             (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 577549))
           (if.true.ret)
           (push.gloc.of \x2E;L1012)
           (call
             (push.gloc.of \x2E;car)
             (push.iloc.1 . 1)
             (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 577549))
           (push)
           (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 577549))
         (push.iloc.1 . 0)
         (call
           (push.gloc.of \x2E;car)
           (push.iloc.1 . 1)
           (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 577549))
         (push)
         (push.iloc 4 . 1)
         (push.subr.gloc.of \x2E;append 2 "../stdlib/core/optimize.scm" . 577549)
         (push.iloc.0 . 0)
         (apply.gloc.of
           core.optimize\x27;collect-context-seq
           "../stdlib/core/optimize.scm"
           .
           577549))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (2 . 0) "../stdlib/core/optimize.scm" . 577549)
         (const . letrec*)
         (ret.eq? "../stdlib/core/optimize.scm" . 577549))
       (if.true
         (push.cddr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 577549)
         (push.cadr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 577549)
         (extend . 2)
         (call
           (push.close
             (1 0)
             (push.gloc.of core.optimize\x27;ht-variable-letrec)
             (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 577549)
             (push.const . #t)
             (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/optimize.scm" . 577549)
             (push.gloc.of core.optimize\x27;ht-variable-binding)
             (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 577549)
             (call
               (cadr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 577549)
               (if.true.ret)
               (ret.const begin #f))
             (push)
             (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/optimize.scm" . 577549)
             (push.gloc.of core.optimize\x27;ht-binding-body-common)
             (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 577549)
             (push.iloc.1 . 0)
             (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/optimize.scm" . 577549)
             (call
               (cadr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 577549)
               (if.not.pair?.ret.const . #f)
               (push.const . lambda)
               (push.iloc.0 . 0)
               (subr.gloc.of \x2E;caadr 1 "../stdlib/core/optimize.scm" . 577549)
               (ret.eq? "../stdlib/core/optimize.scm" . 577549))
             (if.true.ret)
             (push.gloc.of core.optimize\x27;ht-variable-pinned)
             (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 577549)
             (push.const . #t)
             (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 577549))
           (push.iloc.0 . 1)
           (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 577549))
         (call
           (call
             (push.gloc.of \x2E;L1014)
             (push.iloc.0 . 1)
             (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 577549))
           (push)
           (extend . 1)
           (push.close
             (1 0)
             (push.gloc.of core.optimize\x27;ht-binding-body-mutual)
             (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 577549)
             (push.iloc.1 . 0)
             (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 577549))
           (push.iloc.1 . 1)
           (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 577549))
         (call
           (push.gloc.of \x2E;car)
           (push.iloc.0 . 1)
           (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 577549))
         (push)
         (push.iloc 3 . 1)
         (push.subr.gloc.of \x2E;append 2 "../stdlib/core/optimize.scm" . 577549)
         (extend . 1)
         (call
           (call
             (push.gloc.of \x2E;cadr)
             (push.iloc.1 . 1)
             (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 577549))
           (push)
           (push.iloc.0 . 0)
           (push.iloc 4 . 2)
           (apply.gloc.of
             core.optimize\x27;collect-context-each
             "../stdlib/core/optimize.scm"
             .
             577549))
         (push)
         (extend . 1)
         (call
           (call
             (push.gloc.of \x2E;L1016)
             (push.iloc.0 . 0)
             (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 577549))
           (if.true.ret)
           (push.gloc.of \x2E;L991)
           (call
             (push.gloc.of \x2E;car)
             (push.iloc 2 . 1)
             (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 577549))
           (push)
           (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 577549))
         (push.iloc 2 . 0)
         (push.iloc.1 . 0)
         (push.iloc.0 . 0)
         (apply.gloc.of
           core.optimize\x27;collect-context-seq
           "../stdlib/core/optimize.scm"
           .
           577549))
       (push.const . "coreform-optimize")
       (push.const . "internal inconsistency in ~s")
       (push.gloc.of core.optimize\x27;collect-context)
       (push.subr.gloc.of \x2E;format 2 "../stdlib/core/optimize.scm" . 577549)
       (push.iloc 2 . 0)
       (apply.gloc.of \x2E;assertion-violation "../stdlib/core/optimize.scm" . 577549))
     (push.iloc.0 . 0)
     (const . if)
     (if.eq?
       (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 473127)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (apply.gloc.of
         core.optimize\x27;collect-context-each
         "../stdlib/core/optimize.scm"
         .
         473105))
     (push.iloc.0 . 0)
     (const . set!)
     (if.eq?
       (push.gloc.of core.optimize\x27;ht-variable-assigned)
       (push.cadr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 475195)
       (push.const . #t)
       (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/optimize.scm" . 475153)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (apply.gloc.of
         core.optimize\x27;collect-context-each
         "../stdlib/core/optimize.scm"
         .
         476177))
     (push.iloc.0 . 0)
     (push.const begin and or)
     (subr.gloc.of \x2E;memq 2 "../stdlib/core/optimize.scm" . 417809)
     (if.true
       (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 478246)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (apply.gloc.of core.optimize\x27;collect-context-seq "../stdlib/core/optimize.scm" . 478225))
     (call
       (car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 480287)
       (if.not.symbol?.ret.const . #f)
       (push.gloc.of core.optimize\x27;ht-variable-callsites)
       (push.car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 482347)
       (push.iloc.1 . 0)
       (push.gloc.of core.optimize\x27;ht-variable-callsites)
       (push.car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 483424)
       (push.const)
       (subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 483382)
       (push.cons)
       (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 481302))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (push.iloc.1 . 2)
     (apply.gloc.of core.optimize\x27;collect-context-each "../stdlib/core/optimize.scm" . 484369))
   (iloc.0 . 0)
   (if.symbol?
     (call
       (iloc.0 . 3)
       (if.false.ret)
       (push.gloc.of core.optimize\x27;ht-variable-operands-refc)
       (push.iloc.0 . 0)
       (push.gloc.of core.optimize\x27;ht-variable-operands-refc)
       (push.iloc.0 . 0)
       (push.const . 0)
       (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 487503)
       (push.const . 1)
       (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/optimize.scm" . 487500)
       (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 487448))
     (push.gloc.of core.optimize\x27;ht-variable-refc)
     (push.iloc.0 . 0)
     (push.gloc.of core.optimize\x27;ht-variable-refc)
     (push.iloc.0 . 0)
     (push.const . 0)
     (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 488508)
     (push.const . 1)
     (push.subr.gloc.of \x2E;+ 2 "../stdlib/core/optimize.scm" . 488505)
     (subr.gloc.of \x2E;core-hashtable-set! 3 "../stdlib/core/optimize.scm" . 488462)
     (call
       (push.iloc.0 . 0)
       (apply.gloc.of core.optimize\x27;primitive-function? "../stdlib/core/optimize.scm" . 489493))
     (if.true (ret.iloc 0 . 2))
     (push.iloc.0 . 0)
     (push.iloc.0 . 1)
     (subr.gloc.of \x2E;memq 2 "../stdlib/core/optimize.scm" . 490517)
     (if.true (ret.iloc 0 . 2))
     (push.iloc.0 . 0)
     (iloc.0 . 2)
     (ret.cons "../stdlib/core/optimize.scm" . 491546))
   (ret.iloc 0 . 2))
 (set.gloc.of core.optimize\x27;collect-context)
 (close
   (2 0 . core.optimize\x27;crawl-lambda-lifting)
   (call
     (touch.gloc.of loop\x60;2719*)
     (apply.gloc.of loop\x60;2719* "../stdlib/core/optimize.scm" . 626697))
   (call
     (touch.gloc.of traverse-lambda-node\x60;2629*)
     (apply.gloc.of traverse-lambda-node\x60;2629* "../stdlib/core/optimize.scm" . 628743))
   (touch.gloc.of make-table\x60;2629*)
   (apply.gloc.of make-table\x60;2629* "../stdlib/core/optimize.scm" . 629767))
 (set.gloc.of core.optimize\x27;crawl-lambda-lifting)
 (close
   (1 0 . core.optimize\x27;crawl-beta-subst)
   (subr.gloc.of \x2E;make-core-hashtable 0)
   (push)
   (extend . 1)
   (call
     (push.close
       (1 0)
       (push.gloc.of core.optimize\x27;ht-lambda-node)
       (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 638009)
       (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 637968)
       (if.true.ret)
       (push.gloc.of core.optimize\x27;ht-variable-refc)
       (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 639041)
       (push.const . #f)
       (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 639004)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (call
           (=n.iloc (0 . 0) 1 "../stdlib/core/optimize.scm" . 641058)
           (if.true.ret)
           (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 641092)
           (apply.gloc.of
             core.optimize\x27;inlinable-expression?
             "../stdlib/core/optimize.scm"
             .
             641069))
         (if.false.ret)
         (push.gloc.of core.optimize\x27;ht-variable-pinned)
         (push.car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 642128)
         (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 642083)
         (if.true.ret.const . #f)
         (push.gloc.of core.optimize\x27;ht-binding-body-common)
         (push.car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 643145)
         (push.const . #f)
         (ret.subr.gloc.of \x2E;core-hashtable-ref "../stdlib/core/optimize.scm" . 643102))
       (push)
       (extend . 1)
       (iloc.0 . 0)
       (if.true
         (call
           (call
             (push.cdr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 645179)
             (apply.gloc.of core.optimize\x27;constant? "../stdlib/core/optimize.scm" . 645168))
           (if.true.ret)
           (cdr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 646206)
           (if.not.symbol?.ret.const . #f)
           (push.gloc.of core.optimize\x27;ht-variable-assigned)
           (push.cdr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 647273)
           (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 647226)
           (if.true.ret.const . #f)
           (push.gloc.of core.optimize\x27;ht-variable-formals)
           (push.cdr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 648295)
           (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 648249)
           (if.true.ret)
           (push.gloc.of core.optimize\x27;ht-variable-binding)
           (push.cdr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 649324)
           (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 649278)
           (if.false.ret)
           (push.gloc.of core.optimize\x27;ht-variable-privates)
           (push.cdr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 650353)
           (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 650306)
           (if.true.ret)
           (push.gloc.of core.optimize\x27;ht-variable-defined)
           (push.cdr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 651381)
           (push.subr.gloc.of
             \x2E;core-hashtable-contains?
             2
             "../stdlib/core/optimize.scm"
             .
             651335)
           (ret.subr.gloc.of \x2E;not "../stdlib/core/optimize.scm" . 651330))
         (push)
         (extend . 1)
         (call
           (iloc.0 . 0)
           (if.true.ret)
           (call
             (push.cdr.iloc (3 . 0) "../stdlib/core/optimize.scm" . 653375)
             (apply.gloc.of core.optimize\x27;function? "../stdlib/core/optimize.scm" . 653364))
           (if.false.ret)
           (cdr.iloc (3 . 0) "../stdlib/core/optimize.scm" . 654406)
           (if.not.symbol?.ret.const . #t)
           (push.gloc.of core.optimize\x27;ht-variable-operands-refc)
           (push.cdr.iloc (3 . 0) "../stdlib/core/optimize.scm" . 655466)
           (push.const . 0)
           (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 655420)
           (push.const . 1)
           (ret.subr.gloc.of \x2E;<= "../stdlib/core/optimize.scm" . 655416))
         (push)
         (extend . 1)
         (call
           (iloc.1 . 0)
           (if.false.ret)
           (push.cdr.iloc (4 . 0) "../stdlib/core/optimize.scm" . 657481)
           (apply.gloc.of
             core.optimize\x27;inlinable-expression?
             "../stdlib/core/optimize.scm"
             .
             657458))
         (push)
         (extend . 1)
         (call
           (push.close
             (1 0)
             (extend.enclose
               (1 0 . loop)
               (call
                 (<n.iloc (7 . 0) 1 "../stdlib/core/optimize.scm" . 662577)
                 (if.false.ret)
                 (push.const . #t)
                 (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 662588))
               (iloc.0 . 0)
               (if.null?.ret.const)
               (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 664632)
               (car.iloc (8 . 0) "../stdlib/core/optimize.scm" . 664642)
               (if.eq?
                 (n+.iloc (7 . 0) -1 "../stdlib/core/optimize.scm" . 665662)
                 (set.iloc (7 . 0) "../stdlib/core/optimize.scm" . 665651)
                 (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 666681)
                 (apply.iloc (1 . 0) "../stdlib/core/optimize.scm" . 666675))
               (car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 667706)
               (if.pair?
                 (push.iloc.0 . 0)
                 (push.subr.gloc.of \x2E;caar 1 "../stdlib/core/optimize.scm" . 668735)
                 (push.iloc.0 . 0)
                 (push.subr.gloc.of \x2E;cdar 1 "../stdlib/core/optimize.scm" . 668753)
                 (extend . 2)
                 (iloc.0 . 0)
                 (if.pair?
                   (call
                     (push.car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 670786)
                     (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 670780))
                   (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 671810)
                   (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 671804))
                 (push.iloc.0 . 0)
                 (const . quote)
                 (if.eq?
                   (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 673858)
                   (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 673852))
                 (push.iloc.0 . 0)
                 (const . lambda)
                 (if.eq?
                   (call
                     (iloc 4 . 0)
                     (if.false.ret)
                     (push.cdr.iloc (0 . 1) "../stdlib/core/optimize.scm" . 675918)
                     (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 675912))
                   (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 676930)
                   (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 676924))
                 (push.iloc.0 . 0)
                 (push.const let letrec*)
                 (subr.gloc.of \x2E;memq 2 "../stdlib/core/optimize.scm" . 677948)
                 (if.true
                   (call
                     (call
                       (push.gloc.of \x2E;cadr)
                       (push.car.iloc (0 . 1) "../stdlib/core/optimize.scm" . 678988)
                       (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 678978))
                     (push)
                     (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 678972))
                   (call
                     (push.cdr.iloc (0 . 1) "../stdlib/core/optimize.scm" . 680002)
                     (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 679996))
                   (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 681026)
                   (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 681020))
                 (push.iloc.0 . 0)
                 (push.const begin and or)
                 (subr.gloc.of \x2E;memq 2 "../stdlib/core/optimize.scm" . 682044)
                 (if.true
                   (call
                     (push.iloc.0 . 1)
                     (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 683068))
                   (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 684098)
                   (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 684092))
                 (push.iloc.0 . 0)
                 (const . set!)
                 (if.eq?
                   (call
                     (iloc 6 . 0)
                     (if.true.ret)
                     (push.const . #f)
                     (apply.iloc (3 . 0) "../stdlib/core/optimize.scm" . 686150))
                   (call
                     (push.car.iloc (9 . 0) "../stdlib/core/optimize.scm" . 687174)
                     (car.iloc (0 . 1) "../stdlib/core/optimize.scm" . 687182)
                     (if.not.eq?.ret.const . #f)
                     (push.const . #f)
                     (apply.iloc (3 . 0) "../stdlib/core/optimize.scm" . 687194))
                   (call
                     (push.cdr.iloc (9 . 0) "../stdlib/core/optimize.scm" . 688198)
                     (car.iloc (0 . 1) "../stdlib/core/optimize.scm" . 688206)
                     (if.not.eq?.ret.const . #f)
                     (push.const . #f)
                     (apply.iloc (3 . 0) "../stdlib/core/optimize.scm" . 688218))
                   (call
                     (push.cdr.iloc (0 . 1) "../stdlib/core/optimize.scm" . 689218)
                     (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 689212))
                   (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 690242)
                   (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 690236))
                 (push.iloc.0 . 0)
                 (const . if)
                 (if.eq?
                   (call
                     (push.car.iloc (0 . 1) "../stdlib/core/optimize.scm" . 692296)
                     (push.subr.gloc.of \x2E;list 1 "../stdlib/core/optimize.scm" . 692290)
                     (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 692284))
                   (call
                     (iloc 5 . 0)
                     (if.true.ret)
                     (push.const . #f)
                     (apply.iloc (3 . 0) "../stdlib/core/optimize.scm" . 693317))
                   (call
                     (push.cadr.iloc (0 . 1) "../stdlib/core/optimize.scm" . 694344)
                     (push.subr.gloc.of \x2E;list 1 "../stdlib/core/optimize.scm" . 694338)
                     (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 694332))
                   (call
                     (cddr.iloc (0 . 1) "../stdlib/core/optimize.scm" . 695368)
                     (if.not.pair?.ret.const . #f)
                     (push.iloc.0 . 1)
                     (push.subr.gloc.of \x2E;caddr 1 "../stdlib/core/optimize.scm" . 695393)
                     (push.subr.gloc.of \x2E;list 1 "../stdlib/core/optimize.scm" . 695387)
                     (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 695381))
                   (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 696386)
                   (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 696380))
                 (call
                   (push.iloc.0 . 0)
                   (car.iloc (9 . 0) "../stdlib/core/optimize.scm" . 698443)
                   (if.not.eq?.ret.const . #f)
                   (n+.iloc (8 . 0) -1 "../stdlib/core/optimize.scm" . 698463)
                   (set.iloc (8 . 0) "../stdlib/core/optimize.scm" . 698452)
                   (ret.const.unspec))
                 (call
                   (push.iloc.0 . 1)
                   (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 699452))
                 (call
                   (iloc 6 . 0)
                   (if.true.ret)
                   (call
                     (push.iloc.0 . 0)
                     (apply.gloc.of
                       core.optimize\x27;primitive-function?
                       "../stdlib/core/optimize.scm"
                       .
                       701504))
                   (if.true.ret)
                   (call
                     (push.iloc.0 . 0)
                     (apply.gloc.of
                       core.optimize\x27;variable-functional?
                       "../stdlib/core/optimize.scm"
                       .
                       702528))
                   (if.true.ret)
                   (call
                     (call
                       (push.iloc.0 . 0)
                       (apply.gloc.of
                         core.optimize\x27;special-list-function?
                         "../stdlib/core/optimize.scm"
                         .
                         703557))
                     (if.false.ret)
                     (iloc.0 . 1)
                     (if.not.pair?.ret.const . #f)
                     (car.iloc (0 . 1) "../stdlib/core/optimize.scm" . 705614)
                     (if.not.symbol?.ret.const . #f)
                     (call
                       (push.car.iloc (0 . 1) "../stdlib/core/optimize.scm" . 706654)
                       (apply.gloc.of
                         core.optimize\x27;primitive-function?
                         "../stdlib/core/optimize.scm"
                         .
                         706633))
                     (if.true.ret)
                     (push.car.iloc (0 . 1) "../stdlib/core/optimize.scm" . 707679)
                     (apply.gloc.of
                       core.optimize\x27;variable-functional?
                       "../stdlib/core/optimize.scm"
                       .
                       707657))
                   (if.true.ret)
                   (push.const . #f)
                   (apply.iloc (3 . 0) "../stdlib/core/optimize.scm" . 708672))
                 (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 709698)
                 (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 709692))
               (car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 710716)
               (if.symbol?
                 (call
                   (iloc 5 . 0)
                   (if.true.ret)
                   (push.gloc.of core.optimize\x27;ht-variable-assigned)
                   (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 712811)
                   (subr.gloc.of
                     \x2E;core-hashtable-contains?
                     2
                     "../stdlib/core/optimize.scm"
                     .
                     712764)
                   (if.false.ret)
                   (push.const . #f)
                   (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 713788))
                 (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 714809)
                 (apply.iloc (1 . 0) "../stdlib/core/optimize.scm" . 714803))
               (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 716857)
               (apply.iloc (1 . 0) "../stdlib/core/optimize.scm" . 716851))
             (push.iloc 5 . 0)
             (apply.iloc (0 . 0) "../stdlib/core/optimize.scm" . 662572))
           (apply.gloc.of
             \x2E;call/cc
             (\x2E;call/cc
               (lambda (done\x60;2742*)
                 (letrec* ((loop\x60;2746*
                             (lambda (lst\x60;2747*)
                               (and (\x2E;< refc\x60;2729* 1) (done\x60;2742* #t))
                               (if (\x2E;null? lst\x60;2747*)
                                   '()
                                   (if (\x2E;eq? (\x2E;car lst\x60;2747*) (\x2E;car b\x60;2727*))
                                       (begin
                                         (set! refc\x60;2729* (\x2E;- refc\x60;2729* 1))
                                         (loop\x60;2746* (\x2E;cdr lst\x60;2747*)))
                                       (if (\x2E;pair? (\x2E;car lst\x60;2747*))
                                           (let ((proc\x60;2749* (\x2E;caar lst\x60;2747*))
                                                 (args\x60;2749* (\x2E;cdar lst\x60;2747*)))
                                             (if (\x2E;pair? proc\x60;2749*)
                                                 (begin
                                                   (loop\x60;2746* (\x2E;car lst\x60;2747*))
                                                   (loop\x60;2746* (\x2E;cdr lst\x60;2747*)))
                                                 (if (\x2E;eq? proc\x60;2749* 'quote)
                                                     (loop\x60;2746* (\x2E;cdr lst\x60;2747*))
                                                     (if (\x2E;eq? proc\x60;2749* 'lambda)
                                                         (begin
                                                           (and inline\x60;2739*
                                                                (loop\x60;2746*
                                                                  (\x2E;cdr args\x60;2749*)))
                                                           (loop\x60;2746*
                                                             (\x2E;cdr lst\x60;2747*)))
                                                         (if (\x2E;memq
                                                               proc\x60;2749*
                                                               '(let letrec*))
                                                             (begin
                                                               (loop\x60;2746*
                                                                 (\x2E;map
                                                                   \x2E;cadr
                                                                   (\x2E;car args\x60;2749*)))
                                                               (loop\x60;2746*
                                                                 (\x2E;cdr args\x60;2749*))
                                                               (loop\x60;2746*
                                                                 (\x2E;cdr lst\x60;2747*)))
                                                             (if (\x2E;memq
                                                                   proc\x60;2749*
                                                                   '(begin and or))
                                                                 (begin
                                                                   (loop\x60;2746* args\x60;2749*)
                                                                   (loop\x60;2746*
                                                                     (\x2E;cdr lst\x60;2747*)))
                                                                 (if (\x2E;eq? proc\x60;2749* 'set!)
                                                                     (begin
                                                                       (or const\x60;2735*
                                                                           (done\x60;2742* #f))
                                                                       (and (\x2E;eq?
                                                                              (\x2E;car b\x60;2727*)
                                                                              (\x2E;car
                                                                                args\x60;2749*))
                                                                            (done\x60;2742* #f))
                                                                       (and (\x2E;eq?
                                                                              (\x2E;cdr b\x60;2727*)
                                                                              (\x2E;car
                                                                                args\x60;2749*))
                                                                            (done\x60;2742* #f))
                                                                       (loop\x60;2746*
                                                                         (\x2E;cdr args\x60;2749*))
                                                                       (loop\x60;2746*
                                                                         (\x2E;cdr lst\x60;2747*)))
                                                                     (if (\x2E;eq?
                                                                           proc\x60;2749*
                                                                           'if)
                                                                         (begin
                                                                           (loop\x60;2746*
                                                                             (\x2E;list
                                                                               (\x2E;car
                                                                                 args\x60;2749*)))
                                                                           (or pure\x60;2737*
                                                                               (done\x60;2742* #f))
                                                                           (loop\x60;2746*
                                                                             (\x2E;list
                                                                               (\x2E;cadr
                                                                                 args\x60;2749*)))
                                                                           (and (\x2E;pair?
                                                                                  (\x2E;cddr
                                                                                    args\x60;2749*))
                                                                                (loop\x60;2746*
                                                                                  (\x2E;list
                                                                                    (\x2E;caddr
                                                                                      args\x60;2749*))))
                                                                           (loop\x60;2746*
                                                                             (\x2E;cdr
                                                                               lst\x60;2747*)))
                                                                         (begin
                                                                           (and (\x2E;eq?
                                                                                  proc\x60;2749*
                                                                                  (\x2E;car
                                                                                    b\x60;2727*))
                                                                                (set! refc\x60;2729*
                                                                                      (\x2E;-
                                                                                        refc\x60;2729*
                                                                                        1)))
                                                                           (loop\x60;2746*
                                                                             args\x60;2749*)
                                                                           (or const\x60;2735*
                                                                               (core.optimize\x27;primitive-function?
                                                                                 proc\x60;2749*)
                                                                               (core.optimize\x27;variable-functional?
                                                                                 proc\x60;2749*)
                                                                               (and (core.optimize\x27;special-list-function?
                                                                                      proc\x60;2749*)
                                                                                    (\x2E;pair?
                                                                                      args\x60;2749*)
                                                                                    (\x2E;symbol?
                                                                                      (\x2E;car
                                                                                        args\x60;2749*))
                                                                                    (or (core.optimize\x27;primitive-function?
                                                                                          (\x2E;car
                                                                                            args\x60;2749*))
                                                                                        (core.optimize\x27;variable-functional?
                                                                                          (\x2E;car
                                                                                            args\x60;2749*))))
                                                                               (done\x60;2742* #f))
                                                                           (loop\x60;2746*
                                                                             (\x2E;cdr
                                                                               lst\x60;2747*)))))))))))
                                           (if (\x2E;symbol? (\x2E;car lst\x60;2747*))
                                               (begin
                                                 (or const\x60;2735*
                                                     (and (\x2E;core-hashtable-contains?
                                                            core.optimize\x27;ht-variable-assigned
                                                            (\x2E;car lst\x60;2747*))
                                                          (done\x60;2742* #f)))
                                                 (loop\x60;2746* (\x2E;cdr lst\x60;2747*)))
                                               (loop\x60;2746* (\x2E;cdr lst\x60;2747*)))))))))
                   (loop\x60;2746* \x2E;L915\x60;2731*))))))
         (push)
         (extend . 1)
         (push.iloc.0 . 0)
         (const . #t)
         (if.not.eq?.ret.const . #f)
         (push.iloc 7 . 0)
         (push.car.iloc (6 . 0) "../stdlib/core/optimize.scm" . 718911)
         (push.cdr.iloc (6 . 0) "../stdlib/core/optimize.scm" . 718919)
         (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 718887))
       (ret.const.unspec))
     (push.gloc.of core.optimize\x27;ht-variable-binding)
     (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/optimize.scm" . 719882)
     (apply.gloc.of
       \x2E;for-each
       (\x2E;for-each
         (lambda (b\x60;2727*)
           (or (\x2E;core-hashtable-contains?
                 core.optimize\x27;ht-lambda-node
                 (\x2E;cdr b\x60;2727*))
               (let ((refc\x60;2729*
                       (\x2E;core-hashtable-ref
                         core.optimize\x27;ht-variable-refc
                         (\x2E;car b\x60;2727*)
                         #f)))
                 (let ((\x2E;L915\x60;2731*
                         (and refc\x60;2729*
                              (or (\x2E;= refc\x60;2729* 1)
                                  (core.optimize\x27;inlinable-expression? (\x2E;cdr b\x60;2727*)))
                              (\x2E;not
                                (\x2E;core-hashtable-contains?
                                  core.optimize\x27;ht-variable-pinned
                                  (\x2E;car b\x60;2727*)))
                              (\x2E;core-hashtable-ref
                                core.optimize\x27;ht-binding-body-common
                                (\x2E;car b\x60;2727*)
                                #f))))
                   (if \x2E;L915\x60;2731*
                       (let ((const\x60;2735*
                               (or (core.optimize\x27;constant? (\x2E;cdr b\x60;2727*))
                                   (and (\x2E;symbol? (\x2E;cdr b\x60;2727*))
                                        (\x2E;not
                                          (\x2E;core-hashtable-contains?
                                            core.optimize\x27;ht-variable-assigned
                                            (\x2E;cdr b\x60;2727*)))
                                        (or (\x2E;core-hashtable-contains?
                                              core.optimize\x27;ht-variable-formals
                                              (\x2E;cdr b\x60;2727*))
                                            (and (\x2E;core-hashtable-contains?
                                                   core.optimize\x27;ht-variable-binding
                                                   (\x2E;cdr b\x60;2727*))
                                                 (or (\x2E;core-hashtable-contains?
                                                       core.optimize\x27;ht-variable-privates
                                                       (\x2E;cdr b\x60;2727*))
                                                     (\x2E;not
                                                       (\x2E;core-hashtable-contains?
                                                         core.optimize\x27;ht-variable-defined
                                                         (\x2E;cdr b\x60;2727*))))))))))
                         (let ((pure\x60;2737*
                                 (or const\x60;2735*
                                     (and (core.optimize\x27;function? (\x2E;cdr b\x60;2727*))
                                          (or (\x2E;not (\x2E;symbol? (\x2E;cdr b\x60;2727*)))
                                              (\x2E;<=
                                                (\x2E;core-hashtable-ref
                                                  core.optimize\x27;ht-variable-operands-refc
                                                  (\x2E;cdr b\x60;2727*)
                                                  0)
                                                1))))))
                           (let ((inline\x60;2739*
                                   (and const\x60;2735*
                                        (core.optimize\x27;inlinable-expression?
                                          (\x2E;cdr b\x60;2727*)))))
                             (let ((ans\x60;2752*
                                     (\x2E;call/cc
                                       (lambda (done\x60;2742*)
                                         (letrec* ((loop\x60;2746*
                                                     (lambda (lst\x60;2747*)
                                                       (and (\x2E;< refc\x60;2729* 1)
                                                            (done\x60;2742* #t))
                                                       (if (\x2E;null? lst\x60;2747*)
                                                           '()
                                                           (if (\x2E;eq?
                                                                 (\x2E;car lst\x60;2747*)
                                                                 (\x2E;car b\x60;2727*))
                                                               (begin
                                                                 (set! refc\x60;2729*
                                                                       (\x2E;- refc\x60;2729* 1))
                                                                 (loop\x60;2746*
                                                                   (\x2E;cdr lst\x60;2747*)))
                                                               (if (\x2E;pair?
                                                                     (\x2E;car lst\x60;2747*))
                                                                   (let ((proc\x60;2749*
                                                                           (\x2E;caar
                                                                             lst\x60;2747*))
                                                                         (args\x60;2749*
                                                                           (\x2E;cdar
                                                                             lst\x60;2747*)))
                                                                     (if (\x2E;pair? proc\x60;2749*)
                                                                         (begin
                                                                           (loop\x60;2746*
                                                                             (\x2E;car
                                                                               lst\x60;2747*))
                                                                           (loop\x60;2746*
                                                                             (\x2E;cdr
                                                                               lst\x60;2747*)))
                                                                         (if (\x2E;eq?
                                                                               proc\x60;2749*
                                                                               'quote)
                                                                             (loop\x60;2746*
                                                                               (\x2E;cdr
                                                                                 lst\x60;2747*))
                                                                             (if (\x2E;eq?
                                                                                   proc\x60;2749*
                                                                                   'lambda)
                                                                                 (begin
                                                                                   (and inline\x60;2739*
                                                                                        (loop\x60;2746*
                                                                                          (\x2E;cdr
                                                                                            args\x60;2749*)))
                                                                                   (loop\x60;2746*
                                                                                     (\x2E;cdr
                                                                                       lst\x60;2747*)))
                                                                                 (if (\x2E;memq
                                                                                       proc\x60;2749*
                                                                                       '(let
                                                                                          letrec*))
                                                                                     (begin
                                                                                       (loop\x60;2746*
                                                                                         (\x2E;map
                                                                                           \x2E;cadr
                                                                                           (\x2E;car
                                                                                             args\x60;2749*)))
                                                                                       (loop\x60;2746*
                                                                                         (\x2E;cdr
                                                                                           args\x60;2749*))
                                                                                       (loop\x60;2746*
                                                                                         (\x2E;cdr
                                                                                           lst\x60;2747*)))
                                                                                     (if (\x2E;memq
                                                                                           proc\x60;2749*
                                                                                           '(begin
                                                                                              and
                                                                                              or))
                                                                                         (begin
                                                                                           (loop\x60;2746*
                                                                                             args\x60;2749*)
                                                                                           (loop\x60;2746*
                                                                                             (\x2E;cdr
                                                                                               lst\x60;2747*)))
                                                                                         (if (\x2E;eq?
                                                                                               proc\x60;2749*
                                                                                               'set!)
                                                                                             (begin
                                                                                               (or const\x60;2735*
                                                                                                   (done\x60;2742*
                                                                                                     #f))
                                                                                               (and (\x2E;eq?
                                                                                                      (\x2E;car
                                                                                                        b\x60;2727*)
                                                                                                      (\x2E;car
                                                                                                        args\x60;2749*))
                                                                                                    (done\x60;2742*
                                                                                                      #f))
                                                                                               (and (\x2E;eq?
                                                                                                      (\x2E;cdr
                                                                                                        b\x60;2727*)
                                                                                                      (\x2E;car
                                                                                                        args\x60;2749*))
                                                                                                    (done\x60;2742*
                                                                                                      #f))
                                                                                               (loop\x60;2746*
                                                                                                 (\x2E;cdr
                                                                                                   args\x60;2749*))
                                                                                               (loop\x60;2746*
                                                                                                 (\x2E;cdr
                                                                                                   lst\x60;2747*)))
                                                                                             (if (\x2E;eq?
                                                                                                   proc\x60;2749*
                                                                                                   'if)
                                                                                                 (begin
                                                                                                   (loop\x60;2746*
                                                                                                     (\x2E;list
                                                                                                       (\x2E;car
                                                                                                         args\x60;2749*)))
                                                                                                   (or pure\x60;2737*
                                                                                                       (done\x60;2742*
                                                                                                         #f))
                                                                                                   (loop\x60;2746*
                                                                                                     (\x2E;list
                                                                                                       (\x2E;cadr
                                                                                                         args\x60;2749*)))
                                                                                                   (and (\x2E;pair?
                                                                                                          (\x2E;cddr
                                                                                                            args\x60;2749*))
                                                                                                        (loop\x60;2746*
                                                                                                          (\x2E;list
                                                                                                            (\x2E;caddr
                                                                                                              args\x60;2749*))))
                                                                                                   (loop\x60;2746*
                                                                                                     (\x2E;cdr
                                                                                                       lst\x60;2747*)))
                                                                                                 (begin
                                                                                                   (and (\x2E;eq?
                                                                                                          proc\x60;2749*
                                                                                                          (\x2E;car
                                                                                                            b\x60;2727*))
                                                                                                        (set! refc\x60;2729*
                                                                                                              (\x2E;-
                                                                                                                refc\x60;2729*
                                                                                                                1)))
                                                                                                   (loop\x60;2746*
                                                                                                     args\x60;2749*)
                                                                                                   (or const\x60;2735*
                                                                                                       (core.optimize\x27;primitive-function?
                                                                                                         proc\x60;2749*)
                                                                                                       (core.optimize\x27;variable-functional?
                                                                                                         proc\x60;2749*)
                                                                                                       (and (core.optimize\x27;special-list-function?
                                                                                                              proc\x60;2749*)
                                                                                                            (\x2E;pair?
                                                                                                              args\x60;2749*)
                                                                                                            (\x2E;symbol?
                                                                                                              (\x2E;car
                                                                                                                args\x60;2749*))
                                                                                                            (or (core.optimize\x27;primitive-function?
                                                                                                                  (\x2E;car
                                                                                                                    args\x60;2749*))
                                                                                                                (core.optimize\x27;variable-functional?
                                                                                                                  (\x2E;car
                                                                                                                    args\x60;2749*))))
                                                                                                       (done\x60;2742*
                                                                                                         #f))
                                                                                                   (loop\x60;2746*
                                                                                                     (\x2E;cdr
                                                                                                       lst\x60;2747*)))))))))))
                                                                   (if (\x2E;symbol?
                                                                         (\x2E;car lst\x60;2747*))
                                                                       (begin
                                                                         (or const\x60;2735*
                                                                             (and (\x2E;core-hashtable-contains?
                                                                                    core.optimize\x27;ht-variable-assigned
                                                                                    (\x2E;car
                                                                                      lst\x60;2747*))
                                                                                  (done\x60;2742*
                                                                                    #f)))
                                                                         (loop\x60;2746*
                                                                           (\x2E;cdr
                                                                             lst\x60;2747*)))
                                                                       (loop\x60;2746*
                                                                         (\x2E;cdr
                                                                           lst\x60;2747*)))))))))
                                           (loop\x60;2746* \x2E;L915\x60;2731*))))))
                               (and (\x2E;eq? ans\x60;2752* #t)
                                    (\x2E;core-hashtable-set!
                                      ht\x60;2725*
                                      (\x2E;car b\x60;2727*)
                                      (\x2E;cdr b\x60;2727*)))))))
                       (\x2E;unspecified))))))
         (\x2E;core-hashtable->alist core.optimize\x27;ht-variable-binding))))
   (call
     (push.close
       (1 0)
       (cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 721955)
       (if.not.symbol?.ret.const . #f)
       (push.iloc.1 . 0)
       (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 722997)
       (ret.subr.gloc.of \x2E;core-hashtable-delete! "../stdlib/core/optimize.scm" . 722970))
     (push.iloc.0 . 0)
     (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/optimize.scm" . 723987)
     (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 720905))
   (ret.iloc 0 . 0))
 (set.gloc.of core.optimize\x27;crawl-beta-subst)
 (close
   (2 0 . core.optimize\x27;check-stackable-each)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const . #t)
     (call
       (push.iloc 2 . 0)
       (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 731175)
       (push.const . #f)
       (apply.gloc.of core.optimize\x27;check-stackable "../stdlib/core/optimize.scm" . 731154))
     (if.false.ret)
     (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 732184)
     (apply.iloc+ (1 . 0) "../stdlib/core/optimize.scm" . 732178))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "../stdlib/core/optimize.scm" . 730121))
 (set.gloc.of core.optimize\x27;check-stackable-each)
 (close
   (3 0 . core.optimize\x27;check-stackable-seq)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const . #t)
     (call
       (push.iloc 2 . 0)
       (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 738343)
       (call
         (iloc 2 . 2)
         (if.false.ret)
         (cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 738370)
         (ret.null? "../stdlib/core/optimize.scm" . 738363))
       (push)
       (apply.gloc.of core.optimize\x27;check-stackable "../stdlib/core/optimize.scm" . 738322))
     (if.false.ret)
     (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 739352)
     (apply.iloc+ (1 . 0) "../stdlib/core/optimize.scm" . 739346))
   (push.iloc.1 . 1)
   (apply.iloc+ (0 . 0) "../stdlib/core/optimize.scm" . 737289))
 (set.gloc.of core.optimize\x27;check-stackable-seq)
 (close
   (3 0 . core.optimize\x27;check-stackable)
   (iloc.0 . 1)
   (if.pair?
     (push.car.iloc (0 . 1) "../stdlib/core/optimize.scm" . 744468)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . lambda)
     (if.eq?
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 1) "../stdlib/core/optimize.scm" . 746538)
       (push.const . #f)
       (apply.gloc.of core.optimize\x27;check-stackable-seq "../stdlib/core/optimize.scm" . 746513))
     (push.iloc.0 . 0)
     (push.const begin and or)
     (subr.gloc.of \x2E;memq 2 "../stdlib/core/optimize.scm" . 746513)
     (if.true
       (push.iloc.1 . 0)
       (push.cdr.iloc (1 . 1) "../stdlib/core/optimize.scm" . 748586)
       (push.iloc.1 . 2)
       (apply.gloc.of core.optimize\x27;check-stackable-seq "../stdlib/core/optimize.scm" . 748561))
     (push.iloc.0 . 0)
     (const . let)
     (if.eq?
       (call
         (push.close
           (1 0)
           (push.iloc 2 . 0)
           (push.cadr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 750656)
           (push.const . #f)
           (apply.gloc.of core.optimize\x27;check-stackable "../stdlib/core/optimize.scm" . 750635))
         (push.cadr.iloc (1 . 1) "../stdlib/core/optimize.scm" . 750670)
         (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 750614))
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 1) "../stdlib/core/optimize.scm" . 751663)
       (push.iloc.1 . 2)
       (apply.gloc.of core.optimize\x27;check-stackable-seq "../stdlib/core/optimize.scm" . 751638))
     (push.iloc.0 . 0)
     (const . letrec*)
     (if.eq?
       (iloc.1 . 2)
       (if.true
         (call
           (iloc.1 . 1)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (1 . 1) (cdr form\x60;2772*))
           (if.not.pair?.ret.const . #f)
           (cadr.iloc (1 . 1) (cadr form\x60;2772*))
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 1)
           (subr.gloc.of caadr 1 (caadr form\x60;2772*))
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 1)
           (subr.gloc.of cdaadr 1 (cdaadr form\x60;2772*))
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 1)
           (push.subr.gloc.of cdaadr 1 (cdaadr form\x60;2772*))
           (subr.gloc.of car 1 (car (cdaadr form\x60;2772*)))
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 1)
           (push.subr.gloc.of cdaadr 1 (cdaadr form\x60;2772*))
           (subr.gloc.of cdar 1 (cdar (cdaadr form\x60;2772*)))
           (if.not.pair?.ret.const . #f)
           (cddr.iloc (1 . 1) (cddr form\x60;2772*))
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 1)
           (subr.gloc.of caddr 1 (caddr form\x60;2772*))
           (if.not.pair?.ret.const . #f)
           (push.iloc.1 . 1)
           (push.subr.gloc.of cdaadr 1 (cdaadr form\x60;2772*))
           (subr.gloc.of cdr 1 (cdr (cdaadr form\x60;2772*)))
           (if.not.null?.ret.const . #f)
           (push.iloc.1 . 1)
           (subr.gloc.of cdadr 1 (cdadr form\x60;2772*))
           (if.not.null?.ret.const . #f)
           (push.iloc.1 . 1)
           (subr.gloc.of cdddr 1 (cdddr form\x60;2772*))
           (if.not.null?.ret.const . #f)
           (push.iloc.1 . 1)
           (push.subr.gloc.of cdaadr 1 (cdaadr form\x60;2772*))
           (push.subr.gloc.of caar 1 (caar (cdaadr form\x60;2772*)))
           (const . lambda)
           (if.not.eq?.ret.const . #f)
           (push.iloc.1 . 1)
           (push.subr.gloc.of caaadr 1 (caaadr form\x60;2772*))
           (push.iloc.1 . 1)
           (subr.gloc.of caaddr 1 (caaddr form\x60;2772*))
           (ret.eq? (\x2E;eq? (caaadr form\x60;2772*) (caaddr form\x60;2772*))))
         (if.true
           (push.iloc.1 . 1)
           (push.subr.gloc.of cdaadr 1 (cdaadr form\x60;2772*))
           (push.subr.gloc.of cddar 1 (cddar (cdaadr form\x60;2772*)))
           (extend . 1)
           (call
             (push.iloc 2 . 0)
             (push.iloc 2 . 1)
             (push.subr.gloc.of cdaddr 1 (cdaddr form\x60;2772*))
             (apply.gloc.of
               core.optimize\x27;check-stackable-each
               (core.optimize\x27;check-stackable-each var\x60;2772* (cdaddr form\x60;2772*))))
           (if.false.ret)
           (push.iloc 2 . 0)
           (push.iloc.0 . 0)
           (push.iloc 2 . 2)
           (apply.gloc.of
             core.optimize\x27;check-stackable-seq
             (core.optimize\x27;check-stackable-seq var\x60;2772* body\x60;2784* tail\x60;2772*)))
         (call
           (push.close
             (1 0)
             (push.iloc 2 . 0)
             (push.cadr.iloc (0 . 0) (\x2E;cadr b\x60;2787*))
             (push.const . #f)
             (apply.gloc.of
               core.optimize\x27;check-stackable
               (core.optimize\x27;check-stackable var\x60;2772* (\x2E;cadr b\x60;2787*) #f)))
           (push.cadr.iloc (1 . 1) (\x2E;cadr form\x60;2772*))
           (apply.gloc.of
             core.lists\x27;for-all
             (core.lists\x27;for-all
               (lambda (b\x60;2787*)
                 (core.optimize\x27;check-stackable var\x60;2772* (\x2E;cadr b\x60;2787*) #f))
               (\x2E;cadr form\x60;2772*))))
         (if.false.ret)
         (push.iloc.1 . 0)
         (push.cddr.iloc (1 . 1) (\x2E;cddr form\x60;2772*))
         (push.iloc.1 . 2)
         (apply.gloc.of
           core.optimize\x27;check-stackable-seq
           (core.optimize\x27;check-stackable-seq
             var\x60;2772*
             (\x2E;cddr form\x60;2772*)
             tail\x60;2772*)))
       (call
         (push.close
           (1 0)
           (push.iloc 2 . 0)
           (push.cadr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 763975)
           (push.const . #f)
           (apply.gloc.of core.optimize\x27;check-stackable "../stdlib/core/optimize.scm" . 763954))
         (push.cadr.iloc (1 . 1) "../stdlib/core/optimize.scm" . 763989)
         (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 763933))
       (if.false.ret)
       (push.iloc.1 . 0)
       (push.cddr.iloc (1 . 1) "../stdlib/core/optimize.scm" . 764982)
       (push.iloc.1 . 2)
       (apply.gloc.of core.optimize\x27;check-stackable-seq "../stdlib/core/optimize.scm" . 764957))
     (push.iloc.0 . 0)
     (const . if)
     (if.eq?
       (call
         (push.iloc.1 . 0)
         (push.cadr.iloc (1 . 1) "../stdlib/core/optimize.scm" . 767019)
         (push.const . #f)
         (apply.gloc.of core.optimize\x27;check-stackable "../stdlib/core/optimize.scm" . 766998))
       (if.false.ret)
       (call
         (push.iloc.1 . 0)
         (push.iloc.1 . 1)
         (push.subr.gloc.of \x2E;caddr 1 "../stdlib/core/optimize.scm" . 768043)
         (push.iloc.1 . 2)
         (apply.gloc.of core.optimize\x27;check-stackable "../stdlib/core/optimize.scm" . 768022))
       (if.false.ret)
       (push.iloc.1 . 1)
       (subr.gloc.of \x2E;cdddr 1 "../stdlib/core/optimize.scm" . 769057)
       (if.null?.ret.const . #t)
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.subr.gloc.of \x2E;cadddr 1 "../stdlib/core/optimize.scm" . 769092)
       (push.iloc.1 . 2)
       (apply.gloc.of core.optimize\x27;check-stackable "../stdlib/core/optimize.scm" . 769071))
     (push.iloc.0 . 0)
     (const . quote)
     (if.eq?.ret.const . #t)
     (car.iloc (1 . 1) "../stdlib/core/optimize.scm" . 772129)
     (if.symbol?
       (push.car.iloc (1 . 1) "../stdlib/core/optimize.scm" . 773153)
       (iloc.1 . 0)
       (if.eq?
         (iloc.1 . 2)
         (if.false.ret)
         (push.iloc.1 . 0)
         (push.cdr.iloc (1 . 1) "../stdlib/core/optimize.scm" . 774208)
         (apply.gloc.of
           core.optimize\x27;check-stackable-each
           "../stdlib/core/optimize.scm"
           .
           774182))
       (push.iloc.1 . 0)
       (push.cdr.iloc (1 . 1) "../stdlib/core/optimize.scm" . 775222)
       (apply.gloc.of
         core.optimize\x27;check-stackable-each
         "../stdlib/core/optimize.scm"
         .
         775196))
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.gloc.of core.optimize\x27;check-stackable-each "../stdlib/core/optimize.scm" . 777240))
   (ret.const . #t))
 (set.gloc.of core.optimize\x27;check-stackable)
 (close
   (3 0 . core.optimize\x27;transcribe-each)
   (extend.enclose+
     (1 0 . loop)
     (iloc.0 . 0)
     (if.null?.ret.const)
     (call
       (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 785446)
       (push.iloc 2 . 1)
       (push.iloc 2 . 2)
       (apply.gloc.of core.optimize\x27;transcribe "../stdlib/core/optimize.scm" . 785434))
     (push)
     (call
       (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 785479)
       (apply.iloc+ (1 . 0) "../stdlib/core/optimize.scm" . 785473))
     (push)
     (extend . 2)
     (call
       (push.iloc.0 . 0)
       (car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 786467)
       (if.not.eq?.ret.const . #f)
       (push.iloc.0 . 1)
       (cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 786486)
       (ret.eq? "../stdlib/core/optimize.scm" . 786478))
     (if.true (ret.iloc 1 . 0))
     (push.iloc.0 . 0)
     (iloc.0 . 1)
     (ret.cons "../stdlib/core/optimize.scm" . 788502))
   (push.iloc.1 . 0)
   (apply.iloc+ (0 . 0) "../stdlib/core/optimize.scm" . 783369))
 (set.gloc.of core.optimize\x27;transcribe-each)
 (close
   (3 0 . core.optimize\x27;transcribe-binding-construct)
   (push.cddr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 798761)
   (extend . 1)
   (call
     (push.gloc.of \x2E;car)
     (push.cadr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 798742)
     (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 799765))
   (push)
   (call
     (push.gloc.of \x2E;cadr)
     (push.cadr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 798742)
     (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 799791))
   (push)
   (extend . 2)
   (call
     (push.car.iloc (2 . 0) "../stdlib/core/optimize.scm" . 800801)
     (const . letrec*)
     (if.eq?
       (push.close
         (1 0)
         (push.iloc 3 . 2)
         (push.iloc.0 . 0)
         (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 802855)
         (if.true.ret)
         (push.iloc 3 . 1)
         (push.iloc.0 . 0)
         (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 803879)
         (if.true.ret)
         (call
           (push.gloc.of core.optimize\x27;ht-variable-pinned)
           (push.iloc.0 . 0)
           (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 804908)
           (if.false.ret)
           (ret.iloc 0 . 0))
         (if.true.ret)
         (push.gloc.of core.optimize\x27;ht-variable-refc)
         (push.iloc.0 . 0)
         (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 805932)
         (if.false.ret)
         (ret.iloc 0 . 0))
       (push.iloc.0 . 0)
       (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 801820))
     (push.close
       (1 0)
       (push.iloc 3 . 2)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 808999)
       (if.true.ret)
       (push.iloc 3 . 1)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 810023)
       (if.true.ret)
       (push.gloc.of core.optimize\x27;ht-variable-refc)
       (push.iloc.0 . 0)
       (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 811052)
       (if.false.ret)
       (ret.iloc 0 . 0))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 807964))
   (push)
   (extend . 1)
   (call
     (push.gloc.of \x2E;symbol?)
     (push.iloc.0 . 0)
     (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 813076))
   (if.true
     (call
       (push.iloc 2 . 0)
       (push.iloc 3 . 1)
       (push.iloc 3 . 2)
       (apply.gloc.of core.optimize\x27;transcribe-each "../stdlib/core/optimize.scm" . 814116))
     (push)
     (extend . 1)
     (call
       (push.iloc 2 . 1)
       (push.iloc 4 . 1)
       (push.iloc 4 . 2)
       (apply.gloc.of core.optimize\x27;transcribe-each "../stdlib/core/optimize.scm" . 815143))
     (push)
     (extend . 1)
     (call
       (call
         (push.gloc.of \x2E;eq?)
         (push.iloc 3 . 1)
         (push.iloc.0 . 0)
         (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 816164))
       (if.false.ret)
       (push.gloc.of \x2E;eq?)
       (push.iloc 4 . 0)
       (push.iloc.1 . 0)
       (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 816194))
     (if.true (ret.iloc 5 . 0))
     (push.car.iloc (5 . 0) "../stdlib/core/optimize.scm" . 817197)
     (call
       (push.gloc.of \x2E;list)
       (push.iloc 3 . 0)
       (push.iloc.0 . 0)
       (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 817209))
     (push)
     (push.iloc.1 . 0)
     (push.subr.gloc.of \x2E;cons* 3 "../stdlib/core/optimize.scm" . 817188)
     (extend . 1)
     (push.iloc.0 . 0)
     (iloc 6 . 0)
     (if.eq? (ret.iloc 0 . 0))
     (call
       (push.iloc.0 . 0)
       (push.iloc 6 . 0)
       (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
       (apply))
     (ret.iloc 0 . 0))
   (call
     (push.iloc 2 . 0)
     (push.iloc 3 . 1)
     (push.iloc 3 . 2)
     (apply.gloc.of core.optimize\x27;transcribe-each "../stdlib/core/optimize.scm" . 819236))
   (push)
   (extend . 1)
   (push.close
     (0 0)
     (extend.enclose+
       (5 0 . loop)
       (iloc.0 . 0)
       (if.null?
         (push.iloc.0 . 3)
         (push.subr.gloc.of \x2E;reverse 1 "../stdlib/core/optimize.scm" . 823349)
         (push.iloc.0 . 4)
         (push.subr.gloc.of \x2E;reverse 1 "../stdlib/core/optimize.scm" . 824373)
         (ret.subr.gloc.of \x2E;values "../stdlib/core/optimize.scm" . 823341))
       (push.car.iloc (0 . 1) "../stdlib/core/optimize.scm" . 825394)
       (const . #t)
       (if.eq?
         (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 826419)
         (push.cdr.iloc (0 . 1) "../stdlib/core/optimize.scm" . 826430)
         (push.cdr.iloc (0 . 2) "../stdlib/core/optimize.scm" . 826442)
         (push.iloc.0 . 3)
         (push.iloc.0 . 4)
         (apply.iloc+ (1 . 0) "../stdlib/core/optimize.scm" . 826413))
       (push.car.iloc (0 . 1) "../stdlib/core/optimize.scm" . 829490)
       (const . #f)
       (if.eq?
         (call
           (push.car.iloc (0 . 2) "../stdlib/core/optimize.scm" . 830524)
           (apply.gloc.of core.optimize\x27;function? "../stdlib/core/optimize.scm" . 830513))
         (if.true
           (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 831543)
           (push.cdr.iloc (0 . 1) "../stdlib/core/optimize.scm" . 831554)
           (push.cdr.iloc (0 . 2) "../stdlib/core/optimize.scm" . 831566)
           (push.iloc.0 . 3)
           (push.iloc.0 . 4)
           (apply.iloc+ (1 . 0) "../stdlib/core/optimize.scm" . 831537))
         (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 834615)
         (push.cdr.iloc (0 . 1) "../stdlib/core/optimize.scm" . 834626)
         (push.cdr.iloc (0 . 2) "../stdlib/core/optimize.scm" . 834638)
         (call
           (push.car.iloc (0 . 2) "../stdlib/core/optimize.scm" . 835657)
           (push.iloc 7 . 1)
           (push.iloc 7 . 2)
           (apply.gloc.of core.optimize\x27;transcribe "../stdlib/core/optimize.scm" . 835645))
         (push)
         (iloc.0 . 3)
         (push.cons)
         (push.iloc.0 . 4)
         (apply.iloc+ (1 . 0) "../stdlib/core/optimize.scm" . 834609))
       (car.iloc (0 . 1) "../stdlib/core/optimize.scm" . 837686)
       (if.symbol?
         (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 838707)
         (push.cdr.iloc (0 . 1) "../stdlib/core/optimize.scm" . 838718)
         (push.cdr.iloc (0 . 2) "../stdlib/core/optimize.scm" . 838730)
         (push.iloc.0 . 3)
         (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 840767)
         (call
           (push.car.iloc (0 . 2) "../stdlib/core/optimize.scm" . 840790)
           (push.iloc 7 . 1)
           (push.iloc 7 . 2)
           (apply.gloc.of core.optimize\x27;transcribe "../stdlib/core/optimize.scm" . 840778))
         (push)
         (push.subr.gloc.of \x2E;list 2 "../stdlib/core/optimize.scm" . 840761)
         (iloc.0 . 4)
         (push.cons)
         (apply.iloc+ (1 . 0) "../stdlib/core/optimize.scm" . 838701))
       (ret.const.unspec))
     (push.iloc 4 . 0)
     (push.iloc 3 . 0)
     (push.iloc 4 . 1)
     (push.const)
     (push.const)
     (apply.iloc+ (0 . 0) "../stdlib/core/optimize.scm" . 822310))
   (push.close
     (2 0)
     (iloc.0 . 0)
     (if.null?
       (push.car.iloc (5 . 0) "../stdlib/core/optimize.scm" . 842792)
       (push.iloc.0 . 1)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;cons* 3 "../stdlib/core/optimize.scm" . 842783)
       (extend . 1)
       (push.iloc.0 . 0)
       (iloc 6 . 0)
       (if.eq? (ret.iloc 0 . 0))
       (call
         (push.iloc.0 . 0)
         (push.iloc 6 . 0)
         (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
         (apply))
       (ret.iloc 0 . 0))
     (push.car.iloc (5 . 0) "../stdlib/core/optimize.scm" . 844843)
     (const . let)
     (if.eq?
       (push.const . begin)
       (push.iloc.0 . 0)
       (push.car.iloc (5 . 0) "../stdlib/core/optimize.scm" . 845887)
       (push.iloc.0 . 1)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;cons* 3 "../stdlib/core/optimize.scm" . 845887)
       (push.subr.gloc.of \x2E;list 1 "../stdlib/core/optimize.scm" . 845887)
       (subr.gloc.of \x2E;append 2 "../stdlib/core/optimize.scm" . 845887)
       (push.cons)
       (extend . 1)
       (push.iloc.0 . 0)
       (iloc 6 . 0)
       (if.eq? (ret.iloc 0 . 0))
       (call
         (push.iloc.0 . 0)
         (push.iloc 6 . 0)
         (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
         (apply))
       (ret.iloc 0 . 0))
     (push.car.iloc (5 . 0) "../stdlib/core/optimize.scm" . 846891)
     (const . letrec*)
     (if.eq?
       (push.car.iloc (5 . 0) "../stdlib/core/optimize.scm" . 847919)
       (push.iloc.0 . 1)
       (push.iloc.0 . 0)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;append 2 (\x2E;append motion\x60;2825* new-body\x60;2823*))
       (push.subr.gloc.of \x2E;cons* 3 "../stdlib/core/optimize.scm" . 847910)
       (extend . 1)
       (push.iloc.0 . 0)
       (iloc 6 . 0)
       (if.eq? (ret.iloc 0 . 0))
       (call
         (push.iloc.0 . 0)
         (push.iloc 6 . 0)
         (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
         (apply))
       (ret.iloc 0 . 0))
     (push.const . "coreform-optimize")
     (push.const . "internal inconsistency in ~s")
     (push.gloc.of core.optimize\x27;transcribe-binding-construct)
     (push.subr.gloc.of \x2E;format 2 "../stdlib/core/optimize.scm" . 849999)
     (push.iloc 5 . 0)
     (apply.gloc.of \x2E;assertion-violation "../stdlib/core/optimize.scm" . 849958))
   (apply.gloc.of
     \x2E;call-with-values
     (\x2E;call-with-values
       (lambda ()
         (letrec* ((loop\x60;2828*
                     (lambda (vars\x60;2829*
                               flags\x60;2829*
                               inits\x60;2829*
                               motion\x60;2829*
                               binding\x60;2829*)
                       (if (\x2E;null? vars\x60;2829*)
                           (\x2E;values
                             (\x2E;reverse motion\x60;2829*)
                             (\x2E;reverse binding\x60;2829*))
                           (if (\x2E;eq? (\x2E;car flags\x60;2829*) #t)
                               (loop\x60;2828*
                                 (\x2E;cdr vars\x60;2829*)
                                 (\x2E;cdr flags\x60;2829*)
                                 (\x2E;cdr inits\x60;2829*)
                                 motion\x60;2829*
                                 binding\x60;2829*)
                               (if (\x2E;eq? (\x2E;car flags\x60;2829*) #f)
                                   (if (core.optimize\x27;function? (\x2E;car inits\x60;2829*))
                                       (loop\x60;2828*
                                         (\x2E;cdr vars\x60;2829*)
                                         (\x2E;cdr flags\x60;2829*)
                                         (\x2E;cdr inits\x60;2829*)
                                         motion\x60;2829*
                                         binding\x60;2829*)
                                       (loop\x60;2828*
                                         (\x2E;cdr vars\x60;2829*)
                                         (\x2E;cdr flags\x60;2829*)
                                         (\x2E;cdr inits\x60;2829*)
                                         (\x2E;cons
                                           (core.optimize\x27;transcribe
                                             (\x2E;car inits\x60;2829*)
                                             lift\x60;2801*
                                             subst\x60;2801*)
                                           motion\x60;2829*)
                                         binding\x60;2829*))
                                   (if (\x2E;symbol? (\x2E;car flags\x60;2829*))
                                       (loop\x60;2828*
                                         (\x2E;cdr vars\x60;2829*)
                                         (\x2E;cdr flags\x60;2829*)
                                         (\x2E;cdr inits\x60;2829*)
                                         motion\x60;2829*
                                         (\x2E;cons
                                           (\x2E;list
                                             (\x2E;car vars\x60;2829*)
                                             (core.optimize\x27;transcribe
                                               (\x2E;car inits\x60;2829*)
                                               lift\x60;2801*
                                               subst\x60;2801*))
                                           binding\x60;2829*))
                                       (\x2E;unspecified))))))))
           (loop\x60;2828* vars\x60;2808* flags\x60;2814* inits\x60;2808* '() '())))
       (lambda (motion\x60;2825* binding\x60;2825*)
         (if (\x2E;null? motion\x60;2825*)
             (let ((new\x60;2833\x60;2834*
                     (\x2E;cons* (\x2E;car form\x60;2801*) binding\x60;2825* new-body\x60;2823*)))
               (if (\x2E;eq? new\x60;2833\x60;2834* form\x60;2801*)
                   new\x60;2833\x60;2834*
                   (begin
                     ((core.optimize\x27;annotate-hook) new\x60;2833\x60;2834* form\x60;2801*)
                     new\x60;2833\x60;2834*)))
             (if (\x2E;eq? (\x2E;car form\x60;2801*) 'let)
                 (let ((new\x60;2836\x60;2837*
                         (\x2E;cons
                           'begin
                           (\x2E;append
                             motion\x60;2825*
                             (\x2E;list
                               (\x2E;cons*
                                 (\x2E;car form\x60;2801*)
                                 binding\x60;2825*
                                 new-body\x60;2823*))))))
                   (if (\x2E;eq? new\x60;2836\x60;2837* form\x60;2801*)
                       new\x60;2836\x60;2837*
                       (begin
                         ((core.optimize\x27;annotate-hook) new\x60;2836\x60;2837* form\x60;2801*)
                         new\x60;2836\x60;2837*)))
                 (if (\x2E;eq? (\x2E;car form\x60;2801*) 'letrec*)
                     (let ((new\x60;2839\x60;2840*
                             (\x2E;cons*
                               (\x2E;car form\x60;2801*)
                               binding\x60;2825*
                               (\x2E;append motion\x60;2825* new-body\x60;2823*))))
                       (if (\x2E;eq? new\x60;2839\x60;2840* form\x60;2801*)
                           new\x60;2839\x60;2840*
                           (begin
                             ((core.optimize\x27;annotate-hook)
                              new\x60;2839\x60;2840*
                              form\x60;2801*)
                             new\x60;2839\x60;2840*)))
                     (\x2E;assertion-violation
                       "coreform-optimize"
                       (\x2E;format
                         "internal inconsistency in ~s"
                         core.optimize\x27;transcribe-binding-construct)
                       form\x60;2801*))))))))
 (set.gloc.of core.optimize\x27;transcribe-binding-construct)
 (close
   (3 0 . core.optimize\x27;transcribe)
   (iloc.0 . 0)
   (if.pair?
     (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 866324)
     (extend . 1)
     (push.iloc.0 . 0)
     (push.const let letrec*)
     (subr.gloc.of \x2E;memq 2 "../stdlib/core/optimize.scm" . 867345)
     (if.true
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (apply.gloc.of
         core.optimize\x27;transcribe-binding-construct
         "../stdlib/core/optimize.scm"
         .
         868369))
     (push.iloc.0 . 0)
     (push.const quote define lambda if)
     (subr.gloc.of \x2E;memq 2 "../stdlib/core/optimize.scm" . 867345)
     (if.true
       (call
         (iloc.1 . 0)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (1 . 0) (cdr form\x60;2842*))
         (ret.pair? (pair? (cdr form\x60;2842*))))
       (push)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (cddr.iloc (2 . 0) (cddr form\x60;2842*))
         (if.not.null?.ret.const . #f)
         (push.car.iloc (2 . 0) (car form\x60;2842*))
         (const . quote)
         (ret.eq? (eq? (car form\x60;2842*) 'quote)))
       (if.true (ret.iloc 2 . 0))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (2 . 0) (car form\x60;2842*))
         (const . lambda)
         (ret.eq? (eq? (car form\x60;2842*) 'lambda)))
       (if.true
         (push.cddr.iloc (2 . 0) (cddr form\x60;2842*))
         (push.cadr.iloc (2 . 0) (cadr form\x60;2842*))
         (extend . 2)
         (push.iloc 3 . 1)
         (push.iloc 3 . 0)
         (push.const . #f)
         (push.subr.gloc.of
           \x2E;core-hashtable-ref
           3
           (\x2E;core-hashtable-ref lift\x60;2842* form\x60;2842* #f))
         (extend . 1)
         (iloc.0 . 0)
         (if.true
           (push.iloc.0 . 0)
           (ret.subr.gloc.of \x2E;values (\x2E;values \x2E;L924\x60;2862*)))
         (call
           (push.iloc.1 . 0)
           (push.iloc 4 . 1)
           (push.iloc 4 . 2)
           (apply.gloc.of
             core.optimize\x27;transcribe-each
             (core.optimize\x27;transcribe-each e2\x60;2860* lift\x60;2842* subst\x60;2842*)))
         (push)
         (extend . 1)
         (push.iloc 2 . 0)
         (iloc.0 . 0)
         (if.eq? (ret.iloc 5 . 0))
         (call
           (push.const . lambda)
           (push.iloc 2 . 1)
           (push.iloc.0 . 0)
           (push.subr.gloc.of \x2E;cons* 3 (\x2E;cons* 'lambda e1\x60;2860* e2a\x60;2864*))
           (extend . 1)
           (push.iloc.0 . 0)
           (iloc 6 . 0)
           (if.eq? (ret.iloc 0 . 0))
           (call
             (push.iloc.0 . 0)
             (push.iloc 6 . 0)
             (call
               (apply.gloc.of
                 core.optimize\x27;annotate-closure-hook
                 (core.optimize\x27;annotate-closure-hook)))
             (apply))
           (ret.iloc 0 . 0))
         (push)
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc 6 . 0)
         (if.eq? (ret.iloc 0 . 0))
         (call
           (push.iloc.0 . 0)
           (push.iloc 6 . 0)
           (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
           (apply))
         (ret.iloc 0 . 0))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (cddr.iloc (2 . 0) (cddr form\x60;2842*))
         (if.not.pair?.ret.const . #f)
         (push.iloc 2 . 0)
         (subr.gloc.of caddr 1 (caddr form\x60;2842*))
         (if.not.pair?.ret.const . #f)
         (push.iloc 2 . 0)
         (subr.gloc.of cdaddr 1 (cdaddr form\x60;2842*))
         (if.not.pair?.ret.const . #f)
         (push.iloc 2 . 0)
         (subr.gloc.of cdddr 1 (cdddr form\x60;2842*))
         (if.not.null?.ret.const . #f)
         (push.car.iloc (2 . 0) (car form\x60;2842*))
         (const . define)
         (if.not.eq?.ret.const . #f)
         (push.iloc 2 . 0)
         (push.subr.gloc.of caaddr 1 (caaddr form\x60;2842*))
         (const . lambda)
         (ret.eq? (eq? (caaddr form\x60;2842*) 'lambda)))
       (if.true
         (push.iloc 2 . 0)
         (push.subr.gloc.of cdaddr 1 (cdaddr form\x60;2842*))
         (push.subr.gloc.of cdr 1 (cdr (cdaddr form\x60;2842*)))
         (push.iloc 2 . 0)
         (push.subr.gloc.of cdaddr 1 (cdaddr form\x60;2842*))
         (push.subr.gloc.of car 1 (car (cdaddr form\x60;2842*)))
         (push.cadr.iloc (2 . 0) (cadr form\x60;2842*))
         (extend . 3)
         (call
           (push.iloc.0 . 0)
           (push.iloc 3 . 1)
           (push.iloc 3 . 2)
           (apply.gloc.of
             core.optimize\x27;transcribe-each
             (core.optimize\x27;transcribe-each e3\x60;2872* lift\x60;2842* subst\x60;2842*)))
         (push)
         (extend . 1)
         (push.iloc.1 . 0)
         (iloc.0 . 0)
         (if.eq? (ret.iloc 4 . 0))
         (push.const . define)
         (push.iloc.1 . 2)
         (call
           (push.const . lambda)
           (push.iloc.1 . 1)
           (push.iloc.0 . 0)
           (push.subr.gloc.of \x2E;cons* 3 (\x2E;cons* 'lambda e2\x60;2872* e3a\x60;2874*))
           (push.iloc 4 . 0)
           (push.subr.gloc.of \x2E;caddr 1 (\x2E;caddr form\x60;2842*))
           (extend . 2)
           (push.iloc.0 . 0)
           (iloc.0 . 1)
           (if.eq? (ret.iloc 0 . 0))
           (call
             (push.iloc.0 . 0)
             (push.iloc.0 . 1)
             (call
               (apply.gloc.of
                 core.optimize\x27;annotate-closure-hook
                 (core.optimize\x27;annotate-closure-hook)))
             (apply))
           (ret.iloc 0 . 0))
         (push)
         (push.subr.gloc.of
           \x2E;list
           3
           (\x2E;list
             'define
             e1\x60;2872*
             (let ((new\x60;2876\x60;2877* (\x2E;cons* 'lambda e2\x60;2872* e3a\x60;2874*))
                   (soruce\x60;2876\x60;2877* (\x2E;caddr form\x60;2842*)))
               (if (\x2E;eq? new\x60;2876\x60;2877* soruce\x60;2876\x60;2877*)
                   new\x60;2876\x60;2877*
                   (begin
                     ((core.optimize\x27;annotate-closure-hook)
                      new\x60;2876\x60;2877*
                      soruce\x60;2876\x60;2877*)
                     new\x60;2876\x60;2877*)))))
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc 5 . 0)
         (if.eq? (ret.iloc 0 . 0))
         (call
           (push.iloc.0 . 0)
           (push.iloc 5 . 0)
           (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
           (apply))
         (ret.iloc 0 . 0))
       (call
         (push.iloc 2 . 0)
         (push.iloc 2 . 1)
         (push.iloc 2 . 2)
         (apply.gloc.of
           core.optimize\x27;transcribe-each
           (core.optimize\x27;transcribe-each form\x60;2842* lift\x60;2842* subst\x60;2842*)))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (iloc 3 . 0)
       (if.eq? (ret.iloc 0 . 0))
       (call
         (push.iloc.0 . 0)
         (push.iloc 3 . 0)
         (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
         (apply))
       (ret.iloc 0 . 0))
     (call
       (push.iloc.1 . 0)
       (push.iloc.1 . 1)
       (push.iloc.1 . 2)
       (apply.gloc.of core.optimize\x27;transcribe-each "../stdlib/core/optimize.scm" . 888855))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (iloc 2 . 0)
     (if.eq? (ret.iloc 0 . 0))
     (call
       (push.iloc.0 . 0)
       (push.iloc 2 . 0)
       (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
       (apply))
     (ret.iloc 0 . 0))
   (iloc.0 . 0)
   (if.symbol?
     (push.iloc.0 . 2)
     (push.iloc.0 . 0)
     (push.const . #f)
     (subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 890898)
     (if.true.ret)
     (ret.iloc 0 . 0))
   (ret.iloc 0 . 0))
 (set.gloc.of core.optimize\x27;transcribe)
 (close
   (1 0 . core.optimize\x27;self-evaluation?)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;number? 1 "../stdlib/core/optimize.scm" . 896011)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;boolean? 1 "../stdlib/core/optimize.scm" . 896023)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;char? 1 "../stdlib/core/optimize.scm" . 896036)
   (if.true.ret)
   (push.iloc.0 . 0)
   (subr.gloc.of \x2E;string? 1 "../stdlib/core/optimize.scm" . 896046)
   (if.true.ret)
   (push.iloc.0 . 0)
   (ret.subr.gloc.of \x2E;bytevector? "../stdlib/core/optimize.scm" . 896058))
 (set.gloc.of core.optimize\x27;self-evaluation?)
 (close
   (1 0 . core.optimize\x27;pretty-each)
   (touch.gloc.of loop\x60;2898*)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;2898* "../stdlib/core/optimize.scm" . 901129))
 (set.gloc.of core.optimize\x27;pretty-each)
 (close
   (1 0 . core.optimize\x27;pretty)
   (extend.enclose+
     (1 0 . divide)
     (push.gloc.of core.optimize\x27;limit-arguments)
     (push.const . 1)
     (push.subr.gloc.of \x2E;- 2 "../stdlib/core/optimize.scm" . 939033)
     (extend . 1)
     (call
       (extend.enclose+
         (2 0 . loop)
         (push.iloc.0 . 1)
         (subr.gloc.of \x2E;length 1 "../stdlib/core/optimize.scm" . 941092)
         (>.iloc (2 . 0) "../stdlib/core/optimize.scm" . 941089)
         (if.true
           (push.iloc.0 . 1)
           (push.iloc 2 . 0)
           (push.subr.gloc.of \x2E;list-head 2 "../stdlib/core/optimize.scm" . 942125)
           (iloc.0 . 0)
           (push.cons)
           (push.iloc.0 . 1)
           (push.iloc 2 . 0)
           (push.subr.gloc.of \x2E;list-tail 2 "../stdlib/core/optimize.scm" . 943143)
           (apply.iloc+ (1 . 0) "../stdlib/core/optimize.scm" . 942113))
         (push.iloc.0 . 1)
         (iloc.0 . 0)
         (push.cons)
         (ret.subr.gloc.of \x2E;reverse "../stdlib/core/optimize.scm" . 944166))
       (push.const)
       (push.cdr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 940083)
       (apply.iloc+ (0 . 0) "../stdlib/core/optimize.scm" . 941082))
     (push)
     (extend . 1)
     (call
       (car.iloc (2 . 0) "../stdlib/core/optimize.scm" . 945183)
       (if.not.symbol?.ret.const . #f)
       (push.car.iloc (2 . 0) "../stdlib/core/optimize.scm" . 946216)
       (subr.gloc.of \x2E;top-level-bound? 1 "../stdlib/core/optimize.scm" . 946198)
       (if.false.ret)
       (push.car.iloc (2 . 0) "../stdlib/core/optimize.scm" . 947244)
       (push.subr.gloc.of \x2E;top-level-value 1 "../stdlib/core/optimize.scm" . 947227)
       (push.const . \x2E;list)
       (subr.gloc.of \x2E;top-level-value 1 "../stdlib/core/optimize.scm" . 947256)
       (ret.eq? "../stdlib/core/optimize.scm" . 947222))
     (if.true
       (call
         (push.const . \x2E;append)
         (call
           (push.gloc.of \x2E;L988)
           (push.iloc.0 . 0)
           (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 948267))
         (push.cons)
         (apply.gloc.of core.optimize\x27;pretty "../stdlib/core/optimize.scm" . 948247))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (iloc 5 . 0)
       (if.eq? (ret.iloc 0 . 0))
       (call
         (push.iloc.0 . 0)
         (push.iloc 5 . 0)
         (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
         (apply))
       (ret.iloc 0 . 0))
     (call
       (push.const . \x2E;apply)
       (push.car.iloc (2 . 0) "../stdlib/core/optimize.scm" . 949289)
       (push.const . \x2E;append)
       (call
         (push.gloc.of \x2E;L1007)
         (push.iloc.0 . 0)
         (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 949311))
       (push.cons)
       (push.subr.gloc.of \x2E;list 3 "../stdlib/core/optimize.scm" . 949271)
       (apply.gloc.of core.optimize\x27;pretty "../stdlib/core/optimize.scm" . 949271))
     (push)
     (extend . 1)
     (push.iloc.0 . 0)
     (iloc 5 . 0)
     (if.eq? (ret.iloc 0 . 0))
     (call
       (push.iloc.0 . 0)
       (push.iloc 5 . 0)
       (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
       (apply))
     (ret.iloc 0 . 0))
   (iloc.1 . 0)
   (if.pair?
     (car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 952342)
     (if.pair?
       (call
         (iloc.1 . 0)
         (if.not.pair?.ret.const . #f)
         (car.iloc (1 . 0) (car form\x60;2904*))
         (if.not.pair?.ret.const . #f)
         (push.iloc.1 . 0)
         (subr.gloc.of cdar 1 (cdar form\x60;2904*))
         (if.not.pair?.ret.const . #f)
         (push.iloc.1 . 0)
         (push.subr.gloc.of cadar 1 (cadar form\x60;2904*))
         (subr.gloc.of list? 1 (list? (cadar form\x60;2904*)))
         (if.false.ret)
         (push.iloc.1 . 0)
         (push.subr.gloc.of caar 1 (caar form\x60;2904*))
         (const . lambda)
         (if.not.eq?.ret.const . #f)
         (push.iloc.1 . 0)
         (push.subr.gloc.of cadar 1 (cadar form\x60;2904*))
         (push.subr.gloc.of \x2E;length 1 (\x2E;length (cadar form\x60;2904*)))
         (push.cdr.iloc (1 . 0) (cdr form\x60;2904*))
         (push.subr.gloc.of \x2E;length 1 (\x2E;length (cdr form\x60;2904*)))
         (ret.subr.gloc.of
           \x2E;=
           (\x2E;= (\x2E;length (cadar form\x60;2904*)) (\x2E;length (cdr form\x60;2904*)))))
       (if.true
         (push.const . let)
         (call
           (push.gloc.of \x2E;list)
           (push.iloc.1 . 0)
           (push.subr.gloc.of cadar 1 (cadar form\x60;2904*))
           (call
             (push.cdr.iloc (1 . 0) (cdr form\x60;2904*))
             (apply.gloc.of
               core.optimize\x27;pretty-each
               (core.optimize\x27;pretty-each (cdr form\x60;2904*))))
           (push)
           (apply.gloc.of
             \x2E;map
             (\x2E;map
               \x2E;list
               (cadar form\x60;2904*)
               (core.optimize\x27;pretty-each (cdr form\x60;2904*)))))
         (push)
         (call
           (call
             (push.iloc.1 . 0)
             (push.subr.gloc.of cddar 1 (cddar form\x60;2904*))
             (apply.gloc.of
               core.optimize\x27;pretty-each
               (core.optimize\x27;pretty-each (cddar form\x60;2904*))))
           (push)
           (apply.gloc.of
             core.optimize\x27;flatten-begin
             (core.optimize\x27;flatten-begin
               (core.optimize\x27;pretty-each (cddar form\x60;2904*)))))
         (push)
         (push.subr.gloc.of
           \x2E;cons*
           3
           (\x2E;cons*
             'let
             (\x2E;map
               \x2E;list
               (cadar form\x60;2904*)
               (core.optimize\x27;pretty-each (cdr form\x60;2904*)))
             (core.optimize\x27;flatten-begin
               (core.optimize\x27;pretty-each (cddar form\x60;2904*)))))
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc 2 . 0)
         (if.eq? (ret.iloc 0 . 0))
         (call
           (push.iloc.0 . 0)
           (push.iloc 2 . 0)
           (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
           (apply))
         (ret.iloc 0 . 0))
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;length 1 (\x2E;length form\x60;2904*))
       (push.gloc.of core.optimize\x27;limit-arguments)
       (subr.gloc.of
         \x2E;>
         2
         (\x2E;> (\x2E;length form\x60;2904*) core.optimize\x27;limit-arguments))
       (if.true (push.iloc.1 . 0) (apply.iloc+ (0 . 0) (divide\x60;2905* form\x60;2904*)))
       (push.iloc.1 . 0)
       (apply.gloc.of core.optimize\x27;pretty-each (core.optimize\x27;pretty-each form\x60;2904*)))
     (push.car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 962581)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . and)
     (if.eq?
       (cdr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 964640)
       (if.null?.ret.const . #t)
       (cddr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 965664)
       (if.null?
         (push.cadr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 965683)
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc 3 . 0)
         (if.eq? (ret.iloc 0 . 0))
         (call
           (push.iloc.0 . 0)
           (push.iloc 3 . 0)
           (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
           (apply))
         (ret.iloc 0 . 0))
       (call
         (push.cdr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 967729)
         (apply.gloc.of core.optimize\x27;pretty-each "../stdlib/core/optimize.scm" . 967716))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (cdr.iloc (3 . 0) "../stdlib/core/optimize.scm" . 968747)
       (if.eq?
         (call
           (touch.gloc.of flatten-expression\x60;2905*)
           (push.iloc 3 . 0)
           (push.const . and)
           (apply.gloc.of flatten-expression\x60;2905* "../stdlib/core/optimize.scm" . 969768))
         (push)
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc 4 . 0)
         (if.eq? (ret.iloc 0 . 0))
         (call
           (push.iloc.0 . 0)
           (push.iloc 4 . 0)
           (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
           (apply))
         (ret.iloc 0 . 0))
       (call
         (touch.gloc.of flatten-expression\x60;2905*)
         (push.const . and)
         (iloc.0 . 0)
         (push.cons)
         (push.const . and)
         (apply.gloc.of flatten-expression\x60;2905* "../stdlib/core/optimize.scm" . 971816))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (iloc 4 . 0)
       (if.eq? (ret.iloc 0 . 0))
       (call
         (push.iloc.0 . 0)
         (push.iloc 4 . 0)
         (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
         (apply))
       (ret.iloc 0 . 0))
     (push.iloc.0 . 0)
     (const . or)
     (if.eq?
       (cdr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 973856)
       (if.null?.ret.const . #f)
       (cddr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 974880)
       (if.null?
         (push.cadr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 974899)
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc 3 . 0)
         (if.eq? (ret.iloc 0 . 0))
         (call
           (push.iloc.0 . 0)
           (push.iloc 3 . 0)
           (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
           (apply))
         (ret.iloc 0 . 0))
       (call
         (push.cdr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 976945)
         (apply.gloc.of core.optimize\x27;pretty-each "../stdlib/core/optimize.scm" . 976932))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (cdr.iloc (3 . 0) "../stdlib/core/optimize.scm" . 977963)
       (if.eq?
         (call
           (touch.gloc.of flatten-expression\x60;2905*)
           (push.iloc 3 . 0)
           (push.const . or)
           (apply.gloc.of flatten-expression\x60;2905* "../stdlib/core/optimize.scm" . 978984))
         (push)
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc 4 . 0)
         (if.eq? (ret.iloc 0 . 0))
         (call
           (push.iloc.0 . 0)
           (push.iloc 4 . 0)
           (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
           (apply))
         (ret.iloc 0 . 0))
       (call
         (touch.gloc.of flatten-expression\x60;2905*)
         (push.const . or)
         (iloc.0 . 0)
         (push.cons)
         (push.const . or)
         (apply.gloc.of flatten-expression\x60;2905* "../stdlib/core/optimize.scm" . 981032))
       (push)
       (extend . 1)
       (push.iloc.0 . 0)
       (iloc 4 . 0)
       (if.eq? (ret.iloc 0 . 0))
       (call
         (push.iloc.0 . 0)
         (push.iloc 4 . 0)
         (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
         (apply))
       (ret.iloc 0 . 0))
     (push.iloc.0 . 0)
     (const . if)
     (if.eq?
       (push.cdr.iloc (2 . 0) (\x2E;cdr form\x60;2904*))
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (0 . 0) (cdr \x2E;L929\x60;2984\x60;2985*))
         (ret.pair? (pair? (cdr \x2E;L929\x60;2984\x60;2985*))))
       (push)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) (car \x2E;L929\x60;2984\x60;2985*))
         (const . #t)
         (ret.eq? (eq? (car \x2E;L929\x60;2984\x60;2985*) #t)))
       (if.true
         (call
           (push.cadr.iloc (1 . 0) (cadr \x2E;L929\x60;2984\x60;2985*))
           (apply.gloc.of
             core.optimize\x27;pretty
             (core.optimize\x27;pretty (cadr \x2E;L929\x60;2984\x60;2985*))))
         (push)
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc 5 . 0)
         (if.eq? (ret.iloc 0 . 0))
         (call
           (push.iloc.0 . 0)
           (push.iloc 5 . 0)
           (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
           (apply))
         (ret.iloc 0 . 0))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (1 . 0) (car \x2E;L929\x60;2984\x60;2985*))
         (const . #f)
         (ret.eq? (eq? (car \x2E;L929\x60;2984\x60;2985*) #f)))
       (if.true
         (push.cddr.iloc (1 . 0) (cddr \x2E;L929\x60;2984\x60;2985*))
         (extend . 1)
         (iloc.0 . 0)
         (if.null?
           (push.const \x2E;unspecified)
           (extend . 1)
           (push.iloc.0 . 0)
           (iloc 6 . 0)
           (if.eq? (ret.iloc 0 . 0))
           (call
             (push.iloc.0 . 0)
             (push.iloc 6 . 0)
             (call
               (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
             (apply))
           (ret.iloc 0 . 0))
         (call
           (push.car.iloc (0 . 0) (\x2E;car e2\x60;2995*))
           (apply.gloc.of
             core.optimize\x27;pretty
             (core.optimize\x27;pretty (\x2E;car e2\x60;2995*))))
         (push)
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc 6 . 0)
         (if.eq? (ret.iloc 0 . 0))
         (call
           (push.iloc.0 . 0)
           (push.iloc 6 . 0)
           (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
           (apply))
         (ret.iloc 0 . 0))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (cddr.iloc (1 . 0) (cddr \x2E;L929\x60;2984\x60;2985*))
         (if.not.pair?.ret.const . #f)
         (push.iloc.1 . 0)
         (subr.gloc.of cdddr 1 (cdddr \x2E;L929\x60;2984\x60;2985*))
         (if.not.null?.ret.const . #f)
         (push.iloc.1 . 0)
         (push.subr.gloc.of caddr 1 (caddr \x2E;L929\x60;2984\x60;2985*))
         (const . #f)
         (ret.eq? (eq? (caddr \x2E;L929\x60;2984\x60;2985*) #f)))
       (if.true
         (push.cadr.iloc (1 . 0) (cadr \x2E;L929\x60;2984\x60;2985*))
         (extend . 1)
         (push.const . and)
         (call
           (push.car.iloc (2 . 0) (car \x2E;L929\x60;2984\x60;2985*))
           (apply.gloc.of
             core.optimize\x27;pretty
             (core.optimize\x27;pretty (car \x2E;L929\x60;2984\x60;2985*))))
         (push)
         (call
           (push.iloc.0 . 0)
           (apply.gloc.of core.optimize\x27;pretty (core.optimize\x27;pretty e2\x60;3003*)))
         (push)
         (push.subr.gloc.of
           \x2E;list
           3
           (\x2E;list
             'and
             (core.optimize\x27;pretty (car \x2E;L929\x60;2984\x60;2985*))
             (core.optimize\x27;pretty e2\x60;3003*)))
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc 6 . 0)
         (if.eq? (ret.iloc 0 . 0))
         (call
           (push.iloc.0 . 0)
           (push.iloc 6 . 0)
           (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
           (apply))
         (ret.iloc 0 . 0))
       (call
         (iloc.1 . 0)
         (if.not.pair?.ret.const . #f)
         (car.iloc (1 . 0) (car \x2E;L929\x60;2984\x60;2985*))
         (if.not.pair?.ret.const . #f)
         (push.iloc.1 . 0)
         (subr.gloc.of cdar 1 (cdar \x2E;L929\x60;2984\x60;2985*))
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (1 . 0) (cdr \x2E;L929\x60;2984\x60;2985*))
         (if.not.pair?.ret.const . #f)
         (cddr.iloc (1 . 0) (cddr \x2E;L929\x60;2984\x60;2985*))
         (if.not.pair?.ret.const . #f)
         (push.iloc.1 . 0)
         (subr.gloc.of cddar 1 (cddar \x2E;L929\x60;2984\x60;2985*))
         (if.not.null?.ret.const . #f)
         (push.iloc.1 . 0)
         (subr.gloc.of cdddr 1 (cdddr \x2E;L929\x60;2984\x60;2985*))
         (if.not.null?.ret.const . #f)
         (push.iloc.1 . 0)
         (push.subr.gloc.of caar 1 (caar \x2E;L929\x60;2984\x60;2985*))
         (const . not)
         (if.not.eq?.ret.const . #f)
         (push.const . not)
         (apply.gloc.of
           core.optimize\x27;primitive-function?
           (core.optimize\x27;primitive-function? 'not)))
       (if.true
         (push.iloc.1 . 0)
         (push.subr.gloc.of caddr 1 (caddr \x2E;L929\x60;2984\x60;2985*))
         (push.cadr.iloc (1 . 0) (cadr \x2E;L929\x60;2984\x60;2985*))
         (extend . 2)
         (push.const . if)
         (call
           (push.iloc 2 . 0)
           (push.subr.gloc.of cadar 1 (cadar \x2E;L929\x60;2984\x60;2985*))
           (apply.gloc.of
             core.optimize\x27;pretty
             (core.optimize\x27;pretty (cadar \x2E;L929\x60;2984\x60;2985*))))
         (push)
         (call
           (push.iloc.0 . 0)
           (apply.gloc.of core.optimize\x27;pretty (core.optimize\x27;pretty e3\x60;3010*)))
         (push)
         (call
           (push.iloc.0 . 1)
           (apply.gloc.of core.optimize\x27;pretty (core.optimize\x27;pretty e2\x60;3010*)))
         (push)
         (push.subr.gloc.of
           \x2E;list
           4
           (\x2E;list
             'if
             (core.optimize\x27;pretty (cadar \x2E;L929\x60;2984\x60;2985*))
             (core.optimize\x27;pretty e3\x60;3010*)
             (core.optimize\x27;pretty e2\x60;3010*)))
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc 6 . 0)
         (if.eq? (ret.iloc 0 . 0))
         (call
           (push.iloc.0 . 0)
           (push.iloc 6 . 0)
           (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
           (apply))
         (ret.iloc 0 . 0))
       (push.iloc 4 . 0)
       (apply.gloc.of core.optimize\x27;pretty-each (core.optimize\x27;pretty-each form\x60;2904*)))
     (push.iloc.0 . 0)
     (push.const quote begin lambda let letrec*)
     (subr.gloc.of \x2E;memq 2 "../stdlib/core/optimize.scm" . 964626)
     (if.true
       (call
         (iloc 2 . 0)
         (if.not.pair?.ret.const . #f)
         (cdr.iloc (2 . 0) (cdr form\x60;2904*))
         (ret.pair? (pair? (cdr form\x60;2904*))))
       (push)
       (extend . 1)
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (cddr.iloc (3 . 0) (cddr form\x60;2904*))
         (if.not.null?.ret.const . #f)
         (push.car.iloc (3 . 0) (car form\x60;2904*))
         (const . quote)
         (ret.eq? (eq? (car form\x60;2904*) 'quote)))
       (if.true
         (call
           (push.cadr.iloc (3 . 0) (cadr form\x60;2904*))
           (apply.gloc.of
             core.optimize\x27;self-evaluation?
             (core.optimize\x27;self-evaluation? (cadr form\x60;2904*))))
         (if.true (push.iloc 3 . 0) (ret.subr.gloc.of cadr (cadr form\x60;2904*)))
         (ret.iloc 3 . 0))
       (call
         (iloc 3 . 0)
         (if.not.pair?.ret.const . #f)
         (push.car.iloc (3 . 0) (car form\x60;2904*))
         (const . begin)
         (ret.eq? (eq? (car form\x60;2904*) 'begin)))
       (if.true
         (push.cdr.iloc (3 . 0) (cdr form\x60;2904*))
         (extend . 1)
         (iloc.0 . 0)
         (if.null? (ret.iloc 4 . 0))
         (call
           (iloc.0 . 0)
           (if.not.pair?.ret.const . #f)
           (cdr.iloc (0 . 0) (\x2E;cdr e1\x60;3024*))
           (ret.null? (\x2E;null? (\x2E;cdr e1\x60;3024*))))
         (if.true (push.iloc.0 . 0) (ret.subr.gloc.of \x2E;car (\x2E;car e1\x60;3024*)))
         (call
           (call
             (push.iloc.0 . 0)
             (apply.gloc.of
               core.optimize\x27;pretty-each
               (core.optimize\x27;pretty-each e1\x60;3024*)))
           (push)
           (apply.gloc.of
             core.optimize\x27;flatten-begin
             (core.optimize\x27;flatten-begin (core.optimize\x27;pretty-each e1\x60;3024*))))
         (push)
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc.1 . 0)
         (if.eq? (ret.iloc 5 . 0))
         (push.const . begin)
         (iloc.0 . 0)
         (push.cons)
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc 6 . 0)
         (if.eq? (ret.iloc 0 . 0))
         (call
           (push.iloc.0 . 0)
           (push.iloc 6 . 0)
           (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
           (apply))
         (ret.iloc 0 . 0))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (3 . 0) (car form\x60;2904*))
         (const . lambda)
         (ret.eq? (eq? (car form\x60;2904*) 'lambda)))
       (if.true
         (push.cddr.iloc (3 . 0) (cddr form\x60;2904*))
         (push.cadr.iloc (3 . 0) (cadr form\x60;2904*))
         (extend . 2)
         (call
           (call
             (push.iloc.0 . 0)
             (apply.gloc.of
               core.optimize\x27;pretty-each
               (core.optimize\x27;pretty-each e2\x60;3031*)))
           (push)
           (apply.gloc.of
             core.optimize\x27;flatten-begin
             (core.optimize\x27;flatten-begin (core.optimize\x27;pretty-each e2\x60;3031*))))
         (push)
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc.1 . 0)
         (if.eq? (ret.iloc 5 . 0))
         (call
           (push.const . lambda)
           (push.iloc.1 . 1)
           (push.iloc.0 . 0)
           (push.subr.gloc.of \x2E;cons* 3 (\x2E;cons* 'lambda e1\x60;3031* e2a\x60;3033*))
           (extend . 1)
           (push.iloc.0 . 0)
           (iloc 6 . 0)
           (if.eq? (ret.iloc 0 . 0))
           (call
             (push.iloc.0 . 0)
             (push.iloc 6 . 0)
             (call
               (apply.gloc.of
                 core.optimize\x27;annotate-closure-hook
                 (core.optimize\x27;annotate-closure-hook)))
             (apply))
           (ret.iloc 0 . 0))
         (push)
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc 6 . 0)
         (if.eq? (ret.iloc 0 . 0))
         (call
           (push.iloc.0 . 0)
           (push.iloc 6 . 0)
           (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
           (apply))
         (ret.iloc 0 . 0))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (3 . 0) (car form\x60;2904*))
         (const . let)
         (ret.eq? (eq? (car form\x60;2904*) 'let)))
       (if.true
         (push.cddr.iloc (3 . 0) (cddr form\x60;2904*))
         (push.cadr.iloc (3 . 0) (cadr form\x60;2904*))
         (extend . 2)
         (iloc.0 . 1)
         (if.null?
           (push.const . begin)
           (call
             (push.iloc.0 . 0)
             (apply.gloc.of
               core.optimize\x27;flatten-begin
               (core.optimize\x27;flatten-begin e2\x60;3041*)))
           (push.cons)
           (extend . 1)
           (push.iloc.0 . 0)
           (iloc 5 . 0)
           (if.eq? (ret.iloc 0 . 0))
           (call
             (push.iloc.0 . 0)
             (push.iloc 5 . 0)
             (call
               (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
             (apply))
           (ret.iloc 0 . 0))
         (call
           (cdr.iloc (0 . 1) (\x2E;cdr e1\x60;3041*))
           (if.not.null?.ret.const . #f)
           (cdr.iloc (0 . 0) (\x2E;cdr e2\x60;3041*))
           (if.not.null?.ret.const . #f)
           (push.iloc.0 . 1)
           (push.subr.gloc.of \x2E;caar 1 (\x2E;caar e1\x60;3041*))
           (car.iloc (0 . 0) (\x2E;car e2\x60;3041*))
           (ret.eq? (\x2E;eq? (\x2E;caar e1\x60;3041*) (\x2E;car e2\x60;3041*))))
         (if.true
           (call
             (push.iloc.0 . 1)
             (push.subr.gloc.of \x2E;cadar 1 (\x2E;cadar e1\x60;3041*))
             (apply.gloc.of
               core.optimize\x27;pretty
               (core.optimize\x27;pretty (\x2E;cadar e1\x60;3041*))))
           (push)
           (extend . 1)
           (push.iloc.0 . 0)
           (iloc 5 . 0)
           (if.eq? (ret.iloc 0 . 0))
           (call
             (push.iloc.0 . 0)
             (push.iloc 5 . 0)
             (call
               (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
             (apply))
           (ret.iloc 0 . 0))
         (call
           (push.gloc.of \x2E;cadr)
           (push.iloc.0 . 1)
           (apply.gloc.of \x2E;map (\x2E;map \x2E;cadr e1\x60;3041*)))
         (push)
         (extend . 1)
         (call
           (push.iloc.0 . 0)
           (apply.gloc.of
             core.optimize\x27;pretty-each
             (core.optimize\x27;pretty-each e1a\x60;3049*)))
         (push)
         (call
           (call
             (push.iloc.1 . 0)
             (apply.gloc.of
               core.optimize\x27;pretty-each
               (core.optimize\x27;pretty-each e2\x60;3041*)))
           (push)
           (apply.gloc.of
             core.optimize\x27;flatten-begin
             (core.optimize\x27;flatten-begin (core.optimize\x27;pretty-each e2\x60;3041*))))
         (push)
         (extend . 2)
         (call
           (push.iloc 2 . 0)
           (iloc.0 . 1)
           (if.not.eq?.ret.const . #f)
           (push.gloc.of \x2E;eq?)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of
             core.lists\x27;for-all
             (core.lists\x27;for-all \x2E;eq? e1a\x60;3049* e1b\x60;3051*)))
         (if.true (ret.iloc 6 . 0))
         (push.const . let)
         (call
           (push.gloc.of \x2E;list)
           (call
             (push.gloc.of \x2E;car)
             (push.iloc 2 . 1)
             (apply.gloc.of \x2E;map (\x2E;map \x2E;car e1\x60;3041*)))
           (push)
           (push.iloc.0 . 0)
           (apply.gloc.of
             \x2E;map
             (\x2E;map \x2E;list (\x2E;map \x2E;car e1\x60;3041*) e1b\x60;3051*)))
         (push)
         (push.iloc.0 . 1)
         (push.subr.gloc.of
           \x2E;cons*
           3
           (\x2E;cons*
             'let
             (\x2E;map \x2E;list (\x2E;map \x2E;car e1\x60;3041*) e1b\x60;3051*)
             e2a\x60;3051*))
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc 7 . 0)
         (if.eq? (ret.iloc 0 . 0))
         (call
           (push.iloc.0 . 0)
           (push.iloc 7 . 0)
           (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
           (apply))
         (ret.iloc 0 . 0))
       (call
         (iloc.0 . 0)
         (if.false.ret)
         (push.car.iloc (3 . 0) (car form\x60;2904*))
         (const . letrec*)
         (ret.eq? (eq? (car form\x60;2904*) 'letrec*)))
       (if.true
         (push.cddr.iloc (3 . 0) (cddr form\x60;2904*))
         (push.cadr.iloc (3 . 0) (cadr form\x60;2904*))
         (extend . 2)
         (iloc.0 . 1)
         (if.null?
           (push.const . begin)
           (call
             (push.iloc.0 . 0)
             (apply.gloc.of
               core.optimize\x27;flatten-begin
               (core.optimize\x27;flatten-begin e2\x60;3056*)))
           (push.cons)
           (extend . 1)
           (push.iloc.0 . 0)
           (iloc 5 . 0)
           (if.eq? (ret.iloc 0 . 0))
           (call
             (push.iloc.0 . 0)
             (push.iloc 5 . 0)
             (call
               (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
             (apply))
           (ret.iloc 0 . 0))
         (call
           (push.gloc.of \x2E;cadr)
           (push.iloc.0 . 1)
           (apply.gloc.of \x2E;map (\x2E;map \x2E;cadr e1\x60;3056*)))
         (push)
         (extend . 1)
         (call
           (push.iloc.0 . 0)
           (apply.gloc.of
             core.optimize\x27;pretty-each
             (core.optimize\x27;pretty-each e1a\x60;3061*)))
         (push)
         (call
           (call
             (push.iloc.1 . 0)
             (apply.gloc.of
               core.optimize\x27;pretty-each
               (core.optimize\x27;pretty-each e2\x60;3056*)))
           (push)
           (apply.gloc.of
             core.optimize\x27;flatten-begin
             (core.optimize\x27;flatten-begin (core.optimize\x27;pretty-each e2\x60;3056*))))
         (push)
         (extend . 2)
         (call
           (push.iloc 2 . 0)
           (iloc.0 . 1)
           (if.not.eq?.ret.const . #f)
           (push.gloc.of \x2E;eq?)
           (push.iloc.1 . 0)
           (push.iloc.0 . 0)
           (apply.gloc.of
             core.lists\x27;for-all
             (core.lists\x27;for-all \x2E;eq? e1a\x60;3061* e1b\x60;3063*)))
         (if.true (ret.iloc 6 . 0))
         (push.const . letrec*)
         (call
           (push.gloc.of \x2E;list)
           (call
             (push.gloc.of \x2E;car)
             (push.iloc 2 . 1)
             (apply.gloc.of \x2E;map (\x2E;map \x2E;car e1\x60;3056*)))
           (push)
           (push.iloc.0 . 0)
           (apply.gloc.of
             \x2E;map
             (\x2E;map \x2E;list (\x2E;map \x2E;car e1\x60;3056*) e1b\x60;3063*)))
         (push)
         (push.iloc.0 . 1)
         (push.subr.gloc.of
           \x2E;cons*
           3
           (\x2E;cons*
             'letrec*
             (\x2E;map \x2E;list (\x2E;map \x2E;car e1\x60;3056*) e1b\x60;3063*)
             e2a\x60;3063*))
         (extend . 1)
         (push.iloc.0 . 0)
         (iloc 7 . 0)
         (if.eq? (ret.iloc 0 . 0))
         (call
           (push.iloc.0 . 0)
           (push.iloc 7 . 0)
           (call (apply.gloc.of core.optimize\x27;annotate-hook (core.optimize\x27;annotate-hook)))
           (apply))
         (ret.iloc 0 . 0))
       (push.const . "coreform-optimize")
       (push.const . "internal inconsistency in ~s")
       (push.gloc.of core.optimize\x27;pretty)
       (push.subr.gloc.of
         \x2E;format
         2
         (\x2E;format "internal inconsistency in ~s" core.optimize\x27;pretty))
       (push.iloc 3 . 0)
       (apply.gloc.of
         \x2E;assertion-violation
         (\x2E;assertion-violation
           "coreform-optimize"
           (\x2E;format "internal inconsistency in ~s" core.optimize\x27;pretty)
           form\x60;2904*)))
     (push.iloc 2 . 0)
     (push.subr.gloc.of \x2E;length 1 "../stdlib/core/optimize.scm" . 1037337)
     (push.gloc.of core.optimize\x27;limit-arguments)
     (subr.gloc.of \x2E;> 2 "../stdlib/core/optimize.scm" . 1037334)
     (if.true (push.iloc 2 . 0) (apply.iloc+ (1 . 0) "../stdlib/core/optimize.scm" . 1038358))
     (push.iloc 2 . 0)
     (apply.gloc.of core.optimize\x27;pretty-each "../stdlib/core/optimize.scm" . 1039382))
   (ret.iloc 1 . 0))
 (set.gloc.of core.optimize\x27;pretty)
 (close
   (1 0 . core.optimize\x27;process-stackable)
   (extend.unbound . 5)
   (push.close
     (2 0 . trace-lineage-each)
     (extend.enclose+
       (1 0 . loop)
       (iloc.0 . 0)
       (if.pair?
         (call
           (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1052707)
           (push.iloc 2 . 1)
           (apply.iloc (3 . 1) "../stdlib/core/optimize.scm" . 1052692))
         (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1053722)
         (apply.iloc+ (1 . 0) "../stdlib/core/optimize.scm" . 1053716))
       (ret.const.unspec))
     (push.iloc.1 . 0)
     (apply.iloc+ (0 . 0) "../stdlib/core/optimize.scm" . 1051661))
   (push.close
     (2 0 . trace-lineage)
     (iloc.0 . 0)
     (if.not.pair?.ret.const . #f)
     (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1058840)
     (extend . 1)
     (push.iloc.0 . 0)
     (const . define)
     (if.eq?
       (push.gloc.of core.optimize\x27;ht-lambda-node)
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caddr 1 "../stdlib/core/optimize.scm" . 1060933)
       (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 1060892)
       (if.true
         (push.iloc.1 . 0)
         (push.subr.gloc.of \x2E;caddr 1 "../stdlib/core/optimize.scm" . 1061942)
         (push.subr.gloc.of \x2E;cddr 1 "../stdlib/core/optimize.scm" . 1061936)
         (push.iloc.1 . 1)
         (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 1061916))
       (push.iloc.1 . 0)
       (push.subr.gloc.of \x2E;caddr 1 "../stdlib/core/optimize.scm" . 1063979)
       (push.iloc.1 . 1)
       (apply.iloc (2 . 1) "../stdlib/core/optimize.scm" . 1063964))
     (push.iloc.0 . 0)
     (const . lambda)
     (if.eq?
       (push.close
         (1 0)
         (push.iloc 3 . 4)
         (push.iloc.0 . 0)
         (push.const . #t)
         (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 1066027))
       (push.iloc.1 . 1)
       (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 1066005))
     (push.iloc.0 . 0)
     (const . let)
     (if.eq?
       (call
         (push.close
           (1 0)
           (push.cadr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1068090)
           (push.iloc 2 . 1)
           (apply.iloc (3 . 1) "../stdlib/core/optimize.scm" . 1068075))
         (push.cadr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 1068110)
         (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 1068053))
       (push.cddr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 1069097)
       (push.iloc.1 . 1)
       (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 1069077))
     (push.iloc.0 . 0)
     (const . letrec*)
     (if.eq?
       (call
         (push.gloc.of \x2E;values)
         (call
           (push.gloc.of \x2E;L986)
           (push.cadr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 1071238)
           (apply.gloc.of \x2E;map "../stdlib/core/optimize.scm" . 1071155))
         (push)
         (apply.gloc.of core.lists\x27;filter "../stdlib/core/optimize.scm" . 1071140))
       (push)
       (extend . 1)
       (call
         (push.close
           (1 0)
           (push.gloc.of core.optimize\x27;ht-lambda-node)
           (push.cadr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1073235)
           (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 1073194)
           (if.true
             (call
               (push.close
                 (1 0)
                 (push.iloc 5 . 4)
                 (push.iloc.0 . 0)
                 (push.const)
                 (push.subr.gloc.of
                   \x2E;core-hashtable-ref
                   3
                   "../stdlib/core/optimize.scm"
                   .
                   1075265)
                 (extend . 1)
                 (push.iloc.0 . 0)
                 (const . #t)
                 (if.eq?.ret.const . #f)
                 (push.iloc 6 . 4)
                 (push.iloc.1 . 0)
                 (push.car.iloc (2 . 0) "../stdlib/core/optimize.scm" . 1077352)
                 (iloc.0 . 0)
                 (push.cons)
                 (ret.subr.gloc.of
                   \x2E;core-hashtable-set!
                   "../stdlib/core/optimize.scm"
                   .
                   1077309))
               (push.iloc 3 . 1)
               (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 1074218))
             (push.iloc.0 . 0)
             (push.subr.gloc.of \x2E;cddadr 1 "../stdlib/core/optimize.scm" . 1079358)
             (push.iloc.1 . 0)
             (push.iloc 3 . 1)
             (push.subr.gloc.of \x2E;append 2 "../stdlib/core/optimize.scm" . 1079369)
             (apply.iloc (4 . 0) "../stdlib/core/optimize.scm" . 1079338))
           (push.cadr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1081401)
           (push.iloc.1 . 0)
           (push.iloc 3 . 1)
           (push.subr.gloc.of \x2E;append 2 "../stdlib/core/optimize.scm" . 1081410)
           (apply.iloc (4 . 1) "../stdlib/core/optimize.scm" . 1081386))
         (push.cadr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 1082401)
         (apply.gloc.of
           \x2E;for-each
           (\x2E;for-each
             (lambda (b\x60;3091*)
               (if (\x2E;core-hashtable-contains?
                     core.optimize\x27;ht-lambda-node
                     (\x2E;cadr b\x60;3091*))
                   (begin
                     (\x2E;for-each
                       (lambda (a\x60;3093*)
                         (let ((lst\x60;3095*
                                 (\x2E;core-hashtable-ref ht-descendant\x60;3070* a\x60;3093* '())))
                           (and (\x2E;not (\x2E;eq? lst\x60;3095* #t))
                                (\x2E;core-hashtable-set!
                                  ht-descendant\x60;3070*
                                  a\x60;3093*
                                  (\x2E;cons (\x2E;car b\x60;3091*) lst\x60;3095*)))))
                       ancestor\x60;3079*)
                     (trace-lineage-each\x60;3070*
                       (\x2E;cddadr b\x60;3091*)
                       (\x2E;append present\x60;3089* ancestor\x60;3079*)))
                   (trace-lineage\x60;3070*
                     (\x2E;cadr b\x60;3091*)
                     (\x2E;append present\x60;3089* ancestor\x60;3079*))))
             (\x2E;cadr form\x60;3079*))))
       (push.cddr.iloc (2 . 0) "../stdlib/core/optimize.scm" . 1083435)
       (push.iloc 2 . 1)
       (apply.iloc (3 . 0) "../stdlib/core/optimize.scm" . 1083415))
     (push.iloc.0 . 0)
     (const . quote)
     (if.eq?.ret.const . #f)
     (push.iloc.1 . 0)
     (push.iloc.1 . 1)
     (apply.iloc (2 . 0) "../stdlib/core/optimize.scm" . 1086485))
   (push.close
     (1 0 . contain-heap-lambda?)
     (push.iloc.1 . 4)
     (push.iloc.0 . 0)
     (push.const . #f)
     (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 1091602)
     (extend . 1)
     (iloc.0 . 0)
     (if.false.ret)
     (push.iloc.0 . 0)
     (const . #t)
     (if.eq?.ret.const . #t)
     (call
       (push.gloc.of \x2E;L943)
       (push.iloc.0 . 0)
       (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 1094688))
     (push)
     (ret.subr.gloc.of \x2E;not "../stdlib/core/optimize.scm" . 1094683))
   (enclose . 3)
   (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 1045528)
   (set.iloc (0 . 3))
   (subr.gloc.of \x2E;make-core-hashtable 0 "../stdlib/core/optimize.scm" . 1046557)
   (set.iloc (0 . 4))
   (call
     (push.iloc.1 . 0)
     (push.const)
     (apply.iloc (0 . 1) "../stdlib/core/optimize.scm" . 1097735))
   (call
     (push.close
       (1 0)
       (cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1099809)
       (if.not.symbol?.ret.const . #f)
       (push.iloc.1 . 3)
       (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1100854)
       (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1100862)
       (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 1100824))
     (push.gloc.of core.optimize\x27;ht-variable-binding)
     (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/optimize.scm" . 1101841)
     (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 1098759))
   (call
     (push.gloc.of \x2E;L984)
     (push.gloc.of core.optimize\x27;ht-variable-binding)
     (push.subr.gloc.of \x2E;core-hashtable->alist 1 "../stdlib/core/optimize.scm" . 1114143)
     (apply.gloc.of core.lists\x27;remp "../stdlib/core/optimize.scm" . 1103897))
   (push)
   (extend . 1)
   (call
     (extend.enclose+
       (1 0 . loop)
       (call
         (push.close
           (1 0)
           (push.gloc.of core.optimize\x27;ht-variable-stackables)
           (push.car.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1118284)
           (subr.gloc.of \x2E;core-hashtable-contains? 2 "../stdlib/core/optimize.scm" . 1118235)
           (if.true.ret)
           (push.gloc.of core.optimize\x27;ht-lambda-node)
           (push.cdr.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1119306)
           (push.const)
           (push.subr.gloc.of \x2E;core-hashtable-ref 3 "../stdlib/core/optimize.scm" . 1119271)
           (extend . 1)
           (call
             (call
               (push.car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 1121348)
               (apply.iloc (5 . 2) "../stdlib/core/optimize.scm" . 1121326))
             (if.true.ret.const . #f)
             (push.close
               (1 0)
               (push.car.iloc (2 . 0) "../stdlib/core/optimize.scm" . 1124413)
               (iloc.0 . 0)
               (if.eq?.ret.const . #t)
               (call
                 (push.iloc.0 . 0)
                 (apply.gloc.of
                   core.optimize\x27;primitive-function?
                   "../stdlib/core/optimize.scm"
                   .
                   1125432))
               (if.true.ret)
               (call
                 (push.iloc.0 . 0)
                 (apply.gloc.of
                   core.optimize\x27;variable-top-level?
                   "../stdlib/core/optimize.scm"
                   .
                   1126456))
               (if.true.ret)
               (push.gloc.of core.optimize\x27;ht-variable-stackables)
               (push.iloc.0 . 0)
               (subr.gloc.of
                 \x2E;core-hashtable-contains?
                 2
                 "../stdlib/core/optimize.scm"
                 .
                 1127480)
               (if.true.ret)
               (call
                 (push.iloc.0 . 0)
                 (apply.gloc.of
                   core.optimize\x27;variable-iloc?
                   "../stdlib/core/optimize.scm"
                   .
                   1128509))
               (if.false.ret)
               (call (push.iloc.0 . 0) (apply.iloc (6 . 2) "../stdlib/core/optimize.scm" . 1129538))
               (push)
               (ret.subr.gloc.of \x2E;not "../stdlib/core/optimize.scm" . 1129533))
             (push.iloc.0 . 0)
             (apply.gloc.of core.lists\x27;for-all "../stdlib/core/optimize.scm" . 1122345))
           (if.true
             (push.gloc.of core.optimize\x27;ht-variable-stackables)
             (push.car.iloc (1 . 0) "../stdlib/core/optimize.scm" . 1133648)
             (push.cdr.iloc (1 . 0) "../stdlib/core/optimize.scm" . 1133656)
             (ret.subr.gloc.of \x2E;core-hashtable-set! "../stdlib/core/optimize.scm" . 1133604))
           (ret.const.unspec))
         (push.iloc 2 . 0)
         (apply.gloc.of
           \x2E;for-each
           (\x2E;for-each
             (lambda (b\x60;3120*)
               (or (\x2E;core-hashtable-contains?
                     core.optimize\x27;ht-variable-stackables
                     (\x2E;car b\x60;3120*))
                   (let ((free\x60;3122*
                           (\x2E;core-hashtable-ref
                             core.optimize\x27;ht-lambda-node
                             (\x2E;cdr b\x60;3120*)
                             '())))
                     (if (and (\x2E;not (contain-heap-lambda?\x60;3070* (\x2E;car b\x60;3120*)))
                              (core.lists\x27;for-all
                                (lambda (x\x60;3124*)
                                  (or (\x2E;eq? (\x2E;car b\x60;3120*) x\x60;3124*)
                                      (core.optimize\x27;primitive-function? x\x60;3124*)
                                      (core.optimize\x27;variable-top-level? x\x60;3124*)
                                      (\x2E;core-hashtable-contains?
                                        core.optimize\x27;ht-variable-stackables
                                        x\x60;3124*)
                                      (and (core.optimize\x27;variable-iloc? x\x60;3124*)
                                           (\x2E;not
                                             (contain-heap-lambda?\x60;3070* x\x60;3124*)))))
                                free\x60;3122*))
                         (\x2E;core-hashtable-set!
                           core.optimize\x27;ht-variable-stackables
                           (\x2E;car b\x60;3120*)
                           (\x2E;cdr b\x60;3120*))
                         (\x2E;unspecified)))))
             candidates\x60;3113*)))
       (push.gloc.of core.optimize\x27;ht-variable-stackables)
       (push.subr.gloc.of \x2E;core-hashtable-size 1 "../stdlib/core/optimize.scm" . 1136662)
       (extend . 1)
       (iloc.1 . 0)
       (=.iloc (0 . 0) "../stdlib/core/optimize.scm" . 1137681)
       (if.true.ret)
       (push.iloc.0 . 0)
       (apply.iloc+ (2 . 0) "../stdlib/core/optimize.scm" . 1137694))
     (push.gloc.of core.optimize\x27;ht-variable-stackables)
     (push.subr.gloc.of \x2E;core-hashtable-size 1 "../stdlib/core/optimize.scm" . 1116186)
     (apply.iloc+ (0 . 0) "../stdlib/core/optimize.scm" . 1117195))
   (push.gloc.of \x2E;L985)
   (call
     (push.gloc.of \x2E;L949)
     (push.iloc.0 . 0)
     (apply.gloc.of core.lists\x27;remp "../stdlib/core/optimize.scm" . 1139739))
   (push)
   (apply.gloc.of \x2E;for-each "../stdlib/core/optimize.scm" . 1141781))
 (set.gloc.of core.optimize\x27;process-stackable)
 (close
   (1 0 . core.optimize\x27;transform)
   (touch.gloc.of loop\x60;3151*)
   (call
     (push.iloc.0 . 0)
     (apply.gloc.of core.optimize\x27;pretty-form "../stdlib/core/optimize.scm" . 1176600))
   (push)
   (push.const . 1)
   (apply.gloc.of loop\x60;3151* "../stdlib/core/optimize.scm" . 1177609))
 (set.gloc.of core.optimize\x27;transform)
 (close
   (1 0 . core.optimize\x27;pretty-form)
   (touch.gloc.of loop\x60;3182*)
   (push.iloc.0 . 0)
   (apply.gloc.of loop\x60;3182* "../stdlib/core/optimize.scm" . 1243145))
 (set.gloc.of core.optimize\x27;pretty-form)
 (call
   (push.gloc.of \x2E;L992)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/optimize.scm" . 1247257))
 (set.gloc.of core.optimize\x27;annotate-hook)
 (call
   (push.gloc.of \x2E;L1006)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/optimize.scm" . 1248289))
 (set.gloc.of core.optimize\x27;annotate-closure-hook)
 (close
   (2 0 . core.optimize\x27;closure-attribute-set!)
   (push.iloc.0 . 0)
   (push.iloc.0 . 0)
   (push.iloc.0 . 1)
   (call
     (apply.gloc.of
       core.optimize\x27;annotate-closure-hook
       "../stdlib/core/optimize.scm"
       .
       1252360))
   (apply))
 (set.gloc.of core.optimize\x27;closure-attribute-set!)
 (close
   (3 0 . core.optimize\x27;optimize)
   (call
     (apply.gloc.of core.optimize\x27;coreform-optimize "../stdlib/core/optimize.scm" . 1256464))
   (push)
   (const . 0)
   (if.eq?
     (push.iloc.0 . 0)
     (apply.gloc.of core.optimize\x27;pretty-form "../stdlib/core/optimize.scm" . 1257483))
   (push.const . #f)
   (push.const . #f)
   (extend . 2)
   (push.close
     (0 0)
     (call (apply.gloc.of core.optimize\x27;annotate-hook "../stdlib/core/optimize.scm" . 1259533))
     (set.iloc (1 . 0) "../stdlib/core/optimize.scm" . 1259533)
     (call
       (apply.gloc.of
         core.optimize\x27;annotate-closure-hook
         "../stdlib/core/optimize.scm"
         .
         1259533))
     (set.iloc (1 . 1) "../stdlib/core/optimize.scm" . 1259533)
     (call
       (push.iloc 2 . 1)
       (apply.gloc.of core.optimize\x27;annotate-hook "../stdlib/core/optimize.scm" . 1259533))
     (push.iloc 2 . 2)
     (apply.gloc.of
       core.optimize\x27;annotate-closure-hook
       "../stdlib/core/optimize.scm"
       .
       1259533))
   (push.close
     (0 0)
     (call
       (push.iloc 2 . 0)
       (apply.gloc.of core.optimize\x27;transform "../stdlib/core/optimize.scm" . 1259545))
     (push)
     (extend . 1)
     (call (apply.gloc.of core.optimize\x27;clear-context "../stdlib/core/optimize.scm" . 1260559))
     (push.iloc.0 . 0)
     (apply.gloc.of core.optimize\x27;pretty-form "../stdlib/core/optimize.scm" . 1261583))
   (push.close
     (0 0)
     (call
       (push.iloc.1 . 0)
       (apply.gloc.of core.optimize\x27;annotate-hook "../stdlib/core/optimize.scm" . 1259533))
     (push.iloc.1 . 1)
     (apply.gloc.of
       core.optimize\x27;annotate-closure-hook
       "../stdlib/core/optimize.scm"
       .
       1259533))
   (apply.gloc.of \x2E;dynamic-wind "../stdlib/core/optimize.scm" . 1259533))
 (set.gloc.of core.optimize\x27;optimize)
 (call
   (push.const . #t)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/optimize.scm" . 1263643))
 (set.gloc.of core.optimize\x27;coreform-pretty)
 (call
   (push.const . #t)
   (push.gloc.of \x2E;L975)
   (apply.gloc.of \x2E;make-parameter "../stdlib/core/optimize.scm" . 577549))
 (set.gloc.of core.optimize\x27;coreform-optimize)
 (call
   (push.const
     (e2 unbound)
     (lambda import . \x2E;lambda)
     (temp unbound)
     (func unbound)
     (diagnostics import . core.optimize\x27;diagnostics)
     (_ import . \x2E;_)
     (let import . \x2E;let)
     (... import . \x2E;...)
     (args unbound)
     (define-syntax import . \x2E;define-syntax)
     (e1 unbound)
     (more unbound)
     (body2 unbound)
     (vars unbound)
     (body unbound)
     (body1 unbound)
     (define-inline-assistant import . core.optimize\x27;define-inline-assistant)
     (define-inline import . core.optimize\x27;define-inline)
     (syntax-rules import . \x2E;syntax-rules))
   (extend . 1)
   (call
     (push.const . syntax)
     (push.const . core.optimize\x27;define-inline-assistant)
     (push.const
       ()
       ("../stdlib/core/optimize.scm" . 16389)
       ((_ func () (args ...) (vars ...) . body)
        (define-syntax func (syntax-rules () ((_ args ...) (let ((vars args) ...) . body))))
        ((body . 0) (vars . 1) (args . 1) (func . 0))
        (let _ syntax-rules define-syntax))
       ((_ func (e1 e2 ...) (args ...) . more)
        (define-inline-assistant func (e2 ...) (temp args ...) . more)
        ((more . 0) (args . 1) (e2 . 1) (e1 . 0) (func . 0))
        (temp define-inline-assistant)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/optimize.scm" . 577549))
   (call
     (push.const . syntax)
     (push.const . core.optimize\x27;define-inline)
     (push.const
       (lambda)
       ("../stdlib/core/optimize.scm" . 26629)
       ((_ func (lambda (vars ...) body1 body2 ...))
        (define-inline-assistant func (vars ...) () (vars ...) body1 body2 ...)
        ((body2 . 1) (body1 . 0) (vars . 1) (func . 0))
        (define-inline-assistant))
       ((_ (func vars ...) body1 body2 ...)
        (define-inline-assistant func (vars ...) () (vars ...) body1 body2 ...)
        ((body2 . 1) (body1 . 0) (vars . 1) (func . 0))
        (define-inline-assistant)))
     (push.iloc.0 . 0)
     (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/optimize.scm" . 577549))
   (push.const . syntax)
   (push.const . core.optimize\x27;diagnostics)
   (push.const () ("../stdlib/core/optimize.scm" . 33822) ((_ _) #f () ()))
   (push.iloc.0 . 0)
   (apply.gloc.of \x2E;set-top-level-macro! "../stdlib/core/optimize.scm" . 577549))
 (push.const . core.optimize)
 (push.const . #f)
 (push.const (coreform-optimize import . core.optimize\x27;coreform-optimize))
 (apply.gloc.of \x2E;intern-scheme-library "../stdlib/core/optimize.scm" . 577549))

((call
   (push.const core intrinsics)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core intrinsics))))
 (push.const . rnrs.base)
 (push.const 6)
 (push.const
   (define import . \x2E;define)
   (define-syntax import . \x2E;define-syntax)
   (quote import . \x2E;quote)
   (lambda import . \x2E;lambda)
   (if import . \x2E;if)
   (set! import . \x2E;set!)
   (cond import . \x2E;cond)
   (case import . \x2E;case)
   (and import . \x2E;and)
   (or import . \x2E;or)
   (let import . \x2E;let)
   (let* import . \x2E;let*)
   (letrec import . \x2E;letrec)
   (letrec* import . \x2E;letrec*)
   (let-values import . \x2E;let-values)
   (let*-values import . \x2E;let*-values)
   (begin import . \x2E;begin)
   (quasiquote import . \x2E;quasiquote)
   (unquote import . \x2E;unquote)
   (unquote-splicing import . \x2E;unquote-splicing)
   (let-syntax import . \x2E;let-syntax)
   (letrec-syntax import . \x2E;letrec-syntax)
   (syntax-rules import . \x2E;syntax-rules)
   (identifier-syntax import . \x2E;identifier-syntax)
   (assert import . \x2E;assert)
   (else import . \x2E;else)
   (=> import . \x2E;=>)
   (... import . \x2E;...)
   (_ import . \x2E;_)
   (eq? import . \x2E;eq?)
   (eqv? import . \x2E;eqv?)
   (equal? import . \x2E;equal?)
   (procedure? import . \x2E;procedure?)
   (number? import . \x2E;number?)
   (complex? import . \x2E;complex?)
   (real? import . \x2E;real?)
   (rational? import . \x2E;rational?)
   (integer? import . \x2E;integer?)
   (real-valued? import . \x2E;real-valued?)
   (rational-valued? import . \x2E;rational-valued?)
   (integer-valued? import . \x2E;integer-valued?)
   (exact? import . \x2E;exact?)
   (inexact? import . \x2E;inexact?)
   (inexact import . \x2E;inexact)
   (exact import . \x2E;exact)
   (= import . \x2E;=)
   (< import . \x2E;<)
   (> import . \x2E;>)
   (<= import . \x2E;<=)
   (>= import . \x2E;>=)
   (zero? import . \x2E;zero?)
   (positive? import . \x2E;positive?)
   (negative? import . \x2E;negative?)
   (odd? import . \x2E;odd?)
   (even? import . \x2E;even?)
   (finite? import . \x2E;finite?)
   (infinite? import . \x2E;infinite?)
   (nan? import . \x2E;nan?)
   (max import . \x2E;max)
   (min import . \x2E;min)
   (+ import . \x2E;+)
   (* import . \x2E;*)
   (- import . \x2E;-)
   (/ import . \x2E;/)
   (abs import . \x2E;abs)
   (div-and-mod import . \x2E;div-and-mod)
   (div import . \x2E;div)
   (mod import . \x2E;mod)
   (div0-and-mod0 import . \x2E;div0-and-mod0)
   (div0 import . \x2E;div0)
   (mod0 import . \x2E;mod0)
   (gcd import . \x2E;gcd)
   (lcm import . \x2E;lcm)
   (numerator import . \x2E;numerator)
   (denominator import . \x2E;denominator)
   (floor import . \x2E;floor)
   (ceiling import . \x2E;ceiling)
   (truncate import . \x2E;truncate)
   (round import . \x2E;round)
   (rationalize import . \x2E;rationalize)
   (exp import . \x2E;exp)
   (log import . \x2E;log)
   (sin import . \x2E;sin)
   (cos import . \x2E;cos)
   (tan import . \x2E;tan)
   (asin import . \x2E;asin)
   (acos import . \x2E;acos)
   (atan import . \x2E;atan)
   (sqrt import . \x2E;sqrt)
   (exact-integer-sqrt import . \x2E;exact-integer-sqrt)
   (expt import . \x2E;expt)
   (make-rectangular import . \x2E;make-rectangular)
   (make-polar import . \x2E;make-polar)
   (real-part import . \x2E;real-part)
   (imag-part import . \x2E;imag-part)
   (magnitude import . \x2E;magnitude)
   (angle import . \x2E;angle)
   (number->string import . \x2E;number->string)
   (string->number import . \x2E;string->number)
   (not import . \x2E;not)
   (boolean? import . \x2E;boolean?)
   (boolean=? import . \x2E;boolean=?)
   (pair? import . \x2E;pair?)
   (cons import . \x2E;cons)
   (car import . \x2E;car)
   (cdr import . \x2E;cdr)
   (caar import . \x2E;caar)
   (cadr import . \x2E;cadr)
   (cdar import . \x2E;cdar)
   (cddr import . \x2E;cddr)
   (caaar import . \x2E;caaar)
   (caadr import . \x2E;caadr)
   (cadar import . \x2E;cadar)
   (caddr import . \x2E;caddr)
   (cdaar import . \x2E;cdaar)
   (cdadr import . \x2E;cdadr)
   (cddar import . \x2E;cddar)
   (cdddr import . \x2E;cdddr)
   (caaaar import . \x2E;caaaar)
   (caaadr import . \x2E;caaadr)
   (caadar import . \x2E;caadar)
   (caaddr import . \x2E;caaddr)
   (cadaar import . \x2E;cadaar)
   (cadadr import . \x2E;cadadr)
   (caddar import . \x2E;caddar)
   (cadddr import . \x2E;cadddr)
   (cdaaar import . \x2E;cdaaar)
   (cdaadr import . \x2E;cdaadr)
   (cdadar import . \x2E;cdadar)
   (cdaddr import . \x2E;cdaddr)
   (cddaar import . \x2E;cddaar)
   (cddadr import . \x2E;cddadr)
   (cdddar import . \x2E;cdddar)
   (cddddr import . \x2E;cddddr)
   (null? import . \x2E;null?)
   (list? import . \x2E;list?)
   (list import . \x2E;list)
   (length import . \x2E;length)
   (append import . \x2E;append)
   (reverse import . \x2E;reverse)
   (list-tail import . \x2E;list-tail)
   (list-ref import . \x2E;list-ref)
   (map import . \x2E;map)
   (for-each import . \x2E;for-each)
   (symbol? import . \x2E;symbol?)
   (symbol->string import . \x2E;symbol->string)
   (string->symbol import . \x2E;string->symbol)
   (symbol=? import . \x2E;symbol=?)
   (char? import . \x2E;char?)
   (char->integer import . \x2E;char->integer)
   (integer->char import . \x2E;integer->char)
   (char=? import . \x2E;char=?)
   (char<? import . \x2E;char<?)
   (char>? import . \x2E;char>?)
   (char<=? import . \x2E;char<=?)
   (char>=? import . \x2E;char>=?)
   (string? import . \x2E;string?)
   (make-string import . \x2E;make-string)
   (string import . \x2E;string)
   (string-length import . \x2E;string-length)
   (string-ref import . \x2E;string-ref)
   (string=? import . \x2E;string=?)
   (string<? import . \x2E;string<?)
   (string>? import . \x2E;string>?)
   (string<=? import . \x2E;string<=?)
   (string>=? import . \x2E;string>=?)
   (substring import . \x2E;substring)
   (string-append import . \x2E;string-append)
   (string->list import . \x2E;string->list)
   (list->string import . \x2E;list->string)
   (string-copy import . \x2E;string-copy)
   (string-for-each import . \x2E;string-for-each)
   (vector? import . \x2E;vector?)
   (make-vector import . \x2E;make-vector)
   (vector import . \x2E;vector)
   (vector-length import . \x2E;vector-length)
   (vector-ref import . \x2E;vector-ref)
   (vector-set! import . \x2E;vector-set!)
   (vector->list import . \x2E;vector->list)
   (list->vector import . \x2E;list->vector)
   (vector-fill! import . \x2E;vector-fill!)
   (vector-map import . \x2E;vector-map)
   (vector-for-each import . \x2E;vector-for-each)
   (error import . \x2E;error)
   (assertion-violation import . \x2E;assertion-violation)
   (apply import . \x2E;apply)
   (call-with-current-continuation import . \x2E;call-with-current-continuation)
   (call/cc import . \x2E;call/cc)
   (values import . \x2E;values)
   (call-with-values import . \x2E;call-with-values)
   (dynamic-wind import . \x2E;dynamic-wind))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.base
     '(6)
     '((define import . \x2E;define)
       (define-syntax import . \x2E;define-syntax)
       (quote import . \x2E;quote)
       (lambda import . \x2E;lambda)
       (if import . \x2E;if)
       (set! import . \x2E;set!)
       (cond import . \x2E;cond)
       (case import . \x2E;case)
       (and import . \x2E;and)
       (or import . \x2E;or)
       (let import . \x2E;let)
       (let* import . \x2E;let*)
       (letrec import . \x2E;letrec)
       (letrec* import . \x2E;letrec*)
       (let-values import . \x2E;let-values)
       (let*-values import . \x2E;let*-values)
       (begin import . \x2E;begin)
       (quasiquote import . \x2E;quasiquote)
       (unquote import . \x2E;unquote)
       (unquote-splicing import . \x2E;unquote-splicing)
       (let-syntax import . \x2E;let-syntax)
       (letrec-syntax import . \x2E;letrec-syntax)
       (syntax-rules import . \x2E;syntax-rules)
       (identifier-syntax import . \x2E;identifier-syntax)
       (assert import . \x2E;assert)
       (else import . \x2E;else)
       (=> import . \x2E;=>)
       (... import . \x2E;...)
       (_ import . \x2E;_)
       (eq? import . \x2E;eq?)
       (eqv? import . \x2E;eqv?)
       (equal? import . \x2E;equal?)
       (procedure? import . \x2E;procedure?)
       (number? import . \x2E;number?)
       (complex? import . \x2E;complex?)
       (real? import . \x2E;real?)
       (rational? import . \x2E;rational?)
       (integer? import . \x2E;integer?)
       (real-valued? import . \x2E;real-valued?)
       (rational-valued? import . \x2E;rational-valued?)
       (integer-valued? import . \x2E;integer-valued?)
       (exact? import . \x2E;exact?)
       (inexact? import . \x2E;inexact?)
       (inexact import . \x2E;inexact)
       (exact import . \x2E;exact)
       (= import . \x2E;=)
       (< import . \x2E;<)
       (> import . \x2E;>)
       (<= import . \x2E;<=)
       (>= import . \x2E;>=)
       (zero? import . \x2E;zero?)
       (positive? import . \x2E;positive?)
       (negative? import . \x2E;negative?)
       (odd? import . \x2E;odd?)
       (even? import . \x2E;even?)
       (finite? import . \x2E;finite?)
       (infinite? import . \x2E;infinite?)
       (nan? import . \x2E;nan?)
       (max import . \x2E;max)
       (min import . \x2E;min)
       (+ import . \x2E;+)
       (* import . \x2E;*)
       (- import . \x2E;-)
       (/ import . \x2E;/)
       (abs import . \x2E;abs)
       (div-and-mod import . \x2E;div-and-mod)
       (div import . \x2E;div)
       (mod import . \x2E;mod)
       (div0-and-mod0 import . \x2E;div0-and-mod0)
       (div0 import . \x2E;div0)
       (mod0 import . \x2E;mod0)
       (gcd import . \x2E;gcd)
       (lcm import . \x2E;lcm)
       (numerator import . \x2E;numerator)
       (denominator import . \x2E;denominator)
       (floor import . \x2E;floor)
       (ceiling import . \x2E;ceiling)
       (truncate import . \x2E;truncate)
       (round import . \x2E;round)
       (rationalize import . \x2E;rationalize)
       (exp import . \x2E;exp)
       (log import . \x2E;log)
       (sin import . \x2E;sin)
       (cos import . \x2E;cos)
       (tan import . \x2E;tan)
       (asin import . \x2E;asin)
       (acos import . \x2E;acos)
       (atan import . \x2E;atan)
       (sqrt import . \x2E;sqrt)
       (exact-integer-sqrt import . \x2E;exact-integer-sqrt)
       (expt import . \x2E;expt)
       (make-rectangular import . \x2E;make-rectangular)
       (make-polar import . \x2E;make-polar)
       (real-part import . \x2E;real-part)
       (imag-part import . \x2E;imag-part)
       (magnitude import . \x2E;magnitude)
       (angle import . \x2E;angle)
       (number->string import . \x2E;number->string)
       (string->number import . \x2E;string->number)
       (not import . \x2E;not)
       (boolean? import . \x2E;boolean?)
       (boolean=? import . \x2E;boolean=?)
       (pair? import . \x2E;pair?)
       (cons import . \x2E;cons)
       (car import . \x2E;car)
       (cdr import . \x2E;cdr)
       (caar import . \x2E;caar)
       (cadr import . \x2E;cadr)
       (cdar import . \x2E;cdar)
       (cddr import . \x2E;cddr)
       (caaar import . \x2E;caaar)
       (caadr import . \x2E;caadr)
       (cadar import . \x2E;cadar)
       (caddr import . \x2E;caddr)
       (cdaar import . \x2E;cdaar)
       (cdadr import . \x2E;cdadr)
       (cddar import . \x2E;cddar)
       (cdddr import . \x2E;cdddr)
       (caaaar import . \x2E;caaaar)
       (caaadr import . \x2E;caaadr)
       (caadar import . \x2E;caadar)
       (caaddr import . \x2E;caaddr)
       (cadaar import . \x2E;cadaar)
       (cadadr import . \x2E;cadadr)
       (caddar import . \x2E;caddar)
       (cadddr import . \x2E;cadddr)
       (cdaaar import . \x2E;cdaaar)
       (cdaadr import . \x2E;cdaadr)
       (cdadar import . \x2E;cdadar)
       (cdaddr import . \x2E;cdaddr)
       (cddaar import . \x2E;cddaar)
       (cddadr import . \x2E;cddadr)
       (cdddar import . \x2E;cdddar)
       (cddddr import . \x2E;cddddr)
       (null? import . \x2E;null?)
       (list? import . \x2E;list?)
       (list import . \x2E;list)
       (length import . \x2E;length)
       (append import . \x2E;append)
       (reverse import . \x2E;reverse)
       (list-tail import . \x2E;list-tail)
       (list-ref import . \x2E;list-ref)
       (map import . \x2E;map)
       (for-each import . \x2E;for-each)
       (symbol? import . \x2E;symbol?)
       (symbol->string import . \x2E;symbol->string)
       (string->symbol import . \x2E;string->symbol)
       (symbol=? import . \x2E;symbol=?)
       (char? import . \x2E;char?)
       (char->integer import . \x2E;char->integer)
       (integer->char import . \x2E;integer->char)
       (char=? import . \x2E;char=?)
       (char<? import . \x2E;char<?)
       (char>? import . \x2E;char>?)
       (char<=? import . \x2E;char<=?)
       (char>=? import . \x2E;char>=?)
       (string? import . \x2E;string?)
       (make-string import . \x2E;make-string)
       (string import . \x2E;string)
       (string-length import . \x2E;string-length)
       (string-ref import . \x2E;string-ref)
       (string=? import . \x2E;string=?)
       (string<? import . \x2E;string<?)
       (string>? import . \x2E;string>?)
       (string<=? import . \x2E;string<=?)
       (string>=? import . \x2E;string>=?)
       (substring import . \x2E;substring)
       (string-append import . \x2E;string-append)
       (string->list import . \x2E;string->list)
       (list->string import . \x2E;list->string)
       (string-copy import . \x2E;string-copy)
       (string-for-each import . \x2E;string-for-each)
       (vector? import . \x2E;vector?)
       (make-vector import . \x2E;make-vector)
       (vector import . \x2E;vector)
       (vector-length import . \x2E;vector-length)
       (vector-ref import . \x2E;vector-ref)
       (vector-set! import . \x2E;vector-set!)
       (vector->list import . \x2E;vector->list)
       (list->vector import . \x2E;list->vector)
       (vector-fill! import . \x2E;vector-fill!)
       (vector-map import . \x2E;vector-map)
       (vector-for-each import . \x2E;vector-for-each)
       (error import . \x2E;error)
       (assertion-violation import . \x2E;assertion-violation)
       (apply import . \x2E;apply)
       (call-with-current-continuation import . \x2E;call-with-current-continuation)
       (call/cc import . \x2E;call/cc)
       (values import . \x2E;values)
       (call-with-values import . \x2E;call-with-values)
       (dynamic-wind import . \x2E;dynamic-wind)))))

((call
   (push.const core unicode)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core unicode))))
 (push.const . rnrs.unicode)
 (push.const 6)
 (push.const
   (char-upcase import . core.unicode\x27;char-upcase)
   (char-downcase import . core.unicode\x27;char-downcase)
   (char-titlecase import . core.unicode\x27;char-titlecase)
   (char-foldcase import . core.unicode\x27;char-foldcase)
   (char-ci=? import . core.unicode\x27;char-ci=?)
   (char-ci<? import . core.unicode\x27;char-ci<?)
   (char-ci>? import . core.unicode\x27;char-ci>?)
   (char-ci<=? import . core.unicode\x27;char-ci<=?)
   (char-ci>=? import . core.unicode\x27;char-ci>=?)
   (char-alphabetic? import . core.unicode\x27;char-alphabetic?)
   (char-numeric? import . core.unicode\x27;char-numeric?)
   (char-whitespace? import . \x2E;char-whitespace?)
   (char-upper-case? import . core.unicode\x27;char-upper-case?)
   (char-lower-case? import . core.unicode\x27;char-lower-case?)
   (char-title-case? import . core.unicode\x27;char-title-case?)
   (char-general-category import . core.unicode\x27;char-general-category)
   (string-upcase import . core.unicode\x27;string-upcase)
   (string-downcase import . core.unicode\x27;string-downcase)
   (string-titlecase import . core.unicode\x27;string-titlecase)
   (string-foldcase import . core.unicode\x27;string-foldcase)
   (string-ci=? import . core.unicode\x27;string-ci=?)
   (string-ci<? import . core.unicode\x27;string-ci<?)
   (string-ci>? import . core.unicode\x27;string-ci>?)
   (string-ci<=? import . core.unicode\x27;string-ci<=?)
   (string-ci>=? import . core.unicode\x27;string-ci>=?)
   (string-normalize-nfd import . core.unicode\x27;string-normalize-nfd)
   (string-normalize-nfkd import . core.unicode\x27;string-normalize-nfkd)
   (string-normalize-nfc import . core.unicode\x27;string-normalize-nfc)
   (string-normalize-nfkc import . core.unicode\x27;string-normalize-nfkc))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.unicode
     '(6)
     '((char-upcase import . core.unicode\x27;char-upcase)
       (char-downcase import . core.unicode\x27;char-downcase)
       (char-titlecase import . core.unicode\x27;char-titlecase)
       (char-foldcase import . core.unicode\x27;char-foldcase)
       (char-ci=? import . core.unicode\x27;char-ci=?)
       (char-ci<? import . core.unicode\x27;char-ci<?)
       (char-ci>? import . core.unicode\x27;char-ci>?)
       (char-ci<=? import . core.unicode\x27;char-ci<=?)
       (char-ci>=? import . core.unicode\x27;char-ci>=?)
       (char-alphabetic? import . core.unicode\x27;char-alphabetic?)
       (char-numeric? import . core.unicode\x27;char-numeric?)
       (char-whitespace? import . \x2E;char-whitespace?)
       (char-upper-case? import . core.unicode\x27;char-upper-case?)
       (char-lower-case? import . core.unicode\x27;char-lower-case?)
       (char-title-case? import . core.unicode\x27;char-title-case?)
       (char-general-category import . core.unicode\x27;char-general-category)
       (string-upcase import . core.unicode\x27;string-upcase)
       (string-downcase import . core.unicode\x27;string-downcase)
       (string-titlecase import . core.unicode\x27;string-titlecase)
       (string-foldcase import . core.unicode\x27;string-foldcase)
       (string-ci=? import . core.unicode\x27;string-ci=?)
       (string-ci<? import . core.unicode\x27;string-ci<?)
       (string-ci>? import . core.unicode\x27;string-ci>?)
       (string-ci<=? import . core.unicode\x27;string-ci<=?)
       (string-ci>=? import . core.unicode\x27;string-ci>=?)
       (string-normalize-nfd import . core.unicode\x27;string-normalize-nfd)
       (string-normalize-nfkd import . core.unicode\x27;string-normalize-nfkd)
       (string-normalize-nfc import . core.unicode\x27;string-normalize-nfc)
       (string-normalize-nfkc import . core.unicode\x27;string-normalize-nfkc)))))

((call
   (push.const core bytevector-transcoders)
   (apply.gloc.of
     \x2E;require-scheme-library
     (\x2E;require-scheme-library '(core bytevector-transcoders))))
 (call
   (push.const core bytevectors)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core bytevectors))))
 (push.const . rnrs.bytevectors)
 (push.const 6)
 (push.const
   (endianness import . core.bytevectors\x27;endianness)
   (native-endianness import . \x2E;native-endianness)
   (bytevector? import . \x2E;bytevector?)
   (make-bytevector import . \x2E;make-bytevector)
   (bytevector-length import . \x2E;bytevector-length)
   (bytevector=? import . \x2E;bytevector=?)
   (bytevector-fill! import . \x2E;bytevector-fill!)
   (bytevector-copy! import . \x2E;bytevector-copy!)
   (bytevector-copy import . \x2E;bytevector-copy)
   (bytevector-u8-ref import . \x2E;bytevector-u8-ref)
   (bytevector-s8-ref import . \x2E;bytevector-s8-ref)
   (bytevector-u8-set! import . \x2E;bytevector-u8-set!)
   (bytevector-s8-set! import . \x2E;bytevector-s8-set!)
   (bytevector->u8-list import . \x2E;bytevector->u8-list)
   (u8-list->bytevector import . \x2E;u8-list->bytevector)
   (bytevector-u16-ref import . \x2E;bytevector-u16-ref)
   (bytevector-s16-ref import . \x2E;bytevector-s16-ref)
   (bytevector-u16-native-ref import . \x2E;bytevector-u16-native-ref)
   (bytevector-s16-native-ref import . \x2E;bytevector-s16-native-ref)
   (bytevector-u16-set! import . \x2E;bytevector-u16-set!)
   (bytevector-s16-set! import . \x2E;bytevector-s16-set!)
   (bytevector-u16-native-set! import . \x2E;bytevector-u16-native-set!)
   (bytevector-s16-native-set! import . \x2E;bytevector-s16-native-set!)
   (bytevector-u32-ref import . \x2E;bytevector-u32-ref)
   (bytevector-s32-ref import . \x2E;bytevector-s32-ref)
   (bytevector-u32-native-ref import . \x2E;bytevector-u32-native-ref)
   (bytevector-s32-native-ref import . \x2E;bytevector-s32-native-ref)
   (bytevector-u32-set! import . \x2E;bytevector-u32-set!)
   (bytevector-s32-set! import . \x2E;bytevector-s32-set!)
   (bytevector-u32-native-set! import . \x2E;bytevector-u32-native-set!)
   (bytevector-s32-native-set! import . \x2E;bytevector-s32-native-set!)
   (bytevector-u64-ref import . \x2E;bytevector-u64-ref)
   (bytevector-s64-ref import . \x2E;bytevector-s64-ref)
   (bytevector-u64-native-ref import . \x2E;bytevector-u64-native-ref)
   (bytevector-s64-native-ref import . \x2E;bytevector-s64-native-ref)
   (bytevector-u64-set! import . \x2E;bytevector-u64-set!)
   (bytevector-s64-set! import . \x2E;bytevector-s64-set!)
   (bytevector-u64-native-set! import . \x2E;bytevector-u64-native-set!)
   (bytevector-s64-native-set! import . \x2E;bytevector-s64-native-set!)
   (bytevector-ieee-single-ref import . \x2E;bytevector-ieee-single-ref)
   (bytevector-ieee-single-native-ref import . \x2E;bytevector-ieee-single-native-ref)
   (bytevector-ieee-single-set! import . \x2E;bytevector-ieee-single-set!)
   (bytevector-ieee-single-native-set! import . \x2E;bytevector-ieee-single-native-set!)
   (bytevector-ieee-double-ref import . \x2E;bytevector-ieee-double-ref)
   (bytevector-ieee-double-native-ref import . \x2E;bytevector-ieee-double-native-ref)
   (bytevector-ieee-double-set! import . \x2E;bytevector-ieee-double-set!)
   (bytevector-ieee-double-native-set! import . \x2E;bytevector-ieee-double-native-set!)
   (bytevector-uint-ref import . core.bytevectors\x27;bytevector-uint-ref)
   (bytevector-sint-ref import . core.bytevectors\x27;bytevector-sint-ref)
   (bytevector-uint-set! import . core.bytevectors\x27;bytevector-uint-set!)
   (bytevector-sint-set! import . core.bytevectors\x27;bytevector-sint-set!)
   (bytevector->uint-list import . core.bytevectors\x27;bytevector->uint-list)
   (bytevector->sint-list import . core.bytevectors\x27;bytevector->sint-list)
   (uint-list->bytevector import . core.bytevectors\x27;uint-list->bytevector)
   (sint-list->bytevector import . core.bytevectors\x27;sint-list->bytevector)
   (string->utf8 import . \x2E;string->utf8)
   (utf8->string import . \x2E;utf8->string)
   (string->utf16 import . core.bytevector-transcoders\x27;string->utf16)
   (utf16->string import . core.bytevector-transcoders\x27;utf16->string)
   (string->utf32 import . core.bytevector-transcoders\x27;string->utf32)
   (utf32->string import . core.bytevector-transcoders\x27;utf32->string))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.bytevectors
     '(6)
     '((endianness import . core.bytevectors\x27;endianness)
       (native-endianness import . \x2E;native-endianness)
       (bytevector? import . \x2E;bytevector?)
       (make-bytevector import . \x2E;make-bytevector)
       (bytevector-length import . \x2E;bytevector-length)
       (bytevector=? import . \x2E;bytevector=?)
       (bytevector-fill! import . \x2E;bytevector-fill!)
       (bytevector-copy! import . \x2E;bytevector-copy!)
       (bytevector-copy import . \x2E;bytevector-copy)
       (bytevector-u8-ref import . \x2E;bytevector-u8-ref)
       (bytevector-s8-ref import . \x2E;bytevector-s8-ref)
       (bytevector-u8-set! import . \x2E;bytevector-u8-set!)
       (bytevector-s8-set! import . \x2E;bytevector-s8-set!)
       (bytevector->u8-list import . \x2E;bytevector->u8-list)
       (u8-list->bytevector import . \x2E;u8-list->bytevector)
       (bytevector-u16-ref import . \x2E;bytevector-u16-ref)
       (bytevector-s16-ref import . \x2E;bytevector-s16-ref)
       (bytevector-u16-native-ref import . \x2E;bytevector-u16-native-ref)
       (bytevector-s16-native-ref import . \x2E;bytevector-s16-native-ref)
       (bytevector-u16-set! import . \x2E;bytevector-u16-set!)
       (bytevector-s16-set! import . \x2E;bytevector-s16-set!)
       (bytevector-u16-native-set! import . \x2E;bytevector-u16-native-set!)
       (bytevector-s16-native-set! import . \x2E;bytevector-s16-native-set!)
       (bytevector-u32-ref import . \x2E;bytevector-u32-ref)
       (bytevector-s32-ref import . \x2E;bytevector-s32-ref)
       (bytevector-u32-native-ref import . \x2E;bytevector-u32-native-ref)
       (bytevector-s32-native-ref import . \x2E;bytevector-s32-native-ref)
       (bytevector-u32-set! import . \x2E;bytevector-u32-set!)
       (bytevector-s32-set! import . \x2E;bytevector-s32-set!)
       (bytevector-u32-native-set! import . \x2E;bytevector-u32-native-set!)
       (bytevector-s32-native-set! import . \x2E;bytevector-s32-native-set!)
       (bytevector-u64-ref import . \x2E;bytevector-u64-ref)
       (bytevector-s64-ref import . \x2E;bytevector-s64-ref)
       (bytevector-u64-native-ref import . \x2E;bytevector-u64-native-ref)
       (bytevector-s64-native-ref import . \x2E;bytevector-s64-native-ref)
       (bytevector-u64-set! import . \x2E;bytevector-u64-set!)
       (bytevector-s64-set! import . \x2E;bytevector-s64-set!)
       (bytevector-u64-native-set! import . \x2E;bytevector-u64-native-set!)
       (bytevector-s64-native-set! import . \x2E;bytevector-s64-native-set!)
       (bytevector-ieee-single-ref import . \x2E;bytevector-ieee-single-ref)
       (bytevector-ieee-single-native-ref import . \x2E;bytevector-ieee-single-native-ref)
       (bytevector-ieee-single-set! import . \x2E;bytevector-ieee-single-set!)
       (bytevector-ieee-single-native-set! import . \x2E;bytevector-ieee-single-native-set!)
       (bytevector-ieee-double-ref import . \x2E;bytevector-ieee-double-ref)
       (bytevector-ieee-double-native-ref import . \x2E;bytevector-ieee-double-native-ref)
       (bytevector-ieee-double-set! import . \x2E;bytevector-ieee-double-set!)
       (bytevector-ieee-double-native-set! import . \x2E;bytevector-ieee-double-native-set!)
       (bytevector-uint-ref import . core.bytevectors\x27;bytevector-uint-ref)
       (bytevector-sint-ref import . core.bytevectors\x27;bytevector-sint-ref)
       (bytevector-uint-set! import . core.bytevectors\x27;bytevector-uint-set!)
       (bytevector-sint-set! import . core.bytevectors\x27;bytevector-sint-set!)
       (bytevector->uint-list import . core.bytevectors\x27;bytevector->uint-list)
       (bytevector->sint-list import . core.bytevectors\x27;bytevector->sint-list)
       (uint-list->bytevector import . core.bytevectors\x27;uint-list->bytevector)
       (sint-list->bytevector import . core.bytevectors\x27;sint-list->bytevector)
       (string->utf8 import . \x2E;string->utf8)
       (utf8->string import . \x2E;utf8->string)
       (string->utf16 import . core.bytevector-transcoders\x27;string->utf16)
       (utf16->string import . core.bytevector-transcoders\x27;utf16->string)
       (string->utf32 import . core.bytevector-transcoders\x27;string->utf32)
       (utf32->string import . core.bytevector-transcoders\x27;utf32->string)))))

((call
   (push.const core lists)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core lists))))
 (push.const . rnrs.lists)
 (push.const 6)
 (push.const
   (find import . core.lists\x27;find)
   (for-all import . core.lists\x27;for-all)
   (exists import . core.lists\x27;exists)
   (filter import . core.lists\x27;filter)
   (partition import . core.lists\x27;partition)
   (fold-left import . core.lists\x27;fold-left)
   (fold-right import . core.lists\x27;fold-right)
   (remp import . core.lists\x27;remp)
   (remove import . core.lists\x27;remove)
   (remv import . core.lists\x27;remv)
   (remq import . core.lists\x27;remq)
   (memp import . core.lists\x27;memp)
   (member import . \x2E;member)
   (memv import . \x2E;memv)
   (memq import . \x2E;memq)
   (assp import . core.lists\x27;assp)
   (assoc import . \x2E;assoc)
   (assv import . \x2E;assv)
   (assq import . \x2E;assq)
   (cons* import . \x2E;cons*))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.lists
     '(6)
     '((find import . core.lists\x27;find)
       (for-all import . core.lists\x27;for-all)
       (exists import . core.lists\x27;exists)
       (filter import . core.lists\x27;filter)
       (partition import . core.lists\x27;partition)
       (fold-left import . core.lists\x27;fold-left)
       (fold-right import . core.lists\x27;fold-right)
       (remp import . core.lists\x27;remp)
       (remove import . core.lists\x27;remove)
       (remv import . core.lists\x27;remv)
       (remq import . core.lists\x27;remq)
       (memp import . core.lists\x27;memp)
       (member import . \x2E;member)
       (memv import . \x2E;memv)
       (memq import . \x2E;memq)
       (assp import . core.lists\x27;assp)
       (assoc import . \x2E;assoc)
       (assv import . \x2E;assv)
       (assq import . \x2E;assq)
       (cons* import . \x2E;cons*)))))

((call
   (push.const core sorting)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core sorting))))
 (push.const . rnrs.sorting)
 (push.const 6)
 (push.const
   (list-sort import . core.sorting\x27;list-sort)
   (vector-sort import . core.sorting\x27;vector-sort)
   (vector-sort! import . core.sorting\x27;vector-sort!))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.sorting
     '(6)
     '((list-sort import . core.sorting\x27;list-sort)
       (vector-sort import . core.sorting\x27;vector-sort)
       (vector-sort! import . core.sorting\x27;vector-sort!)))))

((call
   (push.const core control)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core control))))
 (push.const . rnrs.control)
 (push.const 6)
 (push.const
   (when import . core.control\x27;when)
   (unless import . core.control\x27;unless)
   (do import . \x2E;do)
   (case-lambda import . core.control\x27;case-lambda))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.control
     '(6)
     '((when import . core.control\x27;when)
       (unless import . core.control\x27;unless)
       (do import . \x2E;do)
       (case-lambda import . core.control\x27;case-lambda)))))

((call
   (push.const core records)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core records))))
 (push.const . rnrs.records.syntactic)
 (push.const 6)
 (push.const
   (define-record-type import . core.records\x27;define-record-type)
   (record-type-descriptor import . core.records\x27;record-type-descriptor)
   (record-constructor-descriptor import . core.records\x27;record-constructor-descriptor)
   (fields import . core.records\x27;fields)
   (mutable import . core.records\x27;mutable)
   (immutable import . core.records\x27;immutable)
   (parent import . core.records\x27;parent)
   (protocol import . core.records\x27;protocol)
   (sealed import . core.records\x27;sealed)
   (opaque import . core.records\x27;opaque)
   (nongenerative import . core.records\x27;nongenerative)
   (parent-rtd import . core.records\x27;parent-rtd))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.records.syntactic
     '(6)
     '((define-record-type import . core.records\x27;define-record-type)
       (record-type-descriptor import . core.records\x27;record-type-descriptor)
       (record-constructor-descriptor import . core.records\x27;record-constructor-descriptor)
       (fields import . core.records\x27;fields)
       (mutable import . core.records\x27;mutable)
       (immutable import . core.records\x27;immutable)
       (parent import . core.records\x27;parent)
       (protocol import . core.records\x27;protocol)
       (sealed import . core.records\x27;sealed)
       (opaque import . core.records\x27;opaque)
       (nongenerative import . core.records\x27;nongenerative)
       (parent-rtd import . core.records\x27;parent-rtd)))))

((call
   (push.const core records)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core records))))
 (push.const . rnrs.records.procedural)
 (push.const 6)
 (push.const
   (make-record-type-descriptor import . \x2E;make-record-type-descriptor)
   (record-type-descriptor? import . \x2E;record-type-descriptor?)
   (make-record-constructor-descriptor import . \x2E;make-record-constructor-descriptor)
   (record-constructor import . \x2E;record-constructor)
   (record-predicate import . \x2E;record-predicate)
   (record-accessor import . \x2E;record-accessor)
   (record-mutator import . \x2E;record-mutator))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.records.procedural
     '(6)
     '((make-record-type-descriptor import . \x2E;make-record-type-descriptor)
       (record-type-descriptor? import . \x2E;record-type-descriptor?)
       (make-record-constructor-descriptor import . \x2E;make-record-constructor-descriptor)
       (record-constructor import . \x2E;record-constructor)
       (record-predicate import . \x2E;record-predicate)
       (record-accessor import . \x2E;record-accessor)
       (record-mutator import . \x2E;record-mutator)))))

((call
   (push.const core records)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core records))))
 (push.const . rnrs.records.inspection)
 (push.const 6)
 (push.const
   (record? import . \x2E;record?)
   (record-rtd import . \x2E;record-rtd)
   (record-type-name import . \x2E;record-type-name)
   (record-type-parent import . \x2E;record-type-parent)
   (record-type-uid import . \x2E;record-type-uid)
   (record-type-generative? import . \x2E;record-type-generative?)
   (record-type-sealed? import . \x2E;record-type-sealed?)
   (record-type-opaque? import . \x2E;record-type-opaque?)
   (record-type-field-names import . \x2E;record-type-field-names)
   (record-field-mutable? import . \x2E;record-field-mutable?))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.records.inspection
     '(6)
     '((record? import . \x2E;record?)
       (record-rtd import . \x2E;record-rtd)
       (record-type-name import . \x2E;record-type-name)
       (record-type-parent import . \x2E;record-type-parent)
       (record-type-uid import . \x2E;record-type-uid)
       (record-type-generative? import . \x2E;record-type-generative?)
       (record-type-sealed? import . \x2E;record-type-sealed?)
       (record-type-opaque? import . \x2E;record-type-opaque?)
       (record-type-field-names import . \x2E;record-type-field-names)
       (record-field-mutable? import . \x2E;record-field-mutable?)))))

((call
   (push.const core exceptions)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core exceptions))))
 (push.const . rnrs.exceptions)
 (push.const 6)
 (push.const
   (with-exception-handler import . \x2E;with-exception-handler)
   (guard import . core.exceptions\x27;guard)
   (raise import . \x2E;raise)
   (raise-continuable import . \x2E;raise-continuable)
   (else import . \x2E;else)
   (=> import . \x2E;=>))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.exceptions
     '(6)
     '((with-exception-handler import . \x2E;with-exception-handler)
       (guard import . core.exceptions\x27;guard)
       (raise import . \x2E;raise)
       (raise-continuable import . \x2E;raise-continuable)
       (else import . \x2E;else)
       (=> import . \x2E;=>)))))

((call
   (push.const core conditions)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core conditions))))
 (push.const . rnrs.conditions)
 (push.const 6)
 (push.const
   (&condition import . \x2E;&condition)
   (condition import . \x2E;condition)
   (simple-conditions import . \x2E;simple-conditions)
   (condition? import . \x2E;condition?)
   (condition-predicate import . \x2E;condition-predicate)
   (condition-accessor import . \x2E;condition-accessor)
   (define-condition-type import . core.conditions\x27;define-condition-type)
   (&message import . \x2E;&message)
   (make-message-condition import . \x2E;make-message-condition)
   (message-condition? import . \x2E;message-condition?)
   (condition-message import . \x2E;condition-message)
   (&warning import . \x2E;&warning)
   (make-warning import . \x2E;make-warning)
   (warning? import . \x2E;warning?)
   (&serious import . \x2E;&serious)
   (make-serious-condition import . \x2E;make-serious-condition)
   (serious-condition? import . \x2E;serious-condition?)
   (&error import . \x2E;&error)
   (make-error import . \x2E;make-error)
   (error? import . \x2E;error?)
   (&violation import . \x2E;&violation)
   (make-violation import . \x2E;make-violation)
   (violation? import . \x2E;violation?)
   (&assertion import . \x2E;&assertion)
   (make-assertion-violation import . \x2E;make-assertion-violation)
   (assertion-violation? import . \x2E;assertion-violation?)
   (&irritants import . \x2E;&irritants)
   (make-irritants-condition import . \x2E;make-irritants-condition)
   (irritants-condition? import . \x2E;irritants-condition?)
   (&who import . \x2E;&who)
   (make-who-condition import . \x2E;make-who-condition)
   (who-condition? import . \x2E;who-condition?)
   (condition-who import . \x2E;condition-who)
   (condition-irritants import . \x2E;condition-irritants)
   (&non-continuable import . \x2E;&non-continuable)
   (make-non-continuable-violation import . \x2E;make-non-continuable-violation)
   (non-continuable-violation? import . \x2E;non-continuable-violation?)
   (&implementation-restriction import . \x2E;&implementation-restriction)
   (make-implementation-restriction-violation
     import
     .
     \x2E;make-implementation-restriction-violation)
   (implementation-restriction-violation? import . \x2E;implementation-restriction-violation?)
   (&lexical import . \x2E;&lexical)
   (make-lexical-violation import . \x2E;make-lexical-violation)
   (lexical-violation? import . \x2E;lexical-violation?)
   (&syntax import . \x2E;&syntax)
   (make-syntax-violation import . \x2E;make-syntax-violation)
   (syntax-violation? import . \x2E;syntax-violation?)
   (syntax-violation-form import . \x2E;syntax-violation-form)
   (syntax-violation-subform import . \x2E;syntax-violation-subform)
   (&undefined import . \x2E;&undefined)
   (make-undefined-violation import . \x2E;make-undefined-violation)
   (undefined-violation? import . \x2E;undefined-violation?))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.conditions
     '(6)
     '((&condition import . \x2E;&condition)
       (condition import . \x2E;condition)
       (simple-conditions import . \x2E;simple-conditions)
       (condition? import . \x2E;condition?)
       (condition-predicate import . \x2E;condition-predicate)
       (condition-accessor import . \x2E;condition-accessor)
       (define-condition-type import . core.conditions\x27;define-condition-type)
       (&message import . \x2E;&message)
       (make-message-condition import . \x2E;make-message-condition)
       (message-condition? import . \x2E;message-condition?)
       (condition-message import . \x2E;condition-message)
       (&warning import . \x2E;&warning)
       (make-warning import . \x2E;make-warning)
       (warning? import . \x2E;warning?)
       (&serious import . \x2E;&serious)
       (make-serious-condition import . \x2E;make-serious-condition)
       (serious-condition? import . \x2E;serious-condition?)
       (&error import . \x2E;&error)
       (make-error import . \x2E;make-error)
       (error? import . \x2E;error?)
       (&violation import . \x2E;&violation)
       (make-violation import . \x2E;make-violation)
       (violation? import . \x2E;violation?)
       (&assertion import . \x2E;&assertion)
       (make-assertion-violation import . \x2E;make-assertion-violation)
       (assertion-violation? import . \x2E;assertion-violation?)
       (&irritants import . \x2E;&irritants)
       (make-irritants-condition import . \x2E;make-irritants-condition)
       (irritants-condition? import . \x2E;irritants-condition?)
       (&who import . \x2E;&who)
       (make-who-condition import . \x2E;make-who-condition)
       (who-condition? import . \x2E;who-condition?)
       (condition-who import . \x2E;condition-who)
       (condition-irritants import . \x2E;condition-irritants)
       (&non-continuable import . \x2E;&non-continuable)
       (make-non-continuable-violation import . \x2E;make-non-continuable-violation)
       (non-continuable-violation? import . \x2E;non-continuable-violation?)
       (&implementation-restriction import . \x2E;&implementation-restriction)
       (make-implementation-restriction-violation
         import
         .
         \x2E;make-implementation-restriction-violation)
       (implementation-restriction-violation? import . \x2E;implementation-restriction-violation?)
       (&lexical import . \x2E;&lexical)
       (make-lexical-violation import . \x2E;make-lexical-violation)
       (lexical-violation? import . \x2E;lexical-violation?)
       (&syntax import . \x2E;&syntax)
       (make-syntax-violation import . \x2E;make-syntax-violation)
       (syntax-violation? import . \x2E;syntax-violation?)
       (syntax-violation-form import . \x2E;syntax-violation-form)
       (syntax-violation-subform import . \x2E;syntax-violation-subform)
       (&undefined import . \x2E;&undefined)
       (make-undefined-violation import . \x2E;make-undefined-violation)
       (undefined-violation? import . \x2E;undefined-violation?)))))

((call
   (push.const core io)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core io))))
 (push.const . rnrs.io.ports)
 (push.const 6)
 (push.const
   (&i/o import . \x2E;&i/o)
   (make-i/o-error import . \x2E;make-i/o-error)
   (i/o-error? import . \x2E;i/o-error?)
   (&i/o-read import . \x2E;&i/o-read)
   (make-i/o-read-error import . \x2E;make-i/o-read-error)
   (i/o-read-error? import . \x2E;i/o-read-error?)
   (&i/o-write import . \x2E;&i/o-write)
   (make-i/o-write-error import . \x2E;make-i/o-write-error)
   (i/o-write-error? import . \x2E;i/o-write-error?)
   (&i/o-invalid-position import . \x2E;&i/o-invalid-position)
   (make-i/o-invalid-position-error import . \x2E;make-i/o-invalid-position-error)
   (i/o-invalid-position-error? import . \x2E;i/o-invalid-position-error?)
   (i/o-error-position import . \x2E;i/o-error-position)
   (&i/o-filename import . \x2E;&i/o-filename)
   (make-i/o-filename-error import . \x2E;make-i/o-filename-error)
   (i/o-filename-error? import . \x2E;i/o-filename-error?)
   (i/o-error-filename import . \x2E;i/o-error-filename)
   (&i/o-file-protection import . \x2E;&i/o-file-protection)
   (make-i/o-file-protection-error import . \x2E;make-i/o-file-protection-error)
   (i/o-file-protection-error? import . \x2E;i/o-file-protection-error?)
   (&i/o-file-is-read-only import . \x2E;&i/o-file-is-read-only)
   (make-i/o-file-is-read-only-error import . \x2E;make-i/o-file-is-read-only-error)
   (i/o-file-is-read-only-error? import . \x2E;i/o-file-is-read-only-error?)
   (&i/o-file-already-exists import . \x2E;&i/o-file-already-exists)
   (make-i/o-file-already-exists-error import . \x2E;make-i/o-file-already-exists-error)
   (i/o-file-already-exists-error? import . \x2E;i/o-file-already-exists-error?)
   (&i/o-file-does-not-exist import . \x2E;&i/o-file-does-not-exist)
   (make-i/o-file-does-not-exist-error import . \x2E;make-i/o-file-does-not-exist-error)
   (i/o-file-does-not-exist-error? import . \x2E;i/o-file-does-not-exist-error?)
   (&i/o-port import . \x2E;&i/o-port)
   (make-i/o-port-error import . \x2E;make-i/o-port-error)
   (i/o-port-error? import . \x2E;i/o-port-error?)
   (i/o-error-port import . \x2E;i/o-error-port)
   (&i/o-decoding import . \x2E;&i/o-decoding)
   (make-i/o-decoding-error import . \x2E;make-i/o-decoding-error)
   (i/o-decoding-error? import . \x2E;i/o-decoding-error?)
   (&i/o-encoding import . \x2E;&i/o-encoding)
   (make-i/o-encoding-error import . \x2E;make-i/o-encoding-error)
   (i/o-encoding-error? import . \x2E;i/o-encoding-error?)
   (i/o-encoding-error-char import . \x2E;i/o-encoding-error-char)
   (file-options import . core.io\x27;file-options)
   (buffer-mode import . core.io\x27;buffer-mode)
   (buffer-mode? import . core.io\x27;buffer-mode?)
   (utf-8-codec import . core.io\x27;utf-8-codec)
   (utf-16-codec import . core.io\x27;utf-16-codec)
   (latin-1-codec import . core.io\x27;latin-1-codec)
   (eol-style import . core.io\x27;eol-style)
   (error-handling-mode import . core.io\x27;error-handling-mode)
   (make-transcoder import . core.io\x27;make-transcoder)
   (transcoder-codec import . core.io\x27;transcoder-codec)
   (transcoder-eol-style import . core.io\x27;transcoder-eol-style)
   (transcoder-error-handling-mode import . core.io\x27;transcoder-error-handling-mode)
   (native-transcoder import . core.io\x27;native-transcoder)
   (native-eol-style import . core.io\x27;native-eol-style)
   (bytevector->string import . core.io\x27;bytevector->string)
   (string->bytevector import . core.io\x27;string->bytevector)
   (eof-object import . \x2E;eof-object)
   (eof-object? import . \x2E;eof-object?)
   (port? import . \x2E;port?)
   (port-transcoder import . core.io\x27;port-transcoder)
   (textual-port? import . core.io\x27;textual-port?)
   (binary-port? import . core.io\x27;binary-port?)
   (transcoded-port import . core.io\x27;transcoded-port)
   (port-has-port-position? import . \x2E;port-has-port-position?)
   (port-position import . \x2E;port-position)
   (port-has-set-port-position!? import . \x2E;port-has-set-port-position!?)
   (set-port-position! import . \x2E;set-port-position!)
   (close-port import . \x2E;close-port)
   (call-with-port import . \x2E;call-with-port)
   (input-port? import . \x2E;input-port?)
   (port-eof? import . \x2E;port-eof?)
   (open-file-input-port import . core.io\x27;open-file-input-port)
   (open-bytevector-input-port import . core.io\x27;open-bytevector-input-port)
   (open-string-input-port import . core.io\x27;open-string-input-port)
   (standard-input-port import . \x2E;standard-input-port)
   (current-input-port import . \x2E;current-input-port)
   (get-u8 import . \x2E;get-u8)
   (lookahead-u8 import . \x2E;lookahead-u8)
   (get-bytevector-n import . \x2E;get-bytevector-n)
   (get-bytevector-n! import . \x2E;get-bytevector-n!)
   (get-bytevector-some import . \x2E;get-bytevector-some)
   (get-bytevector-all import . \x2E;get-bytevector-all)
   (get-char import . \x2E;get-char)
   (lookahead-char import . \x2E;lookahead-char)
   (get-string-n import . \x2E;get-string-n)
   (get-string-n! import . \x2E;get-string-n!)
   (get-string-all import . \x2E;get-string-all)
   (get-line import . \x2E;get-line)
   (get-datum import . \x2E;get-datum)
   (output-port? import . \x2E;output-port?)
   (flush-output-port import . \x2E;flush-output-port)
   (output-port-buffer-mode import . \x2E;output-port-buffer-mode)
   (open-file-output-port import . core.io\x27;open-file-output-port)
   (open-bytevector-output-port import . core.io\x27;open-bytevector-output-port)
   (call-with-bytevector-output-port import . core.io\x27;call-with-bytevector-output-port)
   (open-string-output-port import . core.io\x27;open-string-output-port)
   (call-with-string-output-port import . core.io\x27;call-with-string-output-port)
   (standard-output-port import . \x2E;standard-output-port)
   (standard-error-port import . \x2E;standard-error-port)
   (current-output-port import . \x2E;current-output-port)
   (current-error-port import . \x2E;current-error-port)
   (put-u8 import . \x2E;put-u8)
   (put-bytevector import . \x2E;put-bytevector)
   (put-char import . \x2E;put-char)
   (put-string import . \x2E;put-string)
   (put-datum import . \x2E;put-datum)
   (open-file-input/output-port import . core.io\x27;open-file-input/output-port)
   (make-custom-binary-input-port import . core.io\x27;make-custom-binary-input-port)
   (make-custom-textual-input-port import . core.io\x27;make-custom-textual-input-port)
   (make-custom-binary-output-port import . core.io\x27;make-custom-binary-output-port)
   (make-custom-textual-output-port import . core.io\x27;make-custom-textual-output-port)
   (make-custom-binary-input/output-port import . core.io\x27;make-custom-binary-input/output-port)
   (make-custom-textual-input/output-port
     import
     .
     core.io\x27;make-custom-textual-input/output-port))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.io.ports
     '(6)
     '((&i/o import . \x2E;&i/o)
       (make-i/o-error import . \x2E;make-i/o-error)
       (i/o-error? import . \x2E;i/o-error?)
       (&i/o-read import . \x2E;&i/o-read)
       (make-i/o-read-error import . \x2E;make-i/o-read-error)
       (i/o-read-error? import . \x2E;i/o-read-error?)
       (&i/o-write import . \x2E;&i/o-write)
       (make-i/o-write-error import . \x2E;make-i/o-write-error)
       (i/o-write-error? import . \x2E;i/o-write-error?)
       (&i/o-invalid-position import . \x2E;&i/o-invalid-position)
       (make-i/o-invalid-position-error import . \x2E;make-i/o-invalid-position-error)
       (i/o-invalid-position-error? import . \x2E;i/o-invalid-position-error?)
       (i/o-error-position import . \x2E;i/o-error-position)
       (&i/o-filename import . \x2E;&i/o-filename)
       (make-i/o-filename-error import . \x2E;make-i/o-filename-error)
       (i/o-filename-error? import . \x2E;i/o-filename-error?)
       (i/o-error-filename import . \x2E;i/o-error-filename)
       (&i/o-file-protection import . \x2E;&i/o-file-protection)
       (make-i/o-file-protection-error import . \x2E;make-i/o-file-protection-error)
       (i/o-file-protection-error? import . \x2E;i/o-file-protection-error?)
       (&i/o-file-is-read-only import . \x2E;&i/o-file-is-read-only)
       (make-i/o-file-is-read-only-error import . \x2E;make-i/o-file-is-read-only-error)
       (i/o-file-is-read-only-error? import . \x2E;i/o-file-is-read-only-error?)
       (&i/o-file-already-exists import . \x2E;&i/o-file-already-exists)
       (make-i/o-file-already-exists-error import . \x2E;make-i/o-file-already-exists-error)
       (i/o-file-already-exists-error? import . \x2E;i/o-file-already-exists-error?)
       (&i/o-file-does-not-exist import . \x2E;&i/o-file-does-not-exist)
       (make-i/o-file-does-not-exist-error import . \x2E;make-i/o-file-does-not-exist-error)
       (i/o-file-does-not-exist-error? import . \x2E;i/o-file-does-not-exist-error?)
       (&i/o-port import . \x2E;&i/o-port)
       (make-i/o-port-error import . \x2E;make-i/o-port-error)
       (i/o-port-error? import . \x2E;i/o-port-error?)
       (i/o-error-port import . \x2E;i/o-error-port)
       (&i/o-decoding import . \x2E;&i/o-decoding)
       (make-i/o-decoding-error import . \x2E;make-i/o-decoding-error)
       (i/o-decoding-error? import . \x2E;i/o-decoding-error?)
       (&i/o-encoding import . \x2E;&i/o-encoding)
       (make-i/o-encoding-error import . \x2E;make-i/o-encoding-error)
       (i/o-encoding-error? import . \x2E;i/o-encoding-error?)
       (i/o-encoding-error-char import . \x2E;i/o-encoding-error-char)
       (file-options import . core.io\x27;file-options)
       (buffer-mode import . core.io\x27;buffer-mode)
       (buffer-mode? import . core.io\x27;buffer-mode?)
       (utf-8-codec import . core.io\x27;utf-8-codec)
       (utf-16-codec import . core.io\x27;utf-16-codec)
       (latin-1-codec import . core.io\x27;latin-1-codec)
       (eol-style import . core.io\x27;eol-style)
       (error-handling-mode import . core.io\x27;error-handling-mode)
       (make-transcoder import . core.io\x27;make-transcoder)
       (transcoder-codec import . core.io\x27;transcoder-codec)
       (transcoder-eol-style import . core.io\x27;transcoder-eol-style)
       (transcoder-error-handling-mode import . core.io\x27;transcoder-error-handling-mode)
       (native-transcoder import . core.io\x27;native-transcoder)
       (native-eol-style import . core.io\x27;native-eol-style)
       (bytevector->string import . core.io\x27;bytevector->string)
       (string->bytevector import . core.io\x27;string->bytevector)
       (eof-object import . \x2E;eof-object)
       (eof-object? import . \x2E;eof-object?)
       (port? import . \x2E;port?)
       (port-transcoder import . core.io\x27;port-transcoder)
       (textual-port? import . core.io\x27;textual-port?)
       (binary-port? import . core.io\x27;binary-port?)
       (transcoded-port import . core.io\x27;transcoded-port)
       (port-has-port-position? import . \x2E;port-has-port-position?)
       (port-position import . \x2E;port-position)
       (port-has-set-port-position!? import . \x2E;port-has-set-port-position!?)
       (set-port-position! import . \x2E;set-port-position!)
       (close-port import . \x2E;close-port)
       (call-with-port import . \x2E;call-with-port)
       (input-port? import . \x2E;input-port?)
       (port-eof? import . \x2E;port-eof?)
       (open-file-input-port import . core.io\x27;open-file-input-port)
       (open-bytevector-input-port import . core.io\x27;open-bytevector-input-port)
       (open-string-input-port import . core.io\x27;open-string-input-port)
       (standard-input-port import . \x2E;standard-input-port)
       (current-input-port import . \x2E;current-input-port)
       (get-u8 import . \x2E;get-u8)
       (lookahead-u8 import . \x2E;lookahead-u8)
       (get-bytevector-n import . \x2E;get-bytevector-n)
       (get-bytevector-n! import . \x2E;get-bytevector-n!)
       (get-bytevector-some import . \x2E;get-bytevector-some)
       (get-bytevector-all import . \x2E;get-bytevector-all)
       (get-char import . \x2E;get-char)
       (lookahead-char import . \x2E;lookahead-char)
       (get-string-n import . \x2E;get-string-n)
       (get-string-n! import . \x2E;get-string-n!)
       (get-string-all import . \x2E;get-string-all)
       (get-line import . \x2E;get-line)
       (get-datum import . \x2E;get-datum)
       (output-port? import . \x2E;output-port?)
       (flush-output-port import . \x2E;flush-output-port)
       (output-port-buffer-mode import . \x2E;output-port-buffer-mode)
       (open-file-output-port import . core.io\x27;open-file-output-port)
       (open-bytevector-output-port import . core.io\x27;open-bytevector-output-port)
       (call-with-bytevector-output-port import . core.io\x27;call-with-bytevector-output-port)
       (open-string-output-port import . core.io\x27;open-string-output-port)
       (call-with-string-output-port import . core.io\x27;call-with-string-output-port)
       (standard-output-port import . \x2E;standard-output-port)
       (standard-error-port import . \x2E;standard-error-port)
       (current-output-port import . \x2E;current-output-port)
       (current-error-port import . \x2E;current-error-port)
       (put-u8 import . \x2E;put-u8)
       (put-bytevector import . \x2E;put-bytevector)
       (put-char import . \x2E;put-char)
       (put-string import . \x2E;put-string)
       (put-datum import . \x2E;put-datum)
       (open-file-input/output-port import . core.io\x27;open-file-input/output-port)
       (make-custom-binary-input-port import . core.io\x27;make-custom-binary-input-port)
       (make-custom-textual-input-port import . core.io\x27;make-custom-textual-input-port)
       (make-custom-binary-output-port import . core.io\x27;make-custom-binary-output-port)
       (make-custom-textual-output-port import . core.io\x27;make-custom-textual-output-port)
       (make-custom-binary-input/output-port
         import
         .
         core.io\x27;make-custom-binary-input/output-port)
       (make-custom-textual-input/output-port
         import
         .
         core.io\x27;make-custom-textual-input/output-port)))))

((call
   (push.const core io)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core io))))
 (push.const . rnrs.io.simple)
 (push.const 6)
 (push.const
   (&i/o import . \x2E;&i/o)
   (make-i/o-error import . \x2E;make-i/o-error)
   (i/o-error? import . \x2E;i/o-error?)
   (&i/o-read import . \x2E;&i/o-read)
   (make-i/o-read-error import . \x2E;make-i/o-read-error)
   (i/o-read-error? import . \x2E;i/o-read-error?)
   (&i/o-write import . \x2E;&i/o-write)
   (make-i/o-write-error import . \x2E;make-i/o-write-error)
   (i/o-write-error? import . \x2E;i/o-write-error?)
   (&i/o-invalid-position import . \x2E;&i/o-invalid-position)
   (make-i/o-invalid-position-error import . \x2E;make-i/o-invalid-position-error)
   (i/o-invalid-position-error? import . \x2E;i/o-invalid-position-error?)
   (i/o-error-position import . \x2E;i/o-error-position)
   (&i/o-filename import . \x2E;&i/o-filename)
   (make-i/o-filename-error import . \x2E;make-i/o-filename-error)
   (i/o-filename-error? import . \x2E;i/o-filename-error?)
   (i/o-error-filename import . \x2E;i/o-error-filename)
   (&i/o-file-protection import . \x2E;&i/o-file-protection)
   (make-i/o-file-protection-error import . \x2E;make-i/o-file-protection-error)
   (i/o-file-protection-error? import . \x2E;i/o-file-protection-error?)
   (&i/o-file-is-read-only import . \x2E;&i/o-file-is-read-only)
   (make-i/o-file-is-read-only-error import . \x2E;make-i/o-file-is-read-only-error)
   (i/o-file-is-read-only-error? import . \x2E;i/o-file-is-read-only-error?)
   (&i/o-file-already-exists import . \x2E;&i/o-file-already-exists)
   (make-i/o-file-already-exists-error import . \x2E;make-i/o-file-already-exists-error)
   (i/o-file-already-exists-error? import . \x2E;i/o-file-already-exists-error?)
   (&i/o-file-does-not-exist import . \x2E;&i/o-file-does-not-exist)
   (make-i/o-file-does-not-exist-error import . \x2E;make-i/o-file-does-not-exist-error)
   (i/o-file-does-not-exist-error? import . \x2E;i/o-file-does-not-exist-error?)
   (&i/o-port import . \x2E;&i/o-port)
   (make-i/o-port-error import . \x2E;make-i/o-port-error)
   (i/o-port-error? import . \x2E;i/o-port-error?)
   (i/o-error-port import . \x2E;i/o-error-port)
   (&i/o-decoding import . \x2E;&i/o-decoding)
   (make-i/o-decoding-error import . \x2E;make-i/o-decoding-error)
   (i/o-decoding-error? import . \x2E;i/o-decoding-error?)
   (&i/o-encoding import . \x2E;&i/o-encoding)
   (make-i/o-encoding-error import . \x2E;make-i/o-encoding-error)
   (i/o-encoding-error? import . \x2E;i/o-encoding-error?)
   (i/o-encoding-error-char import . \x2E;i/o-encoding-error-char)
   (current-input-port import . \x2E;current-input-port)
   (current-output-port import . \x2E;current-output-port)
   (current-error-port import . \x2E;current-error-port)
   (eof-object import . \x2E;eof-object)
   (eof-object? import . \x2E;eof-object?)
   (input-port? import . \x2E;input-port?)
   (output-port? import . \x2E;output-port?)
   (call-with-input-file import . core.io\x27;call-with-input-file)
   (call-with-output-file import . core.io\x27;call-with-output-file)
   (with-input-from-file import . core.io\x27;with-input-from-file)
   (with-output-to-file import . core.io\x27;with-output-to-file)
   (open-input-file import . core.io\x27;open-input-file)
   (open-output-file import . core.io\x27;open-output-file)
   (close-input-port import . core.io\x27;close-input-port)
   (close-output-port import . core.io\x27;close-output-port)
   (read-char import . \x2E;read-char)
   (peek-char import . \x2E;peek-char)
   (read import . \x2E;read)
   (write-char import . \x2E;write-char)
   (newline import . \x2E;newline)
   (display import . \x2E;display)
   (write import . \x2E;write))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.io.simple
     '(6)
     '((&i/o import . \x2E;&i/o)
       (make-i/o-error import . \x2E;make-i/o-error)
       (i/o-error? import . \x2E;i/o-error?)
       (&i/o-read import . \x2E;&i/o-read)
       (make-i/o-read-error import . \x2E;make-i/o-read-error)
       (i/o-read-error? import . \x2E;i/o-read-error?)
       (&i/o-write import . \x2E;&i/o-write)
       (make-i/o-write-error import . \x2E;make-i/o-write-error)
       (i/o-write-error? import . \x2E;i/o-write-error?)
       (&i/o-invalid-position import . \x2E;&i/o-invalid-position)
       (make-i/o-invalid-position-error import . \x2E;make-i/o-invalid-position-error)
       (i/o-invalid-position-error? import . \x2E;i/o-invalid-position-error?)
       (i/o-error-position import . \x2E;i/o-error-position)
       (&i/o-filename import . \x2E;&i/o-filename)
       (make-i/o-filename-error import . \x2E;make-i/o-filename-error)
       (i/o-filename-error? import . \x2E;i/o-filename-error?)
       (i/o-error-filename import . \x2E;i/o-error-filename)
       (&i/o-file-protection import . \x2E;&i/o-file-protection)
       (make-i/o-file-protection-error import . \x2E;make-i/o-file-protection-error)
       (i/o-file-protection-error? import . \x2E;i/o-file-protection-error?)
       (&i/o-file-is-read-only import . \x2E;&i/o-file-is-read-only)
       (make-i/o-file-is-read-only-error import . \x2E;make-i/o-file-is-read-only-error)
       (i/o-file-is-read-only-error? import . \x2E;i/o-file-is-read-only-error?)
       (&i/o-file-already-exists import . \x2E;&i/o-file-already-exists)
       (make-i/o-file-already-exists-error import . \x2E;make-i/o-file-already-exists-error)
       (i/o-file-already-exists-error? import . \x2E;i/o-file-already-exists-error?)
       (&i/o-file-does-not-exist import . \x2E;&i/o-file-does-not-exist)
       (make-i/o-file-does-not-exist-error import . \x2E;make-i/o-file-does-not-exist-error)
       (i/o-file-does-not-exist-error? import . \x2E;i/o-file-does-not-exist-error?)
       (&i/o-port import . \x2E;&i/o-port)
       (make-i/o-port-error import . \x2E;make-i/o-port-error)
       (i/o-port-error? import . \x2E;i/o-port-error?)
       (i/o-error-port import . \x2E;i/o-error-port)
       (&i/o-decoding import . \x2E;&i/o-decoding)
       (make-i/o-decoding-error import . \x2E;make-i/o-decoding-error)
       (i/o-decoding-error? import . \x2E;i/o-decoding-error?)
       (&i/o-encoding import . \x2E;&i/o-encoding)
       (make-i/o-encoding-error import . \x2E;make-i/o-encoding-error)
       (i/o-encoding-error? import . \x2E;i/o-encoding-error?)
       (i/o-encoding-error-char import . \x2E;i/o-encoding-error-char)
       (current-input-port import . \x2E;current-input-port)
       (current-output-port import . \x2E;current-output-port)
       (current-error-port import . \x2E;current-error-port)
       (eof-object import . \x2E;eof-object)
       (eof-object? import . \x2E;eof-object?)
       (input-port? import . \x2E;input-port?)
       (output-port? import . \x2E;output-port?)
       (call-with-input-file import . core.io\x27;call-with-input-file)
       (call-with-output-file import . core.io\x27;call-with-output-file)
       (with-input-from-file import . core.io\x27;with-input-from-file)
       (with-output-to-file import . core.io\x27;with-output-to-file)
       (open-input-file import . core.io\x27;open-input-file)
       (open-output-file import . core.io\x27;open-output-file)
       (close-input-port import . core.io\x27;close-input-port)
       (close-output-port import . core.io\x27;close-output-port)
       (read-char import . \x2E;read-char)
       (peek-char import . \x2E;peek-char)
       (read import . \x2E;read)
       (write-char import . \x2E;write-char)
       (newline import . \x2E;newline)
       (display import . \x2E;display)
       (write import . \x2E;write)))))

((call
   (push.const core files)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core files))))
 (push.const . rnrs.files)
 (push.const 6)
 (push.const (file-exists? import . \x2E;file-exists?) (delete-file import . \x2E;delete-file))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.files
     '(6)
     '((file-exists? import . \x2E;file-exists?) (delete-file import . \x2E;delete-file)))))

((call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core primitives))))
 (push.const . rnrs.programs)
 (push.const 6)
 (push.const (command-line import . \x2E;command-line) (exit import . \x2E;exit))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.programs
     '(6)
     '((command-line import . \x2E;command-line) (exit import . \x2E;exit)))))

((call
   (push.const core arithmetic)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core arithmetic))))
 (push.const . rnrs.arithmetic.fixnums)
 (push.const 6)
 (push.const
   (fixnum? import . \x2E;fixnum?)
   (fixnum-width import . \x2E;fixnum-width)
   (least-fixnum import . \x2E;least-fixnum)
   (greatest-fixnum import . \x2E;greatest-fixnum)
   (fx=? import . \x2E;fx=?)
   (fx<? import . \x2E;fx<?)
   (fx>? import . \x2E;fx>?)
   (fx<=? import . \x2E;fx<=?)
   (fx>=? import . \x2E;fx>=?)
   (fxzero? import . \x2E;fxzero?)
   (fxpositive? import . \x2E;fxpositive?)
   (fxnegative? import . \x2E;fxnegative?)
   (fxodd? import . \x2E;fxodd?)
   (fxeven? import . \x2E;fxeven?)
   (fxmax import . \x2E;fxmax)
   (fxmin import . \x2E;fxmin)
   (fx+ import . \x2E;fx+)
   (fx* import . \x2E;fx*)
   (fx- import . \x2E;fx-)
   (fxdiv import . \x2E;fxdiv)
   (fxmod import . core.arithmetic\x27;fxmod)
   (fxdiv-and-mod import . core.arithmetic\x27;fxdiv-and-mod)
   (fxdiv0 import . \x2E;fxdiv0)
   (fxmod0 import . core.arithmetic\x27;fxmod0)
   (fxdiv0-and-mod0 import . core.arithmetic\x27;fxdiv0-and-mod0)
   (fx+/carry import . core.arithmetic\x27;fx+/carry)
   (fx-/carry import . core.arithmetic\x27;fx-/carry)
   (fx*/carry import . core.arithmetic\x27;fx*/carry)
   (fxnot import . \x2E;fxnot)
   (fxand import . \x2E;fxand)
   (fxior import . \x2E;fxior)
   (fxxor import . \x2E;fxxor)
   (fxif import . \x2E;fxif)
   (fxbit-count import . \x2E;fxbit-count)
   (fxlength import . \x2E;fxlength)
   (fxfirst-bit-set import . \x2E;fxfirst-bit-set)
   (fxbit-set? import . \x2E;fxbit-set?)
   (fxcopy-bit import . \x2E;fxcopy-bit)
   (fxbit-field import . \x2E;fxbit-field)
   (fxcopy-bit-field import . \x2E;fxcopy-bit-field)
   (fxarithmetic-shift import . \x2E;fxarithmetic-shift)
   (fxarithmetic-shift-left import . \x2E;fxarithmetic-shift-left)
   (fxarithmetic-shift-right import . \x2E;fxarithmetic-shift-right)
   (fxrotate-bit-field import . core.arithmetic\x27;fxrotate-bit-field)
   (fxreverse-bit-field import . core.arithmetic\x27;fxreverse-bit-field))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.arithmetic.fixnums
     '(6)
     '((fixnum? import . \x2E;fixnum?)
       (fixnum-width import . \x2E;fixnum-width)
       (least-fixnum import . \x2E;least-fixnum)
       (greatest-fixnum import . \x2E;greatest-fixnum)
       (fx=? import . \x2E;fx=?)
       (fx<? import . \x2E;fx<?)
       (fx>? import . \x2E;fx>?)
       (fx<=? import . \x2E;fx<=?)
       (fx>=? import . \x2E;fx>=?)
       (fxzero? import . \x2E;fxzero?)
       (fxpositive? import . \x2E;fxpositive?)
       (fxnegative? import . \x2E;fxnegative?)
       (fxodd? import . \x2E;fxodd?)
       (fxeven? import . \x2E;fxeven?)
       (fxmax import . \x2E;fxmax)
       (fxmin import . \x2E;fxmin)
       (fx+ import . \x2E;fx+)
       (fx* import . \x2E;fx*)
       (fx- import . \x2E;fx-)
       (fxdiv import . \x2E;fxdiv)
       (fxmod import . core.arithmetic\x27;fxmod)
       (fxdiv-and-mod import . core.arithmetic\x27;fxdiv-and-mod)
       (fxdiv0 import . \x2E;fxdiv0)
       (fxmod0 import . core.arithmetic\x27;fxmod0)
       (fxdiv0-and-mod0 import . core.arithmetic\x27;fxdiv0-and-mod0)
       (fx+/carry import . core.arithmetic\x27;fx+/carry)
       (fx-/carry import . core.arithmetic\x27;fx-/carry)
       (fx*/carry import . core.arithmetic\x27;fx*/carry)
       (fxnot import . \x2E;fxnot)
       (fxand import . \x2E;fxand)
       (fxior import . \x2E;fxior)
       (fxxor import . \x2E;fxxor)
       (fxif import . \x2E;fxif)
       (fxbit-count import . \x2E;fxbit-count)
       (fxlength import . \x2E;fxlength)
       (fxfirst-bit-set import . \x2E;fxfirst-bit-set)
       (fxbit-set? import . \x2E;fxbit-set?)
       (fxcopy-bit import . \x2E;fxcopy-bit)
       (fxbit-field import . \x2E;fxbit-field)
       (fxcopy-bit-field import . \x2E;fxcopy-bit-field)
       (fxarithmetic-shift import . \x2E;fxarithmetic-shift)
       (fxarithmetic-shift-left import . \x2E;fxarithmetic-shift-left)
       (fxarithmetic-shift-right import . \x2E;fxarithmetic-shift-right)
       (fxrotate-bit-field import . core.arithmetic\x27;fxrotate-bit-field)
       (fxreverse-bit-field import . core.arithmetic\x27;fxreverse-bit-field)))))

((call
   (push.const core arithmetic)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core arithmetic))))
 (push.const . rnrs.arithmetic.flonums)
 (push.const 6)
 (push.const
   (flonum? import . \x2E;flonum?)
   (real->flonum import . \x2E;real->flonum)
   (fl=? import . \x2E;fl=?)
   (fl<? import . \x2E;fl<?)
   (fl>? import . \x2E;fl>?)
   (fl<=? import . \x2E;fl<=?)
   (fl>=? import . \x2E;fl>=?)
   (flinteger? import . \x2E;flinteger?)
   (flzero? import . \x2E;flzero?)
   (flpositive? import . \x2E;flpositive?)
   (flnegative? import . \x2E;flnegative?)
   (flodd? import . \x2E;flodd?)
   (fleven? import . \x2E;fleven?)
   (flfinite? import . \x2E;flfinite?)
   (flinfinite? import . \x2E;flinfinite?)
   (flnan? import . \x2E;flnan?)
   (flmax import . \x2E;flmax)
   (flmin import . \x2E;flmin)
   (fl+ import . \x2E;fl+)
   (fl* import . \x2E;fl*)
   (fl- import . \x2E;fl-)
   (fl/ import . \x2E;fl/)
   (fldiv-and-mod import . core.arithmetic\x27;fldiv-and-mod)
   (fldiv import . \x2E;fldiv)
   (flmod import . core.arithmetic\x27;flmod)
   (fldiv0-and-mod0 import . core.arithmetic\x27;fldiv0-and-mod0)
   (fldiv0 import . \x2E;fldiv0)
   (flmod0 import . core.arithmetic\x27;flmod0)
   (flnumerator import . \x2E;flnumerator)
   (fldenominator import . \x2E;fldenominator)
   (flfloor import . \x2E;flfloor)
   (flceiling import . \x2E;flceiling)
   (fltruncate import . \x2E;fltruncate)
   (flround import . \x2E;flround)
   (flexp import . \x2E;flexp)
   (flexpt import . \x2E;flexpt)
   (fllog import . \x2E;fllog)
   (flsin import . \x2E;flsin)
   (flcos import . \x2E;flcos)
   (fltan import . \x2E;fltan)
   (flasin import . \x2E;flasin)
   (flacos import . \x2E;flacos)
   (flatan import . \x2E;flatan)
   (flabs import . \x2E;flabs)
   (flsqrt import . \x2E;flsqrt)
   (fixnum->flonum import . \x2E;fixnum->flonum)
   (&no-infinities import . \x2E;&no-infinities)
   (make-no-infinities-violation import . \x2E;make-no-infinities-violation)
   (no-infinities-violation? import . \x2E;no-infinities-violation?)
   (&no-nans import . \x2E;&no-nans)
   (make-no-nans-violation import . \x2E;make-no-nans-violation)
   (no-nans-violation? import . \x2E;no-nans-violation?))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.arithmetic.flonums
     '(6)
     '((flonum? import . \x2E;flonum?)
       (real->flonum import . \x2E;real->flonum)
       (fl=? import . \x2E;fl=?)
       (fl<? import . \x2E;fl<?)
       (fl>? import . \x2E;fl>?)
       (fl<=? import . \x2E;fl<=?)
       (fl>=? import . \x2E;fl>=?)
       (flinteger? import . \x2E;flinteger?)
       (flzero? import . \x2E;flzero?)
       (flpositive? import . \x2E;flpositive?)
       (flnegative? import . \x2E;flnegative?)
       (flodd? import . \x2E;flodd?)
       (fleven? import . \x2E;fleven?)
       (flfinite? import . \x2E;flfinite?)
       (flinfinite? import . \x2E;flinfinite?)
       (flnan? import . \x2E;flnan?)
       (flmax import . \x2E;flmax)
       (flmin import . \x2E;flmin)
       (fl+ import . \x2E;fl+)
       (fl* import . \x2E;fl*)
       (fl- import . \x2E;fl-)
       (fl/ import . \x2E;fl/)
       (fldiv-and-mod import . core.arithmetic\x27;fldiv-and-mod)
       (fldiv import . \x2E;fldiv)
       (flmod import . core.arithmetic\x27;flmod)
       (fldiv0-and-mod0 import . core.arithmetic\x27;fldiv0-and-mod0)
       (fldiv0 import . \x2E;fldiv0)
       (flmod0 import . core.arithmetic\x27;flmod0)
       (flnumerator import . \x2E;flnumerator)
       (fldenominator import . \x2E;fldenominator)
       (flfloor import . \x2E;flfloor)
       (flceiling import . \x2E;flceiling)
       (fltruncate import . \x2E;fltruncate)
       (flround import . \x2E;flround)
       (flexp import . \x2E;flexp)
       (flexpt import . \x2E;flexpt)
       (fllog import . \x2E;fllog)
       (flsin import . \x2E;flsin)
       (flcos import . \x2E;flcos)
       (fltan import . \x2E;fltan)
       (flasin import . \x2E;flasin)
       (flacos import . \x2E;flacos)
       (flatan import . \x2E;flatan)
       (flabs import . \x2E;flabs)
       (flsqrt import . \x2E;flsqrt)
       (fixnum->flonum import . \x2E;fixnum->flonum)
       (&no-infinities import . \x2E;&no-infinities)
       (make-no-infinities-violation import . \x2E;make-no-infinities-violation)
       (no-infinities-violation? import . \x2E;no-infinities-violation?)
       (&no-nans import . \x2E;&no-nans)
       (make-no-nans-violation import . \x2E;make-no-nans-violation)
       (no-nans-violation? import . \x2E;no-nans-violation?)))))

((call
   (push.const core arithmetic)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core arithmetic))))
 (push.const . rnrs.arithmetic.bitwise)
 (push.const 6)
 (push.const
   (bitwise-not import . \x2E;bitwise-not)
   (bitwise-and import . \x2E;bitwise-and)
   (bitwise-ior import . \x2E;bitwise-ior)
   (bitwise-xor import . \x2E;bitwise-xor)
   (bitwise-if import . core.arithmetic\x27;bitwise-if)
   (bitwise-bit-count import . \x2E;bitwise-bit-count)
   (bitwise-length import . \x2E;bitwise-length)
   (bitwise-first-bit-set import . \x2E;bitwise-first-bit-set)
   (bitwise-bit-set? import . core.arithmetic\x27;bitwise-bit-set?)
   (bitwise-copy-bit import . core.arithmetic\x27;bitwise-copy-bit)
   (bitwise-bit-field import . core.arithmetic\x27;bitwise-bit-field)
   (bitwise-copy-bit-field import . core.arithmetic\x27;bitwise-copy-bit-field)
   (bitwise-arithmetic-shift import . \x2E;bitwise-arithmetic-shift)
   (bitwise-arithmetic-shift-left import . core.arithmetic\x27;bitwise-arithmetic-shift-left)
   (bitwise-arithmetic-shift-right import . core.arithmetic\x27;bitwise-arithmetic-shift-right)
   (bitwise-rotate-bit-field import . core.arithmetic\x27;bitwise-rotate-bit-field)
   (bitwise-reverse-bit-field import . core.arithmetic\x27;bitwise-reverse-bit-field))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.arithmetic.bitwise
     '(6)
     '((bitwise-not import . \x2E;bitwise-not)
       (bitwise-and import . \x2E;bitwise-and)
       (bitwise-ior import . \x2E;bitwise-ior)
       (bitwise-xor import . \x2E;bitwise-xor)
       (bitwise-if import . core.arithmetic\x27;bitwise-if)
       (bitwise-bit-count import . \x2E;bitwise-bit-count)
       (bitwise-length import . \x2E;bitwise-length)
       (bitwise-first-bit-set import . \x2E;bitwise-first-bit-set)
       (bitwise-bit-set? import . core.arithmetic\x27;bitwise-bit-set?)
       (bitwise-copy-bit import . core.arithmetic\x27;bitwise-copy-bit)
       (bitwise-bit-field import . core.arithmetic\x27;bitwise-bit-field)
       (bitwise-copy-bit-field import . core.arithmetic\x27;bitwise-copy-bit-field)
       (bitwise-arithmetic-shift import . \x2E;bitwise-arithmetic-shift)
       (bitwise-arithmetic-shift-left import . core.arithmetic\x27;bitwise-arithmetic-shift-left)
       (bitwise-arithmetic-shift-right import . core.arithmetic\x27;bitwise-arithmetic-shift-right)
       (bitwise-rotate-bit-field import . core.arithmetic\x27;bitwise-rotate-bit-field)
       (bitwise-reverse-bit-field import . core.arithmetic\x27;bitwise-reverse-bit-field)))))

((call
   (push.const core syntax-case)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core syntax-case))))
 (push.const . rnrs.syntax-case)
 (push.const 6)
 (push.const
   (make-variable-transformer import . \x2E;make-variable-transformer)
   (syntax-case import . \x2E;syntax-case)
   (_ import . \x2E;_)
   (... import . \x2E;...)
   (syntax import . \x2E;syntax)
   (identifier? import . \x2E;identifier?)
   (bound-identifier=? import . \x2E;bound-identifier=?)
   (free-identifier=? import . \x2E;free-identifier=?)
   (syntax->datum import . \x2E;syntax->datum)
   (datum->syntax import . \x2E;datum->syntax)
   (generate-temporaries import . \x2E;generate-temporaries)
   (with-syntax import . core.syntax-case\x27;with-syntax)
   (quasisyntax import . core.syntax-case\x27;quasisyntax)
   (unsyntax import . core.syntax-case\x27;unsyntax)
   (unsyntax-splicing import . core.syntax-case\x27;unsyntax-splicing)
   (syntax-violation import . \x2E;syntax-violation))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.syntax-case
     '(6)
     '((make-variable-transformer import . \x2E;make-variable-transformer)
       (syntax-case import . \x2E;syntax-case)
       (_ import . \x2E;_)
       (... import . \x2E;...)
       (syntax import . \x2E;syntax)
       (identifier? import . \x2E;identifier?)
       (bound-identifier=? import . \x2E;bound-identifier=?)
       (free-identifier=? import . \x2E;free-identifier=?)
       (syntax->datum import . \x2E;syntax->datum)
       (datum->syntax import . \x2E;datum->syntax)
       (generate-temporaries import . \x2E;generate-temporaries)
       (with-syntax import . core.syntax-case\x27;with-syntax)
       (quasisyntax import . core.syntax-case\x27;quasisyntax)
       (unsyntax import . core.syntax-case\x27;unsyntax)
       (unsyntax-splicing import . core.syntax-case\x27;unsyntax-splicing)
       (syntax-violation import . \x2E;syntax-violation)))))

((call
   (push.const core hashtables)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core hashtables))))
 (push.const . rnrs.hashtables)
 (push.const 6)
 (push.const
   (make-eq-hashtable import . core.hashtables\x27;make-eq-hashtable)
   (make-eqv-hashtable import . core.hashtables\x27;make-eqv-hashtable)
   (make-hashtable import . core.hashtables\x27;make-hashtable)
   (hashtable? import . \x2E;core-hashtable?)
   (hashtable-size import . \x2E;core-hashtable-size)
   (hashtable-ref import . \x2E;core-hashtable-ref)
   (hashtable-set! import . \x2E;core-hashtable-set!)
   (hashtable-delete! import . \x2E;core-hashtable-delete!)
   (hashtable-contains? import . \x2E;core-hashtable-contains?)
   (hashtable-update! import . core.hashtables\x27;hashtable-update!)
   (hashtable-copy import . \x2E;core-hashtable-copy)
   (hashtable-clear! import . \x2E;core-hashtable-clear!)
   (hashtable-keys import . core.hashtables\x27;hashtable-keys)
   (hashtable-entries import . core.hashtables\x27;hashtable-entries)
   (hashtable-equivalence-function import . \x2E;core-hashtable-equivalence-function)
   (hashtable-hash-function import . \x2E;core-hashtable-hash-function)
   (hashtable-mutable? import . \x2E;core-hashtable-mutable?)
   (equal-hash import . \x2E;equal-hash)
   (string-hash import . \x2E;string-hash)
   (string-ci-hash import . core.hashtables\x27;string-ci-hash)
   (symbol-hash import . \x2E;symbol-hash))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.hashtables
     '(6)
     '((make-eq-hashtable import . core.hashtables\x27;make-eq-hashtable)
       (make-eqv-hashtable import . core.hashtables\x27;make-eqv-hashtable)
       (make-hashtable import . core.hashtables\x27;make-hashtable)
       (hashtable? import . \x2E;core-hashtable?)
       (hashtable-size import . \x2E;core-hashtable-size)
       (hashtable-ref import . \x2E;core-hashtable-ref)
       (hashtable-set! import . \x2E;core-hashtable-set!)
       (hashtable-delete! import . \x2E;core-hashtable-delete!)
       (hashtable-contains? import . \x2E;core-hashtable-contains?)
       (hashtable-update! import . core.hashtables\x27;hashtable-update!)
       (hashtable-copy import . \x2E;core-hashtable-copy)
       (hashtable-clear! import . \x2E;core-hashtable-clear!)
       (hashtable-keys import . core.hashtables\x27;hashtable-keys)
       (hashtable-entries import . core.hashtables\x27;hashtable-entries)
       (hashtable-equivalence-function import . \x2E;core-hashtable-equivalence-function)
       (hashtable-hash-function import . \x2E;core-hashtable-hash-function)
       (hashtable-mutable? import . \x2E;core-hashtable-mutable?)
       (equal-hash import . \x2E;equal-hash)
       (string-hash import . \x2E;string-hash)
       (string-ci-hash import . core.hashtables\x27;string-ci-hash)
       (symbol-hash import . \x2E;symbol-hash)))))

((call
   (push.const core enums)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core enums))))
 (push.const . rnrs.enums)
 (push.const 6)
 (push.const
   (make-enumeration import . core.enums\x27;make-enumeration)
   (enum-set-universe import . core.enums\x27;enum-set-universe)
   (enum-set-indexer import . core.enums\x27;enum-set-indexer)
   (enum-set-constructor import . core.enums\x27;enum-set-constructor)
   (enum-set->list import . core.enums\x27;enum-set->list)
   (enum-set-member? import . core.enums\x27;enum-set-member?)
   (enum-set-subset? import . core.enums\x27;enum-set-subset?)
   (enum-set=? import . core.enums\x27;enum-set=?)
   (enum-set-union import . core.enums\x27;enum-set-union)
   (enum-set-intersection import . core.enums\x27;enum-set-intersection)
   (enum-set-difference import . core.enums\x27;enum-set-difference)
   (enum-set-complement import . core.enums\x27;enum-set-complement)
   (enum-set-projection import . core.enums\x27;enum-set-projection)
   (define-enumeration import . core.enums\x27;define-enumeration))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs.enums
     '(6)
     '((make-enumeration import . core.enums\x27;make-enumeration)
       (enum-set-universe import . core.enums\x27;enum-set-universe)
       (enum-set-indexer import . core.enums\x27;enum-set-indexer)
       (enum-set-constructor import . core.enums\x27;enum-set-constructor)
       (enum-set->list import . core.enums\x27;enum-set->list)
       (enum-set-member? import . core.enums\x27;enum-set-member?)
       (enum-set-subset? import . core.enums\x27;enum-set-subset?)
       (enum-set=? import . core.enums\x27;enum-set=?)
       (enum-set-union import . core.enums\x27;enum-set-union)
       (enum-set-intersection import . core.enums\x27;enum-set-intersection)
       (enum-set-difference import . core.enums\x27;enum-set-difference)
       (enum-set-complement import . core.enums\x27;enum-set-complement)
       (enum-set-projection import . core.enums\x27;enum-set-projection)
       (define-enumeration import . core.enums\x27;define-enumeration)))))

((call
   (push.const rnrs enums)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs enums))))
 (call
   (push.const rnrs hashtables)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs hashtables))))
 (call
   (push.const rnrs syntax-case)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs syntax-case))))
 (call
   (push.const rnrs arithmetic bitwise)
   (apply.gloc.of
     \x2E;require-scheme-library
     (\x2E;require-scheme-library '(rnrs arithmetic bitwise))))
 (call
   (push.const rnrs arithmetic flonums)
   (apply.gloc.of
     \x2E;require-scheme-library
     (\x2E;require-scheme-library '(rnrs arithmetic flonums))))
 (call
   (push.const rnrs arithmetic fixnums)
   (apply.gloc.of
     \x2E;require-scheme-library
     (\x2E;require-scheme-library '(rnrs arithmetic fixnums))))
 (call
   (push.const rnrs programs)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs programs))))
 (call
   (push.const rnrs files)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs files))))
 (call
   (push.const rnrs io simple)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs io simple))))
 (call
   (push.const rnrs io ports)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs io ports))))
 (call
   (push.const rnrs conditions)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs conditions))))
 (call
   (push.const rnrs exceptions)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs exceptions))))
 (call
   (push.const rnrs records inspection)
   (apply.gloc.of
     \x2E;require-scheme-library
     (\x2E;require-scheme-library '(rnrs records inspection))))
 (call
   (push.const rnrs records procedural)
   (apply.gloc.of
     \x2E;require-scheme-library
     (\x2E;require-scheme-library '(rnrs records procedural))))
 (call
   (push.const rnrs records syntactic)
   (apply.gloc.of
     \x2E;require-scheme-library
     (\x2E;require-scheme-library '(rnrs records syntactic))))
 (call
   (push.const rnrs control)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs control))))
 (call
   (push.const rnrs sorting)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs sorting))))
 (call
   (push.const rnrs lists)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs lists))))
 (call
   (push.const rnrs bytevectors)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs bytevectors))))
 (call
   (push.const rnrs unicode)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs unicode))))
 (call
   (push.const rnrs base)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs base))))
 (push.const . rnrs)
 (push.const 6)
 (push.const
   (define import . \x2E;define)
   (define-syntax import . \x2E;define-syntax)
   (quote import . \x2E;quote)
   (lambda import . \x2E;lambda)
   (if import . \x2E;if)
   (set! import . \x2E;set!)
   (cond import . \x2E;cond)
   (case import . \x2E;case)
   (and import . \x2E;and)
   (or import . \x2E;or)
   (let import . \x2E;let)
   (let* import . \x2E;let*)
   (letrec import . \x2E;letrec)
   (letrec* import . \x2E;letrec*)
   (let-values import . \x2E;let-values)
   (let*-values import . \x2E;let*-values)
   (begin import . \x2E;begin)
   (quasiquote import . \x2E;quasiquote)
   (unquote import . \x2E;unquote)
   (unquote-splicing import . \x2E;unquote-splicing)
   (let-syntax import . \x2E;let-syntax)
   (letrec-syntax import . \x2E;letrec-syntax)
   (syntax-rules import . \x2E;syntax-rules)
   (identifier-syntax import . \x2E;identifier-syntax)
   (assert import . \x2E;assert)
   (else import . \x2E;else)
   (=> import . \x2E;=>)
   (... import . \x2E;...)
   (_ import . \x2E;_)
   (eq? import . \x2E;eq?)
   (eqv? import . \x2E;eqv?)
   (equal? import . \x2E;equal?)
   (procedure? import . \x2E;procedure?)
   (number? import . \x2E;number?)
   (complex? import . \x2E;complex?)
   (real? import . \x2E;real?)
   (rational? import . \x2E;rational?)
   (integer? import . \x2E;integer?)
   (real-valued? import . \x2E;real-valued?)
   (rational-valued? import . \x2E;rational-valued?)
   (integer-valued? import . \x2E;integer-valued?)
   (exact? import . \x2E;exact?)
   (inexact? import . \x2E;inexact?)
   (inexact import . \x2E;inexact)
   (exact import . \x2E;exact)
   (= import . \x2E;=)
   (< import . \x2E;<)
   (> import . \x2E;>)
   (<= import . \x2E;<=)
   (>= import . \x2E;>=)
   (zero? import . \x2E;zero?)
   (positive? import . \x2E;positive?)
   (negative? import . \x2E;negative?)
   (odd? import . \x2E;odd?)
   (even? import . \x2E;even?)
   (finite? import . \x2E;finite?)
   (infinite? import . \x2E;infinite?)
   (nan? import . \x2E;nan?)
   (max import . \x2E;max)
   (min import . \x2E;min)
   (+ import . \x2E;+)
   (* import . \x2E;*)
   (- import . \x2E;-)
   (/ import . \x2E;/)
   (abs import . \x2E;abs)
   (div-and-mod import . \x2E;div-and-mod)
   (div import . \x2E;div)
   (mod import . \x2E;mod)
   (div0-and-mod0 import . \x2E;div0-and-mod0)
   (div0 import . \x2E;div0)
   (mod0 import . \x2E;mod0)
   (gcd import . \x2E;gcd)
   (lcm import . \x2E;lcm)
   (numerator import . \x2E;numerator)
   (denominator import . \x2E;denominator)
   (floor import . \x2E;floor)
   (ceiling import . \x2E;ceiling)
   (truncate import . \x2E;truncate)
   (round import . \x2E;round)
   (rationalize import . \x2E;rationalize)
   (exp import . \x2E;exp)
   (log import . \x2E;log)
   (sin import . \x2E;sin)
   (cos import . \x2E;cos)
   (tan import . \x2E;tan)
   (asin import . \x2E;asin)
   (acos import . \x2E;acos)
   (atan import . \x2E;atan)
   (sqrt import . \x2E;sqrt)
   (exact-integer-sqrt import . \x2E;exact-integer-sqrt)
   (expt import . \x2E;expt)
   (make-rectangular import . \x2E;make-rectangular)
   (make-polar import . \x2E;make-polar)
   (real-part import . \x2E;real-part)
   (imag-part import . \x2E;imag-part)
   (magnitude import . \x2E;magnitude)
   (angle import . \x2E;angle)
   (number->string import . \x2E;number->string)
   (string->number import . \x2E;string->number)
   (not import . \x2E;not)
   (boolean? import . \x2E;boolean?)
   (boolean=? import . \x2E;boolean=?)
   (pair? import . \x2E;pair?)
   (cons import . \x2E;cons)
   (car import . \x2E;car)
   (cdr import . \x2E;cdr)
   (caar import . \x2E;caar)
   (cadr import . \x2E;cadr)
   (cdar import . \x2E;cdar)
   (cddr import . \x2E;cddr)
   (caaar import . \x2E;caaar)
   (caadr import . \x2E;caadr)
   (cadar import . \x2E;cadar)
   (caddr import . \x2E;caddr)
   (cdaar import . \x2E;cdaar)
   (cdadr import . \x2E;cdadr)
   (cddar import . \x2E;cddar)
   (cdddr import . \x2E;cdddr)
   (caaaar import . \x2E;caaaar)
   (caaadr import . \x2E;caaadr)
   (caadar import . \x2E;caadar)
   (caaddr import . \x2E;caaddr)
   (cadaar import . \x2E;cadaar)
   (cadadr import . \x2E;cadadr)
   (caddar import . \x2E;caddar)
   (cadddr import . \x2E;cadddr)
   (cdaaar import . \x2E;cdaaar)
   (cdaadr import . \x2E;cdaadr)
   (cdadar import . \x2E;cdadar)
   (cdaddr import . \x2E;cdaddr)
   (cddaar import . \x2E;cddaar)
   (cddadr import . \x2E;cddadr)
   (cdddar import . \x2E;cdddar)
   (cddddr import . \x2E;cddddr)
   (null? import . \x2E;null?)
   (list? import . \x2E;list?)
   (list import . \x2E;list)
   (length import . \x2E;length)
   (append import . \x2E;append)
   (reverse import . \x2E;reverse)
   (list-tail import . \x2E;list-tail)
   (list-ref import . \x2E;list-ref)
   (map import . \x2E;map)
   (for-each import . \x2E;for-each)
   (symbol? import . \x2E;symbol?)
   (symbol->string import . \x2E;symbol->string)
   (string->symbol import . \x2E;string->symbol)
   (symbol=? import . \x2E;symbol=?)
   (char? import . \x2E;char?)
   (char->integer import . \x2E;char->integer)
   (integer->char import . \x2E;integer->char)
   (char=? import . \x2E;char=?)
   (char<? import . \x2E;char<?)
   (char>? import . \x2E;char>?)
   (char<=? import . \x2E;char<=?)
   (char>=? import . \x2E;char>=?)
   (string? import . \x2E;string?)
   (make-string import . \x2E;make-string)
   (string import . \x2E;string)
   (string-length import . \x2E;string-length)
   (string-ref import . \x2E;string-ref)
   (string=? import . \x2E;string=?)
   (string<? import . \x2E;string<?)
   (string>? import . \x2E;string>?)
   (string<=? import . \x2E;string<=?)
   (string>=? import . \x2E;string>=?)
   (substring import . \x2E;substring)
   (string-append import . \x2E;string-append)
   (string->list import . \x2E;string->list)
   (list->string import . \x2E;list->string)
   (string-copy import . \x2E;string-copy)
   (string-for-each import . \x2E;string-for-each)
   (vector? import . \x2E;vector?)
   (make-vector import . \x2E;make-vector)
   (vector import . \x2E;vector)
   (vector-length import . \x2E;vector-length)
   (vector-ref import . \x2E;vector-ref)
   (vector-set! import . \x2E;vector-set!)
   (vector->list import . \x2E;vector->list)
   (list->vector import . \x2E;list->vector)
   (vector-fill! import . \x2E;vector-fill!)
   (vector-map import . \x2E;vector-map)
   (vector-for-each import . \x2E;vector-for-each)
   (error import . \x2E;error)
   (assertion-violation import . \x2E;assertion-violation)
   (apply import . \x2E;apply)
   (call-with-current-continuation import . \x2E;call-with-current-continuation)
   (call/cc import . \x2E;call/cc)
   (values import . \x2E;values)
   (call-with-values import . \x2E;call-with-values)
   (dynamic-wind import . \x2E;dynamic-wind)
   (char-upcase import . core.unicode\x27;char-upcase)
   (char-downcase import . core.unicode\x27;char-downcase)
   (char-titlecase import . core.unicode\x27;char-titlecase)
   (char-foldcase import . core.unicode\x27;char-foldcase)
   (char-ci=? import . core.unicode\x27;char-ci=?)
   (char-ci<? import . core.unicode\x27;char-ci<?)
   (char-ci>? import . core.unicode\x27;char-ci>?)
   (char-ci<=? import . core.unicode\x27;char-ci<=?)
   (char-ci>=? import . core.unicode\x27;char-ci>=?)
   (char-alphabetic? import . core.unicode\x27;char-alphabetic?)
   (char-numeric? import . core.unicode\x27;char-numeric?)
   (char-whitespace? import . \x2E;char-whitespace?)
   (char-upper-case? import . core.unicode\x27;char-upper-case?)
   (char-lower-case? import . core.unicode\x27;char-lower-case?)
   (char-title-case? import . core.unicode\x27;char-title-case?)
   (char-general-category import . core.unicode\x27;char-general-category)
   (string-upcase import . core.unicode\x27;string-upcase)
   (string-downcase import . core.unicode\x27;string-downcase)
   (string-titlecase import . core.unicode\x27;string-titlecase)
   (string-foldcase import . core.unicode\x27;string-foldcase)
   (string-ci=? import . core.unicode\x27;string-ci=?)
   (string-ci<? import . core.unicode\x27;string-ci<?)
   (string-ci>? import . core.unicode\x27;string-ci>?)
   (string-ci<=? import . core.unicode\x27;string-ci<=?)
   (string-ci>=? import . core.unicode\x27;string-ci>=?)
   (string-normalize-nfd import . core.unicode\x27;string-normalize-nfd)
   (string-normalize-nfkd import . core.unicode\x27;string-normalize-nfkd)
   (string-normalize-nfc import . core.unicode\x27;string-normalize-nfc)
   (string-normalize-nfkc import . core.unicode\x27;string-normalize-nfkc)
   (endianness import . core.bytevectors\x27;endianness)
   (native-endianness import . \x2E;native-endianness)
   (bytevector? import . \x2E;bytevector?)
   (make-bytevector import . \x2E;make-bytevector)
   (bytevector-length import . \x2E;bytevector-length)
   (bytevector=? import . \x2E;bytevector=?)
   (bytevector-fill! import . \x2E;bytevector-fill!)
   (bytevector-copy! import . \x2E;bytevector-copy!)
   (bytevector-copy import . \x2E;bytevector-copy)
   (bytevector-u8-ref import . \x2E;bytevector-u8-ref)
   (bytevector-s8-ref import . \x2E;bytevector-s8-ref)
   (bytevector-u8-set! import . \x2E;bytevector-u8-set!)
   (bytevector-s8-set! import . \x2E;bytevector-s8-set!)
   (bytevector->u8-list import . \x2E;bytevector->u8-list)
   (u8-list->bytevector import . \x2E;u8-list->bytevector)
   (bytevector-u16-ref import . \x2E;bytevector-u16-ref)
   (bytevector-s16-ref import . \x2E;bytevector-s16-ref)
   (bytevector-u16-native-ref import . \x2E;bytevector-u16-native-ref)
   (bytevector-s16-native-ref import . \x2E;bytevector-s16-native-ref)
   (bytevector-u16-set! import . \x2E;bytevector-u16-set!)
   (bytevector-s16-set! import . \x2E;bytevector-s16-set!)
   (bytevector-u16-native-set! import . \x2E;bytevector-u16-native-set!)
   (bytevector-s16-native-set! import . \x2E;bytevector-s16-native-set!)
   (bytevector-u32-ref import . \x2E;bytevector-u32-ref)
   (bytevector-s32-ref import . \x2E;bytevector-s32-ref)
   (bytevector-u32-native-ref import . \x2E;bytevector-u32-native-ref)
   (bytevector-s32-native-ref import . \x2E;bytevector-s32-native-ref)
   (bytevector-u32-set! import . \x2E;bytevector-u32-set!)
   (bytevector-s32-set! import . \x2E;bytevector-s32-set!)
   (bytevector-u32-native-set! import . \x2E;bytevector-u32-native-set!)
   (bytevector-s32-native-set! import . \x2E;bytevector-s32-native-set!)
   (bytevector-u64-ref import . \x2E;bytevector-u64-ref)
   (bytevector-s64-ref import . \x2E;bytevector-s64-ref)
   (bytevector-u64-native-ref import . \x2E;bytevector-u64-native-ref)
   (bytevector-s64-native-ref import . \x2E;bytevector-s64-native-ref)
   (bytevector-u64-set! import . \x2E;bytevector-u64-set!)
   (bytevector-s64-set! import . \x2E;bytevector-s64-set!)
   (bytevector-u64-native-set! import . \x2E;bytevector-u64-native-set!)
   (bytevector-s64-native-set! import . \x2E;bytevector-s64-native-set!)
   (bytevector-ieee-single-ref import . \x2E;bytevector-ieee-single-ref)
   (bytevector-ieee-single-native-ref import . \x2E;bytevector-ieee-single-native-ref)
   (bytevector-ieee-single-set! import . \x2E;bytevector-ieee-single-set!)
   (bytevector-ieee-single-native-set! import . \x2E;bytevector-ieee-single-native-set!)
   (bytevector-ieee-double-ref import . \x2E;bytevector-ieee-double-ref)
   (bytevector-ieee-double-native-ref import . \x2E;bytevector-ieee-double-native-ref)
   (bytevector-ieee-double-set! import . \x2E;bytevector-ieee-double-set!)
   (bytevector-ieee-double-native-set! import . \x2E;bytevector-ieee-double-native-set!)
   (bytevector-uint-ref import . core.bytevectors\x27;bytevector-uint-ref)
   (bytevector-sint-ref import . core.bytevectors\x27;bytevector-sint-ref)
   (bytevector-uint-set! import . core.bytevectors\x27;bytevector-uint-set!)
   (bytevector-sint-set! import . core.bytevectors\x27;bytevector-sint-set!)
   (bytevector->uint-list import . core.bytevectors\x27;bytevector->uint-list)
   (bytevector->sint-list import . core.bytevectors\x27;bytevector->sint-list)
   (uint-list->bytevector import . core.bytevectors\x27;uint-list->bytevector)
   (sint-list->bytevector import . core.bytevectors\x27;sint-list->bytevector)
   (string->utf8 import . \x2E;string->utf8)
   (utf8->string import . \x2E;utf8->string)
   (string->utf16 import . core.bytevector-transcoders\x27;string->utf16)
   (utf16->string import . core.bytevector-transcoders\x27;utf16->string)
   (string->utf32 import . core.bytevector-transcoders\x27;string->utf32)
   (utf32->string import . core.bytevector-transcoders\x27;utf32->string)
   (find import . core.lists\x27;find)
   (for-all import . core.lists\x27;for-all)
   (exists import . core.lists\x27;exists)
   (filter import . core.lists\x27;filter)
   (partition import . core.lists\x27;partition)
   (fold-left import . core.lists\x27;fold-left)
   (fold-right import . core.lists\x27;fold-right)
   (remp import . core.lists\x27;remp)
   (remove import . core.lists\x27;remove)
   (remv import . core.lists\x27;remv)
   (remq import . core.lists\x27;remq)
   (memp import . core.lists\x27;memp)
   (member import . \x2E;member)
   (memv import . \x2E;memv)
   (memq import . \x2E;memq)
   (assp import . core.lists\x27;assp)
   (assoc import . \x2E;assoc)
   (assv import . \x2E;assv)
   (assq import . \x2E;assq)
   (cons* import . \x2E;cons*)
   (list-sort import . core.sorting\x27;list-sort)
   (vector-sort import . core.sorting\x27;vector-sort)
   (vector-sort! import . core.sorting\x27;vector-sort!)
   (when import . core.control\x27;when)
   (unless import . core.control\x27;unless)
   (do import . \x2E;do)
   (case-lambda import . core.control\x27;case-lambda)
   (define-record-type import . core.records\x27;define-record-type)
   (record-type-descriptor import . core.records\x27;record-type-descriptor)
   (record-constructor-descriptor import . core.records\x27;record-constructor-descriptor)
   (fields import . core.records\x27;fields)
   (mutable import . core.records\x27;mutable)
   (immutable import . core.records\x27;immutable)
   (parent import . core.records\x27;parent)
   (protocol import . core.records\x27;protocol)
   (sealed import . core.records\x27;sealed)
   (opaque import . core.records\x27;opaque)
   (nongenerative import . core.records\x27;nongenerative)
   (parent-rtd import . core.records\x27;parent-rtd)
   (make-record-type-descriptor import . \x2E;make-record-type-descriptor)
   (record-type-descriptor? import . \x2E;record-type-descriptor?)
   (make-record-constructor-descriptor import . \x2E;make-record-constructor-descriptor)
   (record-constructor import . \x2E;record-constructor)
   (record-predicate import . \x2E;record-predicate)
   (record-accessor import . \x2E;record-accessor)
   (record-mutator import . \x2E;record-mutator)
   (record? import . \x2E;record?)
   (record-rtd import . \x2E;record-rtd)
   (record-type-name import . \x2E;record-type-name)
   (record-type-parent import . \x2E;record-type-parent)
   (record-type-uid import . \x2E;record-type-uid)
   (record-type-generative? import . \x2E;record-type-generative?)
   (record-type-sealed? import . \x2E;record-type-sealed?)
   (record-type-opaque? import . \x2E;record-type-opaque?)
   (record-type-field-names import . \x2E;record-type-field-names)
   (record-field-mutable? import . \x2E;record-field-mutable?)
   (with-exception-handler import . \x2E;with-exception-handler)
   (guard import . core.exceptions\x27;guard)
   (raise import . \x2E;raise)
   (raise-continuable import . \x2E;raise-continuable)
   (&condition import . \x2E;&condition)
   (condition import . \x2E;condition)
   (simple-conditions import . \x2E;simple-conditions)
   (condition? import . \x2E;condition?)
   (condition-predicate import . \x2E;condition-predicate)
   (condition-accessor import . \x2E;condition-accessor)
   (define-condition-type import . core.conditions\x27;define-condition-type)
   (&message import . \x2E;&message)
   (make-message-condition import . \x2E;make-message-condition)
   (message-condition? import . \x2E;message-condition?)
   (condition-message import . \x2E;condition-message)
   (&warning import . \x2E;&warning)
   (make-warning import . \x2E;make-warning)
   (warning? import . \x2E;warning?)
   (&serious import . \x2E;&serious)
   (make-serious-condition import . \x2E;make-serious-condition)
   (serious-condition? import . \x2E;serious-condition?)
   (&error import . \x2E;&error)
   (make-error import . \x2E;make-error)
   (error? import . \x2E;error?)
   (&violation import . \x2E;&violation)
   (make-violation import . \x2E;make-violation)
   (violation? import . \x2E;violation?)
   (&assertion import . \x2E;&assertion)
   (make-assertion-violation import . \x2E;make-assertion-violation)
   (assertion-violation? import . \x2E;assertion-violation?)
   (&irritants import . \x2E;&irritants)
   (make-irritants-condition import . \x2E;make-irritants-condition)
   (irritants-condition? import . \x2E;irritants-condition?)
   (condition-irritants import . \x2E;condition-irritants)
   (&who import . \x2E;&who)
   (make-who-condition import . \x2E;make-who-condition)
   (who-condition? import . \x2E;who-condition?)
   (condition-who import . \x2E;condition-who)
   (&non-continuable import . \x2E;&non-continuable)
   (make-non-continuable-violation import . \x2E;make-non-continuable-violation)
   (non-continuable-violation? import . \x2E;non-continuable-violation?)
   (&implementation-restriction import . \x2E;&implementation-restriction)
   (make-implementation-restriction-violation
     import
     .
     \x2E;make-implementation-restriction-violation)
   (implementation-restriction-violation? import . \x2E;implementation-restriction-violation?)
   (&lexical import . \x2E;&lexical)
   (make-lexical-violation import . \x2E;make-lexical-violation)
   (lexical-violation? import . \x2E;lexical-violation?)
   (&syntax import . \x2E;&syntax)
   (make-syntax-violation import . \x2E;make-syntax-violation)
   (syntax-violation? import . \x2E;syntax-violation?)
   (syntax-violation-form import . \x2E;syntax-violation-form)
   (syntax-violation-subform import . \x2E;syntax-violation-subform)
   (&undefined import . \x2E;&undefined)
   (make-undefined-violation import . \x2E;make-undefined-violation)
   (undefined-violation? import . \x2E;undefined-violation?)
   (&i/o import . \x2E;&i/o)
   (make-i/o-error import . \x2E;make-i/o-error)
   (i/o-error? import . \x2E;i/o-error?)
   (&i/o-read import . \x2E;&i/o-read)
   (make-i/o-read-error import . \x2E;make-i/o-read-error)
   (i/o-read-error? import . \x2E;i/o-read-error?)
   (&i/o-write import . \x2E;&i/o-write)
   (make-i/o-write-error import . \x2E;make-i/o-write-error)
   (i/o-write-error? import . \x2E;i/o-write-error?)
   (&i/o-invalid-position import . \x2E;&i/o-invalid-position)
   (make-i/o-invalid-position-error import . \x2E;make-i/o-invalid-position-error)
   (i/o-invalid-position-error? import . \x2E;i/o-invalid-position-error?)
   (i/o-error-position import . \x2E;i/o-error-position)
   (&i/o-filename import . \x2E;&i/o-filename)
   (make-i/o-filename-error import . \x2E;make-i/o-filename-error)
   (i/o-filename-error? import . \x2E;i/o-filename-error?)
   (i/o-error-filename import . \x2E;i/o-error-filename)
   (&i/o-file-protection import . \x2E;&i/o-file-protection)
   (make-i/o-file-protection-error import . \x2E;make-i/o-file-protection-error)
   (i/o-file-protection-error? import . \x2E;i/o-file-protection-error?)
   (&i/o-file-is-read-only import . \x2E;&i/o-file-is-read-only)
   (make-i/o-file-is-read-only-error import . \x2E;make-i/o-file-is-read-only-error)
   (i/o-file-is-read-only-error? import . \x2E;i/o-file-is-read-only-error?)
   (&i/o-file-already-exists import . \x2E;&i/o-file-already-exists)
   (make-i/o-file-already-exists-error import . \x2E;make-i/o-file-already-exists-error)
   (i/o-file-already-exists-error? import . \x2E;i/o-file-already-exists-error?)
   (&i/o-file-does-not-exist import . \x2E;&i/o-file-does-not-exist)
   (make-i/o-file-does-not-exist-error import . \x2E;make-i/o-file-does-not-exist-error)
   (i/o-file-does-not-exist-error? import . \x2E;i/o-file-does-not-exist-error?)
   (&i/o-port import . \x2E;&i/o-port)
   (make-i/o-port-error import . \x2E;make-i/o-port-error)
   (i/o-port-error? import . \x2E;i/o-port-error?)
   (i/o-error-port import . \x2E;i/o-error-port)
   (&i/o-decoding import . \x2E;&i/o-decoding)
   (make-i/o-decoding-error import . \x2E;make-i/o-decoding-error)
   (i/o-decoding-error? import . \x2E;i/o-decoding-error?)
   (&i/o-encoding import . \x2E;&i/o-encoding)
   (make-i/o-encoding-error import . \x2E;make-i/o-encoding-error)
   (i/o-encoding-error? import . \x2E;i/o-encoding-error?)
   (i/o-encoding-error-char import . \x2E;i/o-encoding-error-char)
   (file-options import . core.io\x27;file-options)
   (buffer-mode import . core.io\x27;buffer-mode)
   (buffer-mode? import . core.io\x27;buffer-mode?)
   (utf-8-codec import . core.io\x27;utf-8-codec)
   (utf-16-codec import . core.io\x27;utf-16-codec)
   (latin-1-codec import . core.io\x27;latin-1-codec)
   (eol-style import . core.io\x27;eol-style)
   (error-handling-mode import . core.io\x27;error-handling-mode)
   (make-transcoder import . core.io\x27;make-transcoder)
   (transcoder-codec import . core.io\x27;transcoder-codec)
   (transcoder-eol-style import . core.io\x27;transcoder-eol-style)
   (transcoder-error-handling-mode import . core.io\x27;transcoder-error-handling-mode)
   (native-transcoder import . core.io\x27;native-transcoder)
   (native-eol-style import . core.io\x27;native-eol-style)
   (bytevector->string import . core.io\x27;bytevector->string)
   (string->bytevector import . core.io\x27;string->bytevector)
   (eof-object import . \x2E;eof-object)
   (eof-object? import . \x2E;eof-object?)
   (port? import . \x2E;port?)
   (port-transcoder import . core.io\x27;port-transcoder)
   (textual-port? import . core.io\x27;textual-port?)
   (binary-port? import . core.io\x27;binary-port?)
   (transcoded-port import . core.io\x27;transcoded-port)
   (port-has-port-position? import . \x2E;port-has-port-position?)
   (port-position import . \x2E;port-position)
   (port-has-set-port-position!? import . \x2E;port-has-set-port-position!?)
   (set-port-position! import . \x2E;set-port-position!)
   (close-port import . \x2E;close-port)
   (call-with-port import . \x2E;call-with-port)
   (input-port? import . \x2E;input-port?)
   (port-eof? import . \x2E;port-eof?)
   (open-file-input-port import . core.io\x27;open-file-input-port)
   (open-bytevector-input-port import . core.io\x27;open-bytevector-input-port)
   (open-string-input-port import . core.io\x27;open-string-input-port)
   (standard-input-port import . \x2E;standard-input-port)
   (current-input-port import . \x2E;current-input-port)
   (get-u8 import . \x2E;get-u8)
   (lookahead-u8 import . \x2E;lookahead-u8)
   (get-bytevector-n import . \x2E;get-bytevector-n)
   (get-bytevector-n! import . \x2E;get-bytevector-n!)
   (get-bytevector-some import . \x2E;get-bytevector-some)
   (get-bytevector-all import . \x2E;get-bytevector-all)
   (get-char import . \x2E;get-char)
   (lookahead-char import . \x2E;lookahead-char)
   (get-string-n import . \x2E;get-string-n)
   (get-string-n! import . \x2E;get-string-n!)
   (get-string-all import . \x2E;get-string-all)
   (get-line import . \x2E;get-line)
   (get-datum import . \x2E;get-datum)
   (output-port? import . \x2E;output-port?)
   (flush-output-port import . \x2E;flush-output-port)
   (output-port-buffer-mode import . \x2E;output-port-buffer-mode)
   (open-file-output-port import . core.io\x27;open-file-output-port)
   (open-bytevector-output-port import . core.io\x27;open-bytevector-output-port)
   (call-with-bytevector-output-port import . core.io\x27;call-with-bytevector-output-port)
   (open-string-output-port import . core.io\x27;open-string-output-port)
   (call-with-string-output-port import . core.io\x27;call-with-string-output-port)
   (standard-output-port import . \x2E;standard-output-port)
   (standard-error-port import . \x2E;standard-error-port)
   (current-output-port import . \x2E;current-output-port)
   (current-error-port import . \x2E;current-error-port)
   (put-u8 import . \x2E;put-u8)
   (put-bytevector import . \x2E;put-bytevector)
   (put-char import . \x2E;put-char)
   (put-string import . \x2E;put-string)
   (put-datum import . \x2E;put-datum)
   (open-file-input/output-port import . core.io\x27;open-file-input/output-port)
   (make-custom-binary-input-port import . core.io\x27;make-custom-binary-input-port)
   (make-custom-textual-input-port import . core.io\x27;make-custom-textual-input-port)
   (make-custom-binary-output-port import . core.io\x27;make-custom-binary-output-port)
   (make-custom-textual-output-port import . core.io\x27;make-custom-textual-output-port)
   (make-custom-binary-input/output-port import . core.io\x27;make-custom-binary-input/output-port)
   (make-custom-textual-input/output-port
     import
     .
     core.io\x27;make-custom-textual-input/output-port)
   (call-with-input-file import . core.io\x27;call-with-input-file)
   (call-with-output-file import . core.io\x27;call-with-output-file)
   (with-input-from-file import . core.io\x27;with-input-from-file)
   (with-output-to-file import . core.io\x27;with-output-to-file)
   (open-input-file import . core.io\x27;open-input-file)
   (open-output-file import . core.io\x27;open-output-file)
   (close-input-port import . core.io\x27;close-input-port)
   (close-output-port import . core.io\x27;close-output-port)
   (read-char import . \x2E;read-char)
   (peek-char import . \x2E;peek-char)
   (read import . \x2E;read)
   (write-char import . \x2E;write-char)
   (newline import . \x2E;newline)
   (display import . \x2E;display)
   (write import . \x2E;write)
   (file-exists? import . \x2E;file-exists?)
   (delete-file import . \x2E;delete-file)
   (make-enumeration import . core.enums\x27;make-enumeration)
   (enum-set-universe import . core.enums\x27;enum-set-universe)
   (enum-set-indexer import . core.enums\x27;enum-set-indexer)
   (enum-set-constructor import . core.enums\x27;enum-set-constructor)
   (enum-set->list import . core.enums\x27;enum-set->list)
   (enum-set-member? import . core.enums\x27;enum-set-member?)
   (enum-set-subset? import . core.enums\x27;enum-set-subset?)
   (enum-set=? import . core.enums\x27;enum-set=?)
   (enum-set-union import . core.enums\x27;enum-set-union)
   (enum-set-intersection import . core.enums\x27;enum-set-intersection)
   (enum-set-difference import . core.enums\x27;enum-set-difference)
   (enum-set-complement import . core.enums\x27;enum-set-complement)
   (enum-set-projection import . core.enums\x27;enum-set-projection)
   (define-enumeration import . core.enums\x27;define-enumeration)
   (command-line import . \x2E;command-line)
   (exit import . \x2E;exit)
   (fixnum? import . \x2E;fixnum?)
   (fixnum-width import . \x2E;fixnum-width)
   (least-fixnum import . \x2E;least-fixnum)
   (greatest-fixnum import . \x2E;greatest-fixnum)
   (fx=? import . \x2E;fx=?)
   (fx<? import . \x2E;fx<?)
   (fx>? import . \x2E;fx>?)
   (fx<=? import . \x2E;fx<=?)
   (fx>=? import . \x2E;fx>=?)
   (fxzero? import . \x2E;fxzero?)
   (fxpositive? import . \x2E;fxpositive?)
   (fxnegative? import . \x2E;fxnegative?)
   (fxodd? import . \x2E;fxodd?)
   (fxeven? import . \x2E;fxeven?)
   (fxmax import . \x2E;fxmax)
   (fxmin import . \x2E;fxmin)
   (fx+ import . \x2E;fx+)
   (fx* import . \x2E;fx*)
   (fx- import . \x2E;fx-)
   (fxdiv import . \x2E;fxdiv)
   (fxmod import . core.arithmetic\x27;fxmod)
   (fxdiv-and-mod import . core.arithmetic\x27;fxdiv-and-mod)
   (fxdiv0 import . \x2E;fxdiv0)
   (fxmod0 import . core.arithmetic\x27;fxmod0)
   (fxdiv0-and-mod0 import . core.arithmetic\x27;fxdiv0-and-mod0)
   (fx+/carry import . core.arithmetic\x27;fx+/carry)
   (fx-/carry import . core.arithmetic\x27;fx-/carry)
   (fx*/carry import . core.arithmetic\x27;fx*/carry)
   (fxnot import . \x2E;fxnot)
   (fxand import . \x2E;fxand)
   (fxior import . \x2E;fxior)
   (fxxor import . \x2E;fxxor)
   (fxif import . \x2E;fxif)
   (fxbit-count import . \x2E;fxbit-count)
   (fxlength import . \x2E;fxlength)
   (fxfirst-bit-set import . \x2E;fxfirst-bit-set)
   (fxbit-set? import . \x2E;fxbit-set?)
   (fxcopy-bit import . \x2E;fxcopy-bit)
   (fxbit-field import . \x2E;fxbit-field)
   (fxcopy-bit-field import . \x2E;fxcopy-bit-field)
   (fxarithmetic-shift import . \x2E;fxarithmetic-shift)
   (fxarithmetic-shift-left import . \x2E;fxarithmetic-shift-left)
   (fxarithmetic-shift-right import . \x2E;fxarithmetic-shift-right)
   (fxrotate-bit-field import . core.arithmetic\x27;fxrotate-bit-field)
   (fxreverse-bit-field import . core.arithmetic\x27;fxreverse-bit-field)
   (flonum? import . \x2E;flonum?)
   (real->flonum import . \x2E;real->flonum)
   (fl=? import . \x2E;fl=?)
   (fl<? import . \x2E;fl<?)
   (fl>? import . \x2E;fl>?)
   (fl<=? import . \x2E;fl<=?)
   (fl>=? import . \x2E;fl>=?)
   (flinteger? import . \x2E;flinteger?)
   (flzero? import . \x2E;flzero?)
   (flpositive? import . \x2E;flpositive?)
   (flnegative? import . \x2E;flnegative?)
   (flodd? import . \x2E;flodd?)
   (fleven? import . \x2E;fleven?)
   (flfinite? import . \x2E;flfinite?)
   (flinfinite? import . \x2E;flinfinite?)
   (flnan? import . \x2E;flnan?)
   (flmax import . \x2E;flmax)
   (flmin import . \x2E;flmin)
   (fl+ import . \x2E;fl+)
   (fl* import . \x2E;fl*)
   (fl- import . \x2E;fl-)
   (fl/ import . \x2E;fl/)
   (fldiv-and-mod import . core.arithmetic\x27;fldiv-and-mod)
   (fldiv import . \x2E;fldiv)
   (flmod import . core.arithmetic\x27;flmod)
   (fldiv0-and-mod0 import . core.arithmetic\x27;fldiv0-and-mod0)
   (fldiv0 import . \x2E;fldiv0)
   (flmod0 import . core.arithmetic\x27;flmod0)
   (flnumerator import . \x2E;flnumerator)
   (fldenominator import . \x2E;fldenominator)
   (flfloor import . \x2E;flfloor)
   (flceiling import . \x2E;flceiling)
   (fltruncate import . \x2E;fltruncate)
   (flround import . \x2E;flround)
   (flabs import . \x2E;flabs)
   (flexpt import . \x2E;flexpt)
   (flsqrt import . \x2E;flsqrt)
   (flexp import . \x2E;flexp)
   (fllog import . \x2E;fllog)
   (flsin import . \x2E;flsin)
   (flcos import . \x2E;flcos)
   (fltan import . \x2E;fltan)
   (flasin import . \x2E;flasin)
   (flacos import . \x2E;flacos)
   (flatan import . \x2E;flatan)
   (fixnum->flonum import . \x2E;fixnum->flonum)
   (&no-infinities import . \x2E;&no-infinities)
   (make-no-infinities-violation import . \x2E;make-no-infinities-violation)
   (no-infinities-violation? import . \x2E;no-infinities-violation?)
   (&no-nans import . \x2E;&no-nans)
   (make-no-nans-violation import . \x2E;make-no-nans-violation)
   (no-nans-violation? import . \x2E;no-nans-violation?)
   (bitwise-not import . \x2E;bitwise-not)
   (bitwise-and import . \x2E;bitwise-and)
   (bitwise-ior import . \x2E;bitwise-ior)
   (bitwise-xor import . \x2E;bitwise-xor)
   (bitwise-if import . core.arithmetic\x27;bitwise-if)
   (bitwise-bit-count import . \x2E;bitwise-bit-count)
   (bitwise-length import . \x2E;bitwise-length)
   (bitwise-first-bit-set import . \x2E;bitwise-first-bit-set)
   (bitwise-bit-set? import . core.arithmetic\x27;bitwise-bit-set?)
   (bitwise-copy-bit import . core.arithmetic\x27;bitwise-copy-bit)
   (bitwise-bit-field import . core.arithmetic\x27;bitwise-bit-field)
   (bitwise-copy-bit-field import . core.arithmetic\x27;bitwise-copy-bit-field)
   (bitwise-arithmetic-shift import . \x2E;bitwise-arithmetic-shift)
   (bitwise-arithmetic-shift-left import . core.arithmetic\x27;bitwise-arithmetic-shift-left)
   (bitwise-arithmetic-shift-right import . core.arithmetic\x27;bitwise-arithmetic-shift-right)
   (bitwise-rotate-bit-field import . core.arithmetic\x27;bitwise-rotate-bit-field)
   (bitwise-reverse-bit-field import . core.arithmetic\x27;bitwise-reverse-bit-field)
   (syntax-case import . \x2E;syntax-case)
   (syntax import . \x2E;syntax)
   (with-syntax import . core.syntax-case\x27;with-syntax)
   (make-variable-transformer import . \x2E;make-variable-transformer)
   (identifier? import . \x2E;identifier?)
   (bound-identifier=? import . \x2E;bound-identifier=?)
   (free-identifier=? import . \x2E;free-identifier=?)
   (datum->syntax import . \x2E;datum->syntax)
   (syntax->datum import . \x2E;syntax->datum)
   (generate-temporaries import . \x2E;generate-temporaries)
   (quasisyntax import . core.syntax-case\x27;quasisyntax)
   (unsyntax import . core.syntax-case\x27;unsyntax)
   (unsyntax-splicing import . core.syntax-case\x27;unsyntax-splicing)
   (syntax-violation import . \x2E;syntax-violation)
   (make-eq-hashtable import . core.hashtables\x27;make-eq-hashtable)
   (make-eqv-hashtable import . core.hashtables\x27;make-eqv-hashtable)
   (make-hashtable import . core.hashtables\x27;make-hashtable)
   (hashtable? import . \x2E;core-hashtable?)
   (hashtable-size import . \x2E;core-hashtable-size)
   (hashtable-ref import . \x2E;core-hashtable-ref)
   (hashtable-set! import . \x2E;core-hashtable-set!)
   (hashtable-delete! import . \x2E;core-hashtable-delete!)
   (hashtable-contains? import . \x2E;core-hashtable-contains?)
   (hashtable-update! import . core.hashtables\x27;hashtable-update!)
   (hashtable-copy import . \x2E;core-hashtable-copy)
   (hashtable-clear! import . \x2E;core-hashtable-clear!)
   (hashtable-keys import . core.hashtables\x27;hashtable-keys)
   (hashtable-entries import . core.hashtables\x27;hashtable-entries)
   (hashtable-equivalence-function import . \x2E;core-hashtable-equivalence-function)
   (hashtable-hash-function import . \x2E;core-hashtable-hash-function)
   (hashtable-mutable? import . \x2E;core-hashtable-mutable?)
   (equal-hash import . \x2E;equal-hash)
   (string-hash import . \x2E;string-hash)
   (string-ci-hash import . core.hashtables\x27;string-ci-hash)
   (symbol-hash import . \x2E;symbol-hash))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'rnrs
     '(6)
     '((define import . \x2E;define)
       (define-syntax import . \x2E;define-syntax)
       (quote import . \x2E;quote)
       (lambda import . \x2E;lambda)
       (if import . \x2E;if)
       (set! import . \x2E;set!)
       (cond import . \x2E;cond)
       (case import . \x2E;case)
       (and import . \x2E;and)
       (or import . \x2E;or)
       (let import . \x2E;let)
       (let* import . \x2E;let*)
       (letrec import . \x2E;letrec)
       (letrec* import . \x2E;letrec*)
       (let-values import . \x2E;let-values)
       (let*-values import . \x2E;let*-values)
       (begin import . \x2E;begin)
       (quasiquote import . \x2E;quasiquote)
       (unquote import . \x2E;unquote)
       (unquote-splicing import . \x2E;unquote-splicing)
       (let-syntax import . \x2E;let-syntax)
       (letrec-syntax import . \x2E;letrec-syntax)
       (syntax-rules import . \x2E;syntax-rules)
       (identifier-syntax import . \x2E;identifier-syntax)
       (assert import . \x2E;assert)
       (else import . \x2E;else)
       (=> import . \x2E;=>)
       (... import . \x2E;...)
       (_ import . \x2E;_)
       (eq? import . \x2E;eq?)
       (eqv? import . \x2E;eqv?)
       (equal? import . \x2E;equal?)
       (procedure? import . \x2E;procedure?)
       (number? import . \x2E;number?)
       (complex? import . \x2E;complex?)
       (real? import . \x2E;real?)
       (rational? import . \x2E;rational?)
       (integer? import . \x2E;integer?)
       (real-valued? import . \x2E;real-valued?)
       (rational-valued? import . \x2E;rational-valued?)
       (integer-valued? import . \x2E;integer-valued?)
       (exact? import . \x2E;exact?)
       (inexact? import . \x2E;inexact?)
       (inexact import . \x2E;inexact)
       (exact import . \x2E;exact)
       (= import . \x2E;=)
       (< import . \x2E;<)
       (> import . \x2E;>)
       (<= import . \x2E;<=)
       (>= import . \x2E;>=)
       (zero? import . \x2E;zero?)
       (positive? import . \x2E;positive?)
       (negative? import . \x2E;negative?)
       (odd? import . \x2E;odd?)
       (even? import . \x2E;even?)
       (finite? import . \x2E;finite?)
       (infinite? import . \x2E;infinite?)
       (nan? import . \x2E;nan?)
       (max import . \x2E;max)
       (min import . \x2E;min)
       (+ import . \x2E;+)
       (* import . \x2E;*)
       (- import . \x2E;-)
       (/ import . \x2E;/)
       (abs import . \x2E;abs)
       (div-and-mod import . \x2E;div-and-mod)
       (div import . \x2E;div)
       (mod import . \x2E;mod)
       (div0-and-mod0 import . \x2E;div0-and-mod0)
       (div0 import . \x2E;div0)
       (mod0 import . \x2E;mod0)
       (gcd import . \x2E;gcd)
       (lcm import . \x2E;lcm)
       (numerator import . \x2E;numerator)
       (denominator import . \x2E;denominator)
       (floor import . \x2E;floor)
       (ceiling import . \x2E;ceiling)
       (truncate import . \x2E;truncate)
       (round import . \x2E;round)
       (rationalize import . \x2E;rationalize)
       (exp import . \x2E;exp)
       (log import . \x2E;log)
       (sin import . \x2E;sin)
       (cos import . \x2E;cos)
       (tan import . \x2E;tan)
       (asin import . \x2E;asin)
       (acos import . \x2E;acos)
       (atan import . \x2E;atan)
       (sqrt import . \x2E;sqrt)
       (exact-integer-sqrt import . \x2E;exact-integer-sqrt)
       (expt import . \x2E;expt)
       (make-rectangular import . \x2E;make-rectangular)
       (make-polar import . \x2E;make-polar)
       (real-part import . \x2E;real-part)
       (imag-part import . \x2E;imag-part)
       (magnitude import . \x2E;magnitude)
       (angle import . \x2E;angle)
       (number->string import . \x2E;number->string)
       (string->number import . \x2E;string->number)
       (not import . \x2E;not)
       (boolean? import . \x2E;boolean?)
       (boolean=? import . \x2E;boolean=?)
       (pair? import . \x2E;pair?)
       (cons import . \x2E;cons)
       (car import . \x2E;car)
       (cdr import . \x2E;cdr)
       (caar import . \x2E;caar)
       (cadr import . \x2E;cadr)
       (cdar import . \x2E;cdar)
       (cddr import . \x2E;cddr)
       (caaar import . \x2E;caaar)
       (caadr import . \x2E;caadr)
       (cadar import . \x2E;cadar)
       (caddr import . \x2E;caddr)
       (cdaar import . \x2E;cdaar)
       (cdadr import . \x2E;cdadr)
       (cddar import . \x2E;cddar)
       (cdddr import . \x2E;cdddr)
       (caaaar import . \x2E;caaaar)
       (caaadr import . \x2E;caaadr)
       (caadar import . \x2E;caadar)
       (caaddr import . \x2E;caaddr)
       (cadaar import . \x2E;cadaar)
       (cadadr import . \x2E;cadadr)
       (caddar import . \x2E;caddar)
       (cadddr import . \x2E;cadddr)
       (cdaaar import . \x2E;cdaaar)
       (cdaadr import . \x2E;cdaadr)
       (cdadar import . \x2E;cdadar)
       (cdaddr import . \x2E;cdaddr)
       (cddaar import . \x2E;cddaar)
       (cddadr import . \x2E;cddadr)
       (cdddar import . \x2E;cdddar)
       (cddddr import . \x2E;cddddr)
       (null? import . \x2E;null?)
       (list? import . \x2E;list?)
       (list import . \x2E;list)
       (length import . \x2E;length)
       (append import . \x2E;append)
       (reverse import . \x2E;reverse)
       (list-tail import . \x2E;list-tail)
       (list-ref import . \x2E;list-ref)
       (map import . \x2E;map)
       (for-each import . \x2E;for-each)
       (symbol? import . \x2E;symbol?)
       (symbol->string import . \x2E;symbol->string)
       (string->symbol import . \x2E;string->symbol)
       (symbol=? import . \x2E;symbol=?)
       (char? import . \x2E;char?)
       (char->integer import . \x2E;char->integer)
       (integer->char import . \x2E;integer->char)
       (char=? import . \x2E;char=?)
       (char<? import . \x2E;char<?)
       (char>? import . \x2E;char>?)
       (char<=? import . \x2E;char<=?)
       (char>=? import . \x2E;char>=?)
       (string? import . \x2E;string?)
       (make-string import . \x2E;make-string)
       (string import . \x2E;string)
       (string-length import . \x2E;string-length)
       (string-ref import . \x2E;string-ref)
       (string=? import . \x2E;string=?)
       (string<? import . \x2E;string<?)
       (string>? import . \x2E;string>?)
       (string<=? import . \x2E;string<=?)
       (string>=? import . \x2E;string>=?)
       (substring import . \x2E;substring)
       (string-append import . \x2E;string-append)
       (string->list import . \x2E;string->list)
       (list->string import . \x2E;list->string)
       (string-copy import . \x2E;string-copy)
       (string-for-each import . \x2E;string-for-each)
       (vector? import . \x2E;vector?)
       (make-vector import . \x2E;make-vector)
       (vector import . \x2E;vector)
       (vector-length import . \x2E;vector-length)
       (vector-ref import . \x2E;vector-ref)
       (vector-set! import . \x2E;vector-set!)
       (vector->list import . \x2E;vector->list)
       (list->vector import . \x2E;list->vector)
       (vector-fill! import . \x2E;vector-fill!)
       (vector-map import . \x2E;vector-map)
       (vector-for-each import . \x2E;vector-for-each)
       (error import . \x2E;error)
       (assertion-violation import . \x2E;assertion-violation)
       (apply import . \x2E;apply)
       (call-with-current-continuation import . \x2E;call-with-current-continuation)
       (call/cc import . \x2E;call/cc)
       (values import . \x2E;values)
       (call-with-values import . \x2E;call-with-values)
       (dynamic-wind import . \x2E;dynamic-wind)
       (char-upcase import . core.unicode\x27;char-upcase)
       (char-downcase import . core.unicode\x27;char-downcase)
       (char-titlecase import . core.unicode\x27;char-titlecase)
       (char-foldcase import . core.unicode\x27;char-foldcase)
       (char-ci=? import . core.unicode\x27;char-ci=?)
       (char-ci<? import . core.unicode\x27;char-ci<?)
       (char-ci>? import . core.unicode\x27;char-ci>?)
       (char-ci<=? import . core.unicode\x27;char-ci<=?)
       (char-ci>=? import . core.unicode\x27;char-ci>=?)
       (char-alphabetic? import . core.unicode\x27;char-alphabetic?)
       (char-numeric? import . core.unicode\x27;char-numeric?)
       (char-whitespace? import . \x2E;char-whitespace?)
       (char-upper-case? import . core.unicode\x27;char-upper-case?)
       (char-lower-case? import . core.unicode\x27;char-lower-case?)
       (char-title-case? import . core.unicode\x27;char-title-case?)
       (char-general-category import . core.unicode\x27;char-general-category)
       (string-upcase import . core.unicode\x27;string-upcase)
       (string-downcase import . core.unicode\x27;string-downcase)
       (string-titlecase import . core.unicode\x27;string-titlecase)
       (string-foldcase import . core.unicode\x27;string-foldcase)
       (string-ci=? import . core.unicode\x27;string-ci=?)
       (string-ci<? import . core.unicode\x27;string-ci<?)
       (string-ci>? import . core.unicode\x27;string-ci>?)
       (string-ci<=? import . core.unicode\x27;string-ci<=?)
       (string-ci>=? import . core.unicode\x27;string-ci>=?)
       (string-normalize-nfd import . core.unicode\x27;string-normalize-nfd)
       (string-normalize-nfkd import . core.unicode\x27;string-normalize-nfkd)
       (string-normalize-nfc import . core.unicode\x27;string-normalize-nfc)
       (string-normalize-nfkc import . core.unicode\x27;string-normalize-nfkc)
       (endianness import . core.bytevectors\x27;endianness)
       (native-endianness import . \x2E;native-endianness)
       (bytevector? import . \x2E;bytevector?)
       (make-bytevector import . \x2E;make-bytevector)
       (bytevector-length import . \x2E;bytevector-length)
       (bytevector=? import . \x2E;bytevector=?)
       (bytevector-fill! import . \x2E;bytevector-fill!)
       (bytevector-copy! import . \x2E;bytevector-copy!)
       (bytevector-copy import . \x2E;bytevector-copy)
       (bytevector-u8-ref import . \x2E;bytevector-u8-ref)
       (bytevector-s8-ref import . \x2E;bytevector-s8-ref)
       (bytevector-u8-set! import . \x2E;bytevector-u8-set!)
       (bytevector-s8-set! import . \x2E;bytevector-s8-set!)
       (bytevector->u8-list import . \x2E;bytevector->u8-list)
       (u8-list->bytevector import . \x2E;u8-list->bytevector)
       (bytevector-u16-ref import . \x2E;bytevector-u16-ref)
       (bytevector-s16-ref import . \x2E;bytevector-s16-ref)
       (bytevector-u16-native-ref import . \x2E;bytevector-u16-native-ref)
       (bytevector-s16-native-ref import . \x2E;bytevector-s16-native-ref)
       (bytevector-u16-set! import . \x2E;bytevector-u16-set!)
       (bytevector-s16-set! import . \x2E;bytevector-s16-set!)
       (bytevector-u16-native-set! import . \x2E;bytevector-u16-native-set!)
       (bytevector-s16-native-set! import . \x2E;bytevector-s16-native-set!)
       (bytevector-u32-ref import . \x2E;bytevector-u32-ref)
       (bytevector-s32-ref import . \x2E;bytevector-s32-ref)
       (bytevector-u32-native-ref import . \x2E;bytevector-u32-native-ref)
       (bytevector-s32-native-ref import . \x2E;bytevector-s32-native-ref)
       (bytevector-u32-set! import . \x2E;bytevector-u32-set!)
       (bytevector-s32-set! import . \x2E;bytevector-s32-set!)
       (bytevector-u32-native-set! import . \x2E;bytevector-u32-native-set!)
       (bytevector-s32-native-set! import . \x2E;bytevector-s32-native-set!)
       (bytevector-u64-ref import . \x2E;bytevector-u64-ref)
       (bytevector-s64-ref import . \x2E;bytevector-s64-ref)
       (bytevector-u64-native-ref import . \x2E;bytevector-u64-native-ref)
       (bytevector-s64-native-ref import . \x2E;bytevector-s64-native-ref)
       (bytevector-u64-set! import . \x2E;bytevector-u64-set!)
       (bytevector-s64-set! import . \x2E;bytevector-s64-set!)
       (bytevector-u64-native-set! import . \x2E;bytevector-u64-native-set!)
       (bytevector-s64-native-set! import . \x2E;bytevector-s64-native-set!)
       (bytevector-ieee-single-ref import . \x2E;bytevector-ieee-single-ref)
       (bytevector-ieee-single-native-ref import . \x2E;bytevector-ieee-single-native-ref)
       (bytevector-ieee-single-set! import . \x2E;bytevector-ieee-single-set!)
       (bytevector-ieee-single-native-set! import . \x2E;bytevector-ieee-single-native-set!)
       (bytevector-ieee-double-ref import . \x2E;bytevector-ieee-double-ref)
       (bytevector-ieee-double-native-ref import . \x2E;bytevector-ieee-double-native-ref)
       (bytevector-ieee-double-set! import . \x2E;bytevector-ieee-double-set!)
       (bytevector-ieee-double-native-set! import . \x2E;bytevector-ieee-double-native-set!)
       (bytevector-uint-ref import . core.bytevectors\x27;bytevector-uint-ref)
       (bytevector-sint-ref import . core.bytevectors\x27;bytevector-sint-ref)
       (bytevector-uint-set! import . core.bytevectors\x27;bytevector-uint-set!)
       (bytevector-sint-set! import . core.bytevectors\x27;bytevector-sint-set!)
       (bytevector->uint-list import . core.bytevectors\x27;bytevector->uint-list)
       (bytevector->sint-list import . core.bytevectors\x27;bytevector->sint-list)
       (uint-list->bytevector import . core.bytevectors\x27;uint-list->bytevector)
       (sint-list->bytevector import . core.bytevectors\x27;sint-list->bytevector)
       (string->utf8 import . \x2E;string->utf8)
       (utf8->string import . \x2E;utf8->string)
       (string->utf16 import . core.bytevector-transcoders\x27;string->utf16)
       (utf16->string import . core.bytevector-transcoders\x27;utf16->string)
       (string->utf32 import . core.bytevector-transcoders\x27;string->utf32)
       (utf32->string import . core.bytevector-transcoders\x27;utf32->string)
       (find import . core.lists\x27;find)
       (for-all import . core.lists\x27;for-all)
       (exists import . core.lists\x27;exists)
       (filter import . core.lists\x27;filter)
       (partition import . core.lists\x27;partition)
       (fold-left import . core.lists\x27;fold-left)
       (fold-right import . core.lists\x27;fold-right)
       (remp import . core.lists\x27;remp)
       (remove import . core.lists\x27;remove)
       (remv import . core.lists\x27;remv)
       (remq import . core.lists\x27;remq)
       (memp import . core.lists\x27;memp)
       (member import . \x2E;member)
       (memv import . \x2E;memv)
       (memq import . \x2E;memq)
       (assp import . core.lists\x27;assp)
       (assoc import . \x2E;assoc)
       (assv import . \x2E;assv)
       (assq import . \x2E;assq)
       (cons* import . \x2E;cons*)
       (list-sort import . core.sorting\x27;list-sort)
       (vector-sort import . core.sorting\x27;vector-sort)
       (vector-sort! import . core.sorting\x27;vector-sort!)
       (when import . core.control\x27;when)
       (unless import . core.control\x27;unless)
       (do import . \x2E;do)
       (case-lambda import . core.control\x27;case-lambda)
       (define-record-type import . core.records\x27;define-record-type)
       (record-type-descriptor import . core.records\x27;record-type-descriptor)
       (record-constructor-descriptor import . core.records\x27;record-constructor-descriptor)
       (fields import . core.records\x27;fields)
       (mutable import . core.records\x27;mutable)
       (immutable import . core.records\x27;immutable)
       (parent import . core.records\x27;parent)
       (protocol import . core.records\x27;protocol)
       (sealed import . core.records\x27;sealed)
       (opaque import . core.records\x27;opaque)
       (nongenerative import . core.records\x27;nongenerative)
       (parent-rtd import . core.records\x27;parent-rtd)
       (make-record-type-descriptor import . \x2E;make-record-type-descriptor)
       (record-type-descriptor? import . \x2E;record-type-descriptor?)
       (make-record-constructor-descriptor import . \x2E;make-record-constructor-descriptor)
       (record-constructor import . \x2E;record-constructor)
       (record-predicate import . \x2E;record-predicate)
       (record-accessor import . \x2E;record-accessor)
       (record-mutator import . \x2E;record-mutator)
       (record? import . \x2E;record?)
       (record-rtd import . \x2E;record-rtd)
       (record-type-name import . \x2E;record-type-name)
       (record-type-parent import . \x2E;record-type-parent)
       (record-type-uid import . \x2E;record-type-uid)
       (record-type-generative? import . \x2E;record-type-generative?)
       (record-type-sealed? import . \x2E;record-type-sealed?)
       (record-type-opaque? import . \x2E;record-type-opaque?)
       (record-type-field-names import . \x2E;record-type-field-names)
       (record-field-mutable? import . \x2E;record-field-mutable?)
       (with-exception-handler import . \x2E;with-exception-handler)
       (guard import . core.exceptions\x27;guard)
       (raise import . \x2E;raise)
       (raise-continuable import . \x2E;raise-continuable)
       (&condition import . \x2E;&condition)
       (condition import . \x2E;condition)
       (simple-conditions import . \x2E;simple-conditions)
       (condition? import . \x2E;condition?)
       (condition-predicate import . \x2E;condition-predicate)
       (condition-accessor import . \x2E;condition-accessor)
       (define-condition-type import . core.conditions\x27;define-condition-type)
       (&message import . \x2E;&message)
       (make-message-condition import . \x2E;make-message-condition)
       (message-condition? import . \x2E;message-condition?)
       (condition-message import . \x2E;condition-message)
       (&warning import . \x2E;&warning)
       (make-warning import . \x2E;make-warning)
       (warning? import . \x2E;warning?)
       (&serious import . \x2E;&serious)
       (make-serious-condition import . \x2E;make-serious-condition)
       (serious-condition? import . \x2E;serious-condition?)
       (&error import . \x2E;&error)
       (make-error import . \x2E;make-error)
       (error? import . \x2E;error?)
       (&violation import . \x2E;&violation)
       (make-violation import . \x2E;make-violation)
       (violation? import . \x2E;violation?)
       (&assertion import . \x2E;&assertion)
       (make-assertion-violation import . \x2E;make-assertion-violation)
       (assertion-violation? import . \x2E;assertion-violation?)
       (&irritants import . \x2E;&irritants)
       (make-irritants-condition import . \x2E;make-irritants-condition)
       (irritants-condition? import . \x2E;irritants-condition?)
       (condition-irritants import . \x2E;condition-irritants)
       (&who import . \x2E;&who)
       (make-who-condition import . \x2E;make-who-condition)
       (who-condition? import . \x2E;who-condition?)
       (condition-who import . \x2E;condition-who)
       (&non-continuable import . \x2E;&non-continuable)
       (make-non-continuable-violation import . \x2E;make-non-continuable-violation)
       (non-continuable-violation? import . \x2E;non-continuable-violation?)
       (&implementation-restriction import . \x2E;&implementation-restriction)
       (make-implementation-restriction-violation
         import
         .
         \x2E;make-implementation-restriction-violation)
       (implementation-restriction-violation? import . \x2E;implementation-restriction-violation?)
       (&lexical import . \x2E;&lexical)
       (make-lexical-violation import . \x2E;make-lexical-violation)
       (lexical-violation? import . \x2E;lexical-violation?)
       (&syntax import . \x2E;&syntax)
       (make-syntax-violation import . \x2E;make-syntax-violation)
       (syntax-violation? import . \x2E;syntax-violation?)
       (syntax-violation-form import . \x2E;syntax-violation-form)
       (syntax-violation-subform import . \x2E;syntax-violation-subform)
       (&undefined import . \x2E;&undefined)
       (make-undefined-violation import . \x2E;make-undefined-violation)
       (undefined-violation? import . \x2E;undefined-violation?)
       (&i/o import . \x2E;&i/o)
       (make-i/o-error import . \x2E;make-i/o-error)
       (i/o-error? import . \x2E;i/o-error?)
       (&i/o-read import . \x2E;&i/o-read)
       (make-i/o-read-error import . \x2E;make-i/o-read-error)
       (i/o-read-error? import . \x2E;i/o-read-error?)
       (&i/o-write import . \x2E;&i/o-write)
       (make-i/o-write-error import . \x2E;make-i/o-write-error)
       (i/o-write-error? import . \x2E;i/o-write-error?)
       (&i/o-invalid-position import . \x2E;&i/o-invalid-position)
       (make-i/o-invalid-position-error import . \x2E;make-i/o-invalid-position-error)
       (i/o-invalid-position-error? import . \x2E;i/o-invalid-position-error?)
       (i/o-error-position import . \x2E;i/o-error-position)
       (&i/o-filename import . \x2E;&i/o-filename)
       (make-i/o-filename-error import . \x2E;make-i/o-filename-error)
       (i/o-filename-error? import . \x2E;i/o-filename-error?)
       (i/o-error-filename import . \x2E;i/o-error-filename)
       (&i/o-file-protection import . \x2E;&i/o-file-protection)
       (make-i/o-file-protection-error import . \x2E;make-i/o-file-protection-error)
       (i/o-file-protection-error? import . \x2E;i/o-file-protection-error?)
       (&i/o-file-is-read-only import . \x2E;&i/o-file-is-read-only)
       (make-i/o-file-is-read-only-error import . \x2E;make-i/o-file-is-read-only-error)
       (i/o-file-is-read-only-error? import . \x2E;i/o-file-is-read-only-error?)
       (&i/o-file-already-exists import . \x2E;&i/o-file-already-exists)
       (make-i/o-file-already-exists-error import . \x2E;make-i/o-file-already-exists-error)
       (i/o-file-already-exists-error? import . \x2E;i/o-file-already-exists-error?)
       (&i/o-file-does-not-exist import . \x2E;&i/o-file-does-not-exist)
       (make-i/o-file-does-not-exist-error import . \x2E;make-i/o-file-does-not-exist-error)
       (i/o-file-does-not-exist-error? import . \x2E;i/o-file-does-not-exist-error?)
       (&i/o-port import . \x2E;&i/o-port)
       (make-i/o-port-error import . \x2E;make-i/o-port-error)
       (i/o-port-error? import . \x2E;i/o-port-error?)
       (i/o-error-port import . \x2E;i/o-error-port)
       (&i/o-decoding import . \x2E;&i/o-decoding)
       (make-i/o-decoding-error import . \x2E;make-i/o-decoding-error)
       (i/o-decoding-error? import . \x2E;i/o-decoding-error?)
       (&i/o-encoding import . \x2E;&i/o-encoding)
       (make-i/o-encoding-error import . \x2E;make-i/o-encoding-error)
       (i/o-encoding-error? import . \x2E;i/o-encoding-error?)
       (i/o-encoding-error-char import . \x2E;i/o-encoding-error-char)
       (file-options import . core.io\x27;file-options)
       (buffer-mode import . core.io\x27;buffer-mode)
       (buffer-mode? import . core.io\x27;buffer-mode?)
       (utf-8-codec import . core.io\x27;utf-8-codec)
       (utf-16-codec import . core.io\x27;utf-16-codec)
       (latin-1-codec import . core.io\x27;latin-1-codec)
       (eol-style import . core.io\x27;eol-style)
       (error-handling-mode import . core.io\x27;error-handling-mode)
       (make-transcoder import . core.io\x27;make-transcoder)
       (transcoder-codec import . core.io\x27;transcoder-codec)
       (transcoder-eol-style import . core.io\x27;transcoder-eol-style)
       (transcoder-error-handling-mode import . core.io\x27;transcoder-error-handling-mode)
       (native-transcoder import . core.io\x27;native-transcoder)
       (native-eol-style import . core.io\x27;native-eol-style)
       (bytevector->string import . core.io\x27;bytevector->string)
       (string->bytevector import . core.io\x27;string->bytevector)
       (eof-object import . \x2E;eof-object)
       (eof-object? import . \x2E;eof-object?)
       (port? import . \x2E;port?)
       (port-transcoder import . core.io\x27;port-transcoder)
       (textual-port? import . core.io\x27;textual-port?)
       (binary-port? import . core.io\x27;binary-port?)
       (transcoded-port import . core.io\x27;transcoded-port)
       (port-has-port-position? import . \x2E;port-has-port-position?)
       (port-position import . \x2E;port-position)
       (port-has-set-port-position!? import . \x2E;port-has-set-port-position!?)
       (set-port-position! import . \x2E;set-port-position!)
       (close-port import . \x2E;close-port)
       (call-with-port import . \x2E;call-with-port)
       (input-port? import . \x2E;input-port?)
       (port-eof? import . \x2E;port-eof?)
       (open-file-input-port import . core.io\x27;open-file-input-port)
       (open-bytevector-input-port import . core.io\x27;open-bytevector-input-port)
       (open-string-input-port import . core.io\x27;open-string-input-port)
       (standard-input-port import . \x2E;standard-input-port)
       (current-input-port import . \x2E;current-input-port)
       (get-u8 import . \x2E;get-u8)
       (lookahead-u8 import . \x2E;lookahead-u8)
       (get-bytevector-n import . \x2E;get-bytevector-n)
       (get-bytevector-n! import . \x2E;get-bytevector-n!)
       (get-bytevector-some import . \x2E;get-bytevector-some)
       (get-bytevector-all import . \x2E;get-bytevector-all)
       (get-char import . \x2E;get-char)
       (lookahead-char import . \x2E;lookahead-char)
       (get-string-n import . \x2E;get-string-n)
       (get-string-n! import . \x2E;get-string-n!)
       (get-string-all import . \x2E;get-string-all)
       (get-line import . \x2E;get-line)
       (get-datum import . \x2E;get-datum)
       (output-port? import . \x2E;output-port?)
       (flush-output-port import . \x2E;flush-output-port)
       (output-port-buffer-mode import . \x2E;output-port-buffer-mode)
       (open-file-output-port import . core.io\x27;open-file-output-port)
       (open-bytevector-output-port import . core.io\x27;open-bytevector-output-port)
       (call-with-bytevector-output-port import . core.io\x27;call-with-bytevector-output-port)
       (open-string-output-port import . core.io\x27;open-string-output-port)
       (call-with-string-output-port import . core.io\x27;call-with-string-output-port)
       (standard-output-port import . \x2E;standard-output-port)
       (standard-error-port import . \x2E;standard-error-port)
       (current-output-port import . \x2E;current-output-port)
       (current-error-port import . \x2E;current-error-port)
       (put-u8 import . \x2E;put-u8)
       (put-bytevector import . \x2E;put-bytevector)
       (put-char import . \x2E;put-char)
       (put-string import . \x2E;put-string)
       (put-datum import . \x2E;put-datum)
       (open-file-input/output-port import . core.io\x27;open-file-input/output-port)
       (make-custom-binary-input-port import . core.io\x27;make-custom-binary-input-port)
       (make-custom-textual-input-port import . core.io\x27;make-custom-textual-input-port)
       (make-custom-binary-output-port import . core.io\x27;make-custom-binary-output-port)
       (make-custom-textual-output-port import . core.io\x27;make-custom-textual-output-port)
       (make-custom-binary-input/output-port
         import
         .
         core.io\x27;make-custom-binary-input/output-port)
       (make-custom-textual-input/output-port
         import
         .
         core.io\x27;make-custom-textual-input/output-port)
       (call-with-input-file import . core.io\x27;call-with-input-file)
       (call-with-output-file import . core.io\x27;call-with-output-file)
       (with-input-from-file import . core.io\x27;with-input-from-file)
       (with-output-to-file import . core.io\x27;with-output-to-file)
       (open-input-file import . core.io\x27;open-input-file)
       (open-output-file import . core.io\x27;open-output-file)
       (close-input-port import . core.io\x27;close-input-port)
       (close-output-port import . core.io\x27;close-output-port)
       (read-char import . \x2E;read-char)
       (peek-char import . \x2E;peek-char)
       (read import . \x2E;read)
       (write-char import . \x2E;write-char)
       (newline import . \x2E;newline)
       (display import . \x2E;display)
       (write import . \x2E;write)
       (file-exists? import . \x2E;file-exists?)
       (delete-file import . \x2E;delete-file)
       (make-enumeration import . core.enums\x27;make-enumeration)
       (enum-set-universe import . core.enums\x27;enum-set-universe)
       (enum-set-indexer import . core.enums\x27;enum-set-indexer)
       (enum-set-constructor import . core.enums\x27;enum-set-constructor)
       (enum-set->list import . core.enums\x27;enum-set->list)
       (enum-set-member? import . core.enums\x27;enum-set-member?)
       (enum-set-subset? import . core.enums\x27;enum-set-subset?)
       (enum-set=? import . core.enums\x27;enum-set=?)
       (enum-set-union import . core.enums\x27;enum-set-union)
       (enum-set-intersection import . core.enums\x27;enum-set-intersection)
       (enum-set-difference import . core.enums\x27;enum-set-difference)
       (enum-set-complement import . core.enums\x27;enum-set-complement)
       (enum-set-projection import . core.enums\x27;enum-set-projection)
       (define-enumeration import . core.enums\x27;define-enumeration)
       (command-line import . \x2E;command-line)
       (exit import . \x2E;exit)
       (fixnum? import . \x2E;fixnum?)
       (fixnum-width import . \x2E;fixnum-width)
       (least-fixnum import . \x2E;least-fixnum)
       (greatest-fixnum import . \x2E;greatest-fixnum)
       (fx=? import . \x2E;fx=?)
       (fx<? import . \x2E;fx<?)
       (fx>? import . \x2E;fx>?)
       (fx<=? import . \x2E;fx<=?)
       (fx>=? import . \x2E;fx>=?)
       (fxzero? import . \x2E;fxzero?)
       (fxpositive? import . \x2E;fxpositive?)
       (fxnegative? import . \x2E;fxnegative?)
       (fxodd? import . \x2E;fxodd?)
       (fxeven? import . \x2E;fxeven?)
       (fxmax import . \x2E;fxmax)
       (fxmin import . \x2E;fxmin)
       (fx+ import . \x2E;fx+)
       (fx* import . \x2E;fx*)
       (fx- import . \x2E;fx-)
       (fxdiv import . \x2E;fxdiv)
       (fxmod import . core.arithmetic\x27;fxmod)
       (fxdiv-and-mod import . core.arithmetic\x27;fxdiv-and-mod)
       (fxdiv0 import . \x2E;fxdiv0)
       (fxmod0 import . core.arithmetic\x27;fxmod0)
       (fxdiv0-and-mod0 import . core.arithmetic\x27;fxdiv0-and-mod0)
       (fx+/carry import . core.arithmetic\x27;fx+/carry)
       (fx-/carry import . core.arithmetic\x27;fx-/carry)
       (fx*/carry import . core.arithmetic\x27;fx*/carry)
       (fxnot import . \x2E;fxnot)
       (fxand import . \x2E;fxand)
       (fxior import . \x2E;fxior)
       (fxxor import . \x2E;fxxor)
       (fxif import . \x2E;fxif)
       (fxbit-count import . \x2E;fxbit-count)
       (fxlength import . \x2E;fxlength)
       (fxfirst-bit-set import . \x2E;fxfirst-bit-set)
       (fxbit-set? import . \x2E;fxbit-set?)
       (fxcopy-bit import . \x2E;fxcopy-bit)
       (fxbit-field import . \x2E;fxbit-field)
       (fxcopy-bit-field import . \x2E;fxcopy-bit-field)
       (fxarithmetic-shift import . \x2E;fxarithmetic-shift)
       (fxarithmetic-shift-left import . \x2E;fxarithmetic-shift-left)
       (fxarithmetic-shift-right import . \x2E;fxarithmetic-shift-right)
       (fxrotate-bit-field import . core.arithmetic\x27;fxrotate-bit-field)
       (fxreverse-bit-field import . core.arithmetic\x27;fxreverse-bit-field)
       (flonum? import . \x2E;flonum?)
       (real->flonum import . \x2E;real->flonum)
       (fl=? import . \x2E;fl=?)
       (fl<? import . \x2E;fl<?)
       (fl>? import . \x2E;fl>?)
       (fl<=? import . \x2E;fl<=?)
       (fl>=? import . \x2E;fl>=?)
       (flinteger? import . \x2E;flinteger?)
       (flzero? import . \x2E;flzero?)
       (flpositive? import . \x2E;flpositive?)
       (flnegative? import . \x2E;flnegative?)
       (flodd? import . \x2E;flodd?)
       (fleven? import . \x2E;fleven?)
       (flfinite? import . \x2E;flfinite?)
       (flinfinite? import . \x2E;flinfinite?)
       (flnan? import . \x2E;flnan?)
       (flmax import . \x2E;flmax)
       (flmin import . \x2E;flmin)
       (fl+ import . \x2E;fl+)
       (fl* import . \x2E;fl*)
       (fl- import . \x2E;fl-)
       (fl/ import . \x2E;fl/)
       (fldiv-and-mod import . core.arithmetic\x27;fldiv-and-mod)
       (fldiv import . \x2E;fldiv)
       (flmod import . core.arithmetic\x27;flmod)
       (fldiv0-and-mod0 import . core.arithmetic\x27;fldiv0-and-mod0)
       (fldiv0 import . \x2E;fldiv0)
       (flmod0 import . core.arithmetic\x27;flmod0)
       (flnumerator import . \x2E;flnumerator)
       (fldenominator import . \x2E;fldenominator)
       (flfloor import . \x2E;flfloor)
       (flceiling import . \x2E;flceiling)
       (fltruncate import . \x2E;fltruncate)
       (flround import . \x2E;flround)
       (flabs import . \x2E;flabs)
       (flexpt import . \x2E;flexpt)
       (flsqrt import . \x2E;flsqrt)
       (flexp import . \x2E;flexp)
       (fllog import . \x2E;fllog)
       (flsin import . \x2E;flsin)
       (flcos import . \x2E;flcos)
       (fltan import . \x2E;fltan)
       (flasin import . \x2E;flasin)
       (flacos import . \x2E;flacos)
       (flatan import . \x2E;flatan)
       (fixnum->flonum import . \x2E;fixnum->flonum)
       (&no-infinities import . \x2E;&no-infinities)
       (make-no-infinities-violation import . \x2E;make-no-infinities-violation)
       (no-infinities-violation? import . \x2E;no-infinities-violation?)
       (&no-nans import . \x2E;&no-nans)
       (make-no-nans-violation import . \x2E;make-no-nans-violation)
       (no-nans-violation? import . \x2E;no-nans-violation?)
       (bitwise-not import . \x2E;bitwise-not)
       (bitwise-and import . \x2E;bitwise-and)
       (bitwise-ior import . \x2E;bitwise-ior)
       (bitwise-xor import . \x2E;bitwise-xor)
       (bitwise-if import . core.arithmetic\x27;bitwise-if)
       (bitwise-bit-count import . \x2E;bitwise-bit-count)
       (bitwise-length import . \x2E;bitwise-length)
       (bitwise-first-bit-set import . \x2E;bitwise-first-bit-set)
       (bitwise-bit-set? import . core.arithmetic\x27;bitwise-bit-set?)
       (bitwise-copy-bit import . core.arithmetic\x27;bitwise-copy-bit)
       (bitwise-bit-field import . core.arithmetic\x27;bitwise-bit-field)
       (bitwise-copy-bit-field import . core.arithmetic\x27;bitwise-copy-bit-field)
       (bitwise-arithmetic-shift import . \x2E;bitwise-arithmetic-shift)
       (bitwise-arithmetic-shift-left import . core.arithmetic\x27;bitwise-arithmetic-shift-left)
       (bitwise-arithmetic-shift-right import . core.arithmetic\x27;bitwise-arithmetic-shift-right)
       (bitwise-rotate-bit-field import . core.arithmetic\x27;bitwise-rotate-bit-field)
       (bitwise-reverse-bit-field import . core.arithmetic\x27;bitwise-reverse-bit-field)
       (syntax-case import . \x2E;syntax-case)
       (syntax import . \x2E;syntax)
       (with-syntax import . core.syntax-case\x27;with-syntax)
       (make-variable-transformer import . \x2E;make-variable-transformer)
       (identifier? import . \x2E;identifier?)
       (bound-identifier=? import . \x2E;bound-identifier=?)
       (free-identifier=? import . \x2E;free-identifier=?)
       (datum->syntax import . \x2E;datum->syntax)
       (syntax->datum import . \x2E;syntax->datum)
       (generate-temporaries import . \x2E;generate-temporaries)
       (quasisyntax import . core.syntax-case\x27;quasisyntax)
       (unsyntax import . core.syntax-case\x27;unsyntax)
       (unsyntax-splicing import . core.syntax-case\x27;unsyntax-splicing)
       (syntax-violation import . \x2E;syntax-violation)
       (make-eq-hashtable import . core.hashtables\x27;make-eq-hashtable)
       (make-eqv-hashtable import . core.hashtables\x27;make-eqv-hashtable)
       (make-hashtable import . core.hashtables\x27;make-hashtable)
       (hashtable? import . \x2E;core-hashtable?)
       (hashtable-size import . \x2E;core-hashtable-size)
       (hashtable-ref import . \x2E;core-hashtable-ref)
       (hashtable-set! import . \x2E;core-hashtable-set!)
       (hashtable-delete! import . \x2E;core-hashtable-delete!)
       (hashtable-contains? import . \x2E;core-hashtable-contains?)
       (hashtable-update! import . core.hashtables\x27;hashtable-update!)
       (hashtable-copy import . \x2E;core-hashtable-copy)
       (hashtable-clear! import . \x2E;core-hashtable-clear!)
       (hashtable-keys import . core.hashtables\x27;hashtable-keys)
       (hashtable-entries import . core.hashtables\x27;hashtable-entries)
       (hashtable-equivalence-function import . \x2E;core-hashtable-equivalence-function)
       (hashtable-hash-function import . \x2E;core-hashtable-hash-function)
       (hashtable-mutable? import . \x2E;core-hashtable-mutable?)
       (equal-hash import . \x2E;equal-hash)
       (string-hash import . \x2E;string-hash)
       (string-ci-hash import . core.hashtables\x27;string-ci-hash)
       (symbol-hash import . \x2E;symbol-hash)))))

((call
   (push.const rnrs)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(rnrs))))
 (call
   (push.const core enums)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core enums))))
 (call
   (push.const core struct)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core struct))))
 (call
   (push.const core hashtables)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core hashtables))))
 (call
   (push.const core unicode)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core unicode))))
 (call
   (push.const core bytevector-transcoders)
   (apply.gloc.of
     \x2E;require-scheme-library
     (\x2E;require-scheme-library '(core bytevector-transcoders))))
 (call
   (push.const core conditions)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core conditions))))
 (call
   (push.const core records)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core records))))
 (call
   (push.const core destructuring)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core destructuring))))
 (call
   (push.const core lists)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core lists))))
 (call
   (push.const core optargs)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core optargs))))
 (call
   (push.const core control)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core control))))
 (call
   (push.const core r5rs)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core r5rs))))
 (call
   (push.const core syntax-case)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core syntax-case))))
 (call
   (push.const core bytevectors)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core bytevectors))))
 (call
   (push.const core sorting)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core sorting))))
 (call
   (push.const core arithmetic)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core arithmetic))))
 (call
   (push.const core exceptions)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core exceptions))))
 (call
   (push.const core files)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core files))))
 (call
   (push.const core io)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core io))))
 (call
   (push.const core parameters)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core parameters))))
 (call
   (push.const core optimize)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core optimize))))
 (call
   (push.const core primitives)
   (apply.gloc.of \x2E;require-scheme-library (\x2E;require-scheme-library '(core primitives))))
 (push.const . core)
 (push.const . #f)
 (push.const
   (&assertion import . \x2E;&assertion)
   (&condition import . \x2E;&condition)
   (&error import . \x2E;&error)
   (&i/o import . \x2E;&i/o)
   (&i/o-decoding import . \x2E;&i/o-decoding)
   (&i/o-encoding import . \x2E;&i/o-encoding)
   (&i/o-file-already-exists import . \x2E;&i/o-file-already-exists)
   (&i/o-file-does-not-exist import . \x2E;&i/o-file-does-not-exist)
   (&i/o-file-is-read-only import . \x2E;&i/o-file-is-read-only)
   (&i/o-file-protection import . \x2E;&i/o-file-protection)
   (&i/o-filename import . \x2E;&i/o-filename)
   (&i/o-invalid-position import . \x2E;&i/o-invalid-position)
   (&i/o-port import . \x2E;&i/o-port)
   (&i/o-read import . \x2E;&i/o-read)
   (&i/o-write import . \x2E;&i/o-write)
   (&implementation-restriction import . \x2E;&implementation-restriction)
   (&irritants import . \x2E;&irritants)
   (&lexical import . \x2E;&lexical)
   (&message import . \x2E;&message)
   (&no-infinities import . \x2E;&no-infinities)
   (&no-nans import . \x2E;&no-nans)
   (&non-continuable import . \x2E;&non-continuable)
   (&serious import . \x2E;&serious)
   (&syntax import . \x2E;&syntax)
   (&undefined import . \x2E;&undefined)
   (&violation import . \x2E;&violation)
   (&warning import . \x2E;&warning)
   (&who import . \x2E;&who)
   (* import . \x2E;*)
   (+ import . \x2E;+)
   (- import . \x2E;-)
   (... import . \x2E;...)
   (/ import . \x2E;/)
   (< import . \x2E;<)
   (<= import . \x2E;<=)
   (= import . \x2E;=)
   (=> import . \x2E;=>)
   (> import . \x2E;>)
   (>= import . \x2E;>=)
   (_ import . \x2E;_)
   (abs import . \x2E;abs)
   (acos import . \x2E;acos)
   (add-library-path import . \x2E;add-library-path)
   (add-load-path import . \x2E;add-load-path)
   (and import . \x2E;and)
   (angle import . \x2E;angle)
   (append import . \x2E;append)
   (apply import . \x2E;apply)
   (architecture-feature import . \x2E;architecture-feature)
   (asin import . \x2E;asin)
   (assert import . \x2E;assert)
   (assertion-violation import . \x2E;assertion-violation)
   (assertion-violation? import . \x2E;assertion-violation?)
   (assoc import . \x2E;assoc)
   (assp import . core.lists\x27;assp)
   (assq import . \x2E;assq)
   (assv import . \x2E;assv)
   (atan import . \x2E;atan)
   (auto-compile-cache import . \x2E;auto-compile-cache)
   (auto-compile-verbose import . \x2E;auto-compile-verbose)
   (backtrace import . \x2E;backtrace)
   (backtrace-line-length import . \x2E;backtrace-line-length)
   (begin import . \x2E;begin)
   (binary-port? import . core.io\x27;binary-port?)
   (bitwise-and import . \x2E;bitwise-and)
   (bitwise-arithmetic-shift import . \x2E;bitwise-arithmetic-shift)
   (bitwise-arithmetic-shift-left import . core.arithmetic\x27;bitwise-arithmetic-shift-left)
   (bitwise-arithmetic-shift-right import . core.arithmetic\x27;bitwise-arithmetic-shift-right)
   (bitwise-bit-count import . \x2E;bitwise-bit-count)
   (bitwise-bit-field import . core.arithmetic\x27;bitwise-bit-field)
   (bitwise-bit-set? import . core.arithmetic\x27;bitwise-bit-set?)
   (bitwise-copy-bit import . core.arithmetic\x27;bitwise-copy-bit)
   (bitwise-copy-bit-field import . core.arithmetic\x27;bitwise-copy-bit-field)
   (bitwise-first-bit-set import . \x2E;bitwise-first-bit-set)
   (bitwise-if import . core.arithmetic\x27;bitwise-if)
   (bitwise-ior import . \x2E;bitwise-ior)
   (bitwise-length import . \x2E;bitwise-length)
   (bitwise-not import . \x2E;bitwise-not)
   (bitwise-reverse-bit-field import . core.arithmetic\x27;bitwise-reverse-bit-field)
   (bitwise-rotate-bit-field import . core.arithmetic\x27;bitwise-rotate-bit-field)
   (bitwise-xor import . \x2E;bitwise-xor)
   (boolean=? import . \x2E;boolean=?)
   (boolean? import . \x2E;boolean?)
   (bound-identifier=? import . \x2E;bound-identifier=?)
   (break import . core.lists\x27;break)
   (buffer-mode import . core.io\x27;buffer-mode)
   (buffer-mode? import . core.io\x27;buffer-mode?)
   (bytevector->sint-list import . core.bytevectors\x27;bytevector->sint-list)
   (bytevector->string import . core.io\x27;bytevector->string)
   (bytevector->u8-list import . \x2E;bytevector->u8-list)
   (bytevector->uint-list import . core.bytevectors\x27;bytevector->uint-list)
   (bytevector-c-double-ref import . \x2E;bytevector-c-double-ref)
   (bytevector-c-double-set! import . \x2E;bytevector-c-double-set!)
   (bytevector-c-float-ref import . \x2E;bytevector-c-float-ref)
   (bytevector-c-float-set! import . \x2E;bytevector-c-float-set!)
   (bytevector-c-int-ref import . \x2E;bytevector-c-int-ref)
   (bytevector-c-int-set! import . \x2E;bytevector-c-int-set!)
   (bytevector-c-int16-ref import . \x2E;bytevector-c-int16-ref)
   (bytevector-c-int16-set! import . \x2E;bytevector-c-int16-set!)
   (bytevector-c-int32-ref import . \x2E;bytevector-c-int32-ref)
   (bytevector-c-int32-set! import . \x2E;bytevector-c-int32-set!)
   (bytevector-c-int64-ref import . \x2E;bytevector-c-int64-ref)
   (bytevector-c-int64-set! import . \x2E;bytevector-c-int64-set!)
   (bytevector-c-int8-ref import . \x2E;bytevector-c-int8-ref)
   (bytevector-c-int8-set! import . \x2E;bytevector-c-int8-set!)
   (bytevector-c-long-long-ref import . \x2E;bytevector-c-long-long-ref)
   (bytevector-c-long-long-set! import . \x2E;bytevector-c-long-long-set!)
   (bytevector-c-long-ref import . \x2E;bytevector-c-long-ref)
   (bytevector-c-long-set! import . \x2E;bytevector-c-long-set!)
   (bytevector-c-short-ref import . \x2E;bytevector-c-short-ref)
   (bytevector-c-short-set! import . \x2E;bytevector-c-short-set!)
   (bytevector-c-strlen import . \x2E;bytevector-c-strlen)
   (bytevector-c-uint16-ref import . \x2E;bytevector-c-uint16-ref)
   (bytevector-c-uint32-ref import . \x2E;bytevector-c-uint32-ref)
   (bytevector-c-uint64-ref import . \x2E;bytevector-c-uint64-ref)
   (bytevector-c-uint8-ref import . \x2E;bytevector-c-uint8-ref)
   (bytevector-c-unsigned-int-ref import . \x2E;bytevector-c-unsigned-int-ref)
   (bytevector-c-unsigned-long-long-ref import . \x2E;bytevector-c-unsigned-long-long-ref)
   (bytevector-c-unsigned-long-ref import . \x2E;bytevector-c-unsigned-long-ref)
   (bytevector-c-unsigned-short-ref import . \x2E;bytevector-c-unsigned-short-ref)
   (bytevector-c-void*-ref import . \x2E;bytevector-c-void*-ref)
   (bytevector-c-void*-set! import . \x2E;bytevector-c-void*-set!)
   (bytevector-copy import . \x2E;bytevector-copy)
   (bytevector-copy! import . \x2E;bytevector-copy!)
   (bytevector-fill! import . \x2E;bytevector-fill!)
   (bytevector-ieee-double-native-ref import . \x2E;bytevector-ieee-double-native-ref)
   (bytevector-ieee-double-native-set! import . \x2E;bytevector-ieee-double-native-set!)
   (bytevector-ieee-double-ref import . \x2E;bytevector-ieee-double-ref)
   (bytevector-ieee-double-set! import . \x2E;bytevector-ieee-double-set!)
   (bytevector-ieee-single-native-ref import . \x2E;bytevector-ieee-single-native-ref)
   (bytevector-ieee-single-native-set! import . \x2E;bytevector-ieee-single-native-set!)
   (bytevector-ieee-single-ref import . \x2E;bytevector-ieee-single-ref)
   (bytevector-ieee-single-set! import . \x2E;bytevector-ieee-single-set!)
   (bytevector-length import . \x2E;bytevector-length)
   (bytevector-mapping? import . \x2E;bytevector-mapping?)
   (bytevector-s16-native-ref import . \x2E;bytevector-s16-native-ref)
   (bytevector-s16-native-set! import . \x2E;bytevector-s16-native-set!)
   (bytevector-s16-ref import . \x2E;bytevector-s16-ref)
   (bytevector-s16-set! import . \x2E;bytevector-s16-set!)
   (bytevector-s32-native-ref import . \x2E;bytevector-s32-native-ref)
   (bytevector-s32-native-set! import . \x2E;bytevector-s32-native-set!)
   (bytevector-s32-ref import . \x2E;bytevector-s32-ref)
   (bytevector-s32-set! import . \x2E;bytevector-s32-set!)
   (bytevector-s64-native-ref import . \x2E;bytevector-s64-native-ref)
   (bytevector-s64-native-set! import . \x2E;bytevector-s64-native-set!)
   (bytevector-s64-ref import . \x2E;bytevector-s64-ref)
   (bytevector-s64-set! import . \x2E;bytevector-s64-set!)
   (bytevector-s8-ref import . \x2E;bytevector-s8-ref)
   (bytevector-s8-set! import . \x2E;bytevector-s8-set!)
   (bytevector-sint-ref import . core.bytevectors\x27;bytevector-sint-ref)
   (bytevector-sint-set! import . core.bytevectors\x27;bytevector-sint-set!)
   (bytevector-u16-native-ref import . \x2E;bytevector-u16-native-ref)
   (bytevector-u16-native-set! import . \x2E;bytevector-u16-native-set!)
   (bytevector-u16-ref import . \x2E;bytevector-u16-ref)
   (bytevector-u16-set! import . \x2E;bytevector-u16-set!)
   (bytevector-u32-native-ref import . \x2E;bytevector-u32-native-ref)
   (bytevector-u32-native-set! import . \x2E;bytevector-u32-native-set!)
   (bytevector-u32-ref import . \x2E;bytevector-u32-ref)
   (bytevector-u32-set! import . \x2E;bytevector-u32-set!)
   (bytevector-u64-native-ref import . \x2E;bytevector-u64-native-ref)
   (bytevector-u64-native-set! import . \x2E;bytevector-u64-native-set!)
   (bytevector-u64-ref import . \x2E;bytevector-u64-ref)
   (bytevector-u64-set! import . \x2E;bytevector-u64-set!)
   (bytevector-u8-ref import . \x2E;bytevector-u8-ref)
   (bytevector-u8-set! import . \x2E;bytevector-u8-set!)
   (bytevector-uint-ref import . core.bytevectors\x27;bytevector-uint-ref)
   (bytevector-uint-set! import . core.bytevectors\x27;bytevector-uint-set!)
   (bytevector=? import . \x2E;bytevector=?)
   (bytevector? import . \x2E;bytevector?)
   (caaaar import . \x2E;caaaar)
   (caaadr import . \x2E;caaadr)
   (caaar import . \x2E;caaar)
   (caadar import . \x2E;caadar)
   (caaddr import . \x2E;caaddr)
   (caadr import . \x2E;caadr)
   (caar import . \x2E;caar)
   (cadaar import . \x2E;cadaar)
   (cadadr import . \x2E;cadadr)
   (cadar import . \x2E;cadar)
   (caddar import . \x2E;caddar)
   (cadddr import . \x2E;cadddr)
   (caddr import . \x2E;caddr)
   (cadr import . \x2E;cadr)
   (call-with-bytevector-output-port import . core.io\x27;call-with-bytevector-output-port)
   (call-with-current-continuation import . \x2E;call-with-current-continuation)
   (call-with-input-file import . core.io\x27;call-with-input-file)
   (call-with-output-file import . core.io\x27;call-with-output-file)
   (call-with-port import . \x2E;call-with-port)
   (call-with-string-output-port import . core.io\x27;call-with-string-output-port)
   (call-with-values import . \x2E;call-with-values)
   (call/cc import . \x2E;call/cc)
   (car import . \x2E;car)
   (case import . \x2E;case)
   (case-lambda import . core.control\x27;case-lambda)
   (cdaaar import . \x2E;cdaaar)
   (cdaadr import . \x2E;cdaadr)
   (cdaar import . \x2E;cdaar)
   (cdadar import . \x2E;cdadar)
   (cdaddr import . \x2E;cdaddr)
   (cdadr import . \x2E;cdadr)
   (cdar import . \x2E;cdar)
   (cddaar import . \x2E;cddaar)
   (cddadr import . \x2E;cddadr)
   (cddar import . \x2E;cddar)
   (cdddar import . \x2E;cdddar)
   (cddddr import . \x2E;cddddr)
   (cdddr import . \x2E;cdddr)
   (cddr import . \x2E;cddr)
   (cdr import . \x2E;cdr)
   (ceiling import . \x2E;ceiling)
   (change-file-mode import . \x2E;change-file-mode)
   (char->integer import . \x2E;char->integer)
   (char-alphabetic? import . core.unicode\x27;char-alphabetic?)
   (char-ci<=? import . core.unicode\x27;char-ci<=?)
   (char-ci<? import . core.unicode\x27;char-ci<?)
   (char-ci=? import . core.unicode\x27;char-ci=?)
   (char-ci>=? import . core.unicode\x27;char-ci>=?)
   (char-ci>? import . core.unicode\x27;char-ci>?)
   (char-downcase import . core.unicode\x27;char-downcase)
   (char-foldcase import . core.unicode\x27;char-foldcase)
   (char-general-category import . core.unicode\x27;char-general-category)
   (char-lower-case? import . core.unicode\x27;char-lower-case?)
   (char-numeric? import . core.unicode\x27;char-numeric?)
   (char-title-case? import . core.unicode\x27;char-title-case?)
   (char-titlecase import . core.unicode\x27;char-titlecase)
   (char-upcase import . core.unicode\x27;char-upcase)
   (char-upper-case? import . core.unicode\x27;char-upper-case?)
   (char-whitespace? import . \x2E;char-whitespace?)
   (char<=? import . \x2E;char<=?)
   (char<? import . \x2E;char<?)
   (char=? import . \x2E;char=?)
   (char>=? import . \x2E;char>=?)
   (char>? import . \x2E;char>?)
   (char? import . \x2E;char?)
   (circular-list? import . \x2E;circular-list?)
   (close-input-port import . core.io\x27;close-input-port)
   (close-output-port import . core.io\x27;close-output-port)
   (close-port import . \x2E;close-port)
   (closure-code import . \x2E;closure-code)
   (cmwc-random-real import . \x2E;cmwc-random-real)
   (cmwc-random-u32 import . \x2E;cmwc-random-u32)
   (collect import . \x2E;collect)
   (collect-notify import . \x2E;collect-notify)
   (collect-stack-notify import . \x2E;collect-stack-notify)
   (collect-trip-bytes import . \x2E;collect-trip-bytes)
   (command-line import . \x2E;command-line)
   (command-line-shift import . \x2E;command-line-shift)
   (compile import . \x2E;compile)
   (compile-coreform import . \x2E;compile-coreform)
   (complex? import . \x2E;complex?)
   (cond import . \x2E;cond)
   (condition import . \x2E;condition)
   (condition-accessor import . \x2E;condition-accessor)
   (condition-irritants import . \x2E;condition-irritants)
   (condition-message import . \x2E;condition-message)
   (condition-predicate import . \x2E;condition-predicate)
   (condition-who import . \x2E;condition-who)
   (condition? import . \x2E;condition?)
   (cons import . \x2E;cons)
   (cons* import . \x2E;cons*)
   (copy-environment-macros! import . \x2E;copy-environment-macros!)
   (copy-environment-variables! import . \x2E;copy-environment-variables!)
   (core-eval import . \x2E;core-eval)
   (core-hashtable->alist import . \x2E;core-hashtable->alist)
   (core-hashtable-clear! import . \x2E;core-hashtable-clear!)
   (core-hashtable-contains? import . \x2E;core-hashtable-contains?)
   (core-hashtable-copy import . \x2E;core-hashtable-copy)
   (core-hashtable-delete! import . \x2E;core-hashtable-delete!)
   (core-hashtable-equivalence-function import . \x2E;core-hashtable-equivalence-function)
   (core-hashtable-hash-function import . \x2E;core-hashtable-hash-function)
   (core-hashtable-mutable? import . \x2E;core-hashtable-mutable?)
   (core-hashtable-ref import . \x2E;core-hashtable-ref)
   (core-hashtable-set! import . \x2E;core-hashtable-set!)
   (core-hashtable-size import . \x2E;core-hashtable-size)
   (core-hashtable? import . \x2E;core-hashtable?)
   (core-read import . \x2E;core-read)
   (coreform-optimize import . core.optimize\x27;coreform-optimize)
   (cos import . \x2E;cos)
   (create-directory import . \x2E;create-directory)
   (create-hard-link import . \x2E;create-hard-link)
   (create-symbolic-link import . \x2E;create-symbolic-link)
   (current-after-expansion-hook import . \x2E;current-after-expansion-hook)
   (current-directory import . \x2E;current-directory)
   (current-dynamic-environment import . \x2E;current-dynamic-environment)
   (current-environment import . \x2E;current-environment)
   (current-error-port import . \x2E;current-error-port)
   (current-exception-printer import . \x2E;current-exception-printer)
   (current-input-port import . \x2E;current-input-port)
   (current-library-infix import . \x2E;current-library-infix)
   (current-library-suffix import . \x2E;current-library-suffix)
   (current-macro-environment import . \x2E;current-macro-environment)
   (current-output-port import . \x2E;current-output-port)
   (current-primitive-prefix import . \x2E;current-primitive-prefix)
   (current-rename-delimiter import . \x2E;current-rename-delimiter)
   (current-source-comments import . \x2E;current-source-comments)
   (current-variable-environment import . \x2E;current-variable-environment)
   (cyclic-object? import . \x2E;cyclic-object?)
   (datum import . core.syntax-case\x27;datum)
   (datum->syntax import . \x2E;datum->syntax)
   (decode-flonum import . \x2E;decode-flonum)
   (decode-microsecond import . \x2E;decode-microsecond)
   (define import . \x2E;define)
   (define-condition-type import . core.conditions\x27;define-condition-type)
   (define-enumeration import . core.enums\x27;define-enumeration)
   (define-macro import . core.syntax-case\x27;define-macro)
   (define-record-type import . core.records\x27;define-record-type)
   (define-struct import . core.struct\x27;define-struct)
   (define-syntax import . \x2E;define-syntax)
   (delay import . core.r5rs\x27;delay)
   (delete-file import . \x2E;delete-file)
   (denominator import . \x2E;denominator)
   (destructuring-bind import . core.destructuring\x27;destructuring-bind)
   (destructuring-match import . core.destructuring\x27;destructuring-match)
   (directory-list import . \x2E;directory-list)
   (display import . \x2E;display)
   (display-backtrace import . \x2E;display-backtrace)
   (display-heap-statistics import . \x2E;display-heap-statistics)
   (display-object-statistics import . \x2E;display-object-statistics)
   (display-thread-status import . \x2E;display-thread-status)
   (div import . \x2E;div)
   (div-and-mod import . \x2E;div-and-mod)
   (div0 import . \x2E;div0)
   (div0-and-mod0 import . \x2E;div0-and-mod0)
   (do import . \x2E;do)
   (drop import . core.lists\x27;drop)
   (dynamic-wind import . \x2E;dynamic-wind)
   (else import . \x2E;else)
   (encode-microsecond import . \x2E;encode-microsecond)
   (endianness import . core.bytevectors\x27;endianness)
   (enum-set->list import . core.enums\x27;enum-set->list)
   (enum-set-complement import . core.enums\x27;enum-set-complement)
   (enum-set-constructor import . core.enums\x27;enum-set-constructor)
   (enum-set-difference import . core.enums\x27;enum-set-difference)
   (enum-set-indexer import . core.enums\x27;enum-set-indexer)
   (enum-set-intersection import . core.enums\x27;enum-set-intersection)
   (enum-set-member? import . core.enums\x27;enum-set-member?)
   (enum-set-projection import . core.enums\x27;enum-set-projection)
   (enum-set-subset? import . core.enums\x27;enum-set-subset?)
   (enum-set-union import . core.enums\x27;enum-set-union)
   (enum-set-universe import . core.enums\x27;enum-set-universe)
   (enum-set=? import . core.enums\x27;enum-set=?)
   (enum-set? import . core.enums\x27;enum-set?)
   (environment import . \x2E;environment)
   (eof-object import . \x2E;eof-object)
   (eof-object? import . \x2E;eof-object?)
   (eol-style import . core.io\x27;eol-style)
   (eq? import . \x2E;eq?)
   (equal-hash import . \x2E;equal-hash)
   (equal? import . \x2E;equal?)
   (eqv? import . \x2E;eqv?)
   (error import . \x2E;error)
   (error-handling-mode import . core.io\x27;error-handling-mode)
   (error? import . \x2E;error?)
   (eval import . \x2E;eval)
   (even? import . \x2E;even?)
   (exact import . \x2E;exact)
   (exact->inexact import . \x2E;inexact)
   (exact-integer-sqrt import . \x2E;exact-integer-sqrt)
   (exact? import . \x2E;exact?)
   (exists import . core.lists\x27;exists)
   (exit import . \x2E;exit)
   (exp import . \x2E;exp)
   (expansion-backtrace import . \x2E;expansion-backtrace)
   (expt import . \x2E;expt)
   (extract-accumulated-bytevector import . \x2E;extract-accumulated-bytevector)
   (extract-accumulated-string import . \x2E;extract-accumulated-string)
   (fields import . core.records\x27;fields)
   (file-directory? import . \x2E;file-directory?)
   (file-executable? import . \x2E;file-executable?)
   (file-exists? import . \x2E;file-exists?)
   (file-options import . core.io\x27;file-options)
   (file-readable? import . \x2E;file-readable?)
   (file-regular? import . \x2E;file-regular?)
   (file-size-in-bytes import . \x2E;file-size-in-bytes)
   (file-stat-atime import . \x2E;file-stat-atime)
   (file-stat-ctime import . \x2E;file-stat-ctime)
   (file-stat-mtime import . \x2E;file-stat-mtime)
   (file-symbolic-link? import . \x2E;file-symbolic-link?)
   (file-writable? import . \x2E;file-writable?)
   (filter import . core.lists\x27;filter)
   (find import . core.lists\x27;find)
   (finite? import . \x2E;finite?)
   (fixnum->flonum import . \x2E;fixnum->flonum)
   (fixnum-width import . \x2E;fixnum-width)
   (fixnum? import . \x2E;fixnum?)
   (fl* import . \x2E;fl*)
   (fl+ import . \x2E;fl+)
   (fl- import . \x2E;fl-)
   (fl/ import . \x2E;fl/)
   (fl<=? import . \x2E;fl<=?)
   (fl<? import . \x2E;fl<?)
   (fl=? import . \x2E;fl=?)
   (fl>=? import . \x2E;fl>=?)
   (fl>? import . \x2E;fl>?)
   (flabs import . \x2E;flabs)
   (flacos import . \x2E;flacos)
   (flasin import . \x2E;flasin)
   (flatan import . \x2E;flatan)
   (flceiling import . \x2E;flceiling)
   (flcos import . \x2E;flcos)
   (fldenominator import . \x2E;fldenominator)
   (fldiv import . \x2E;fldiv)
   (fldiv-and-mod import . core.arithmetic\x27;fldiv-and-mod)
   (fldiv0 import . \x2E;fldiv0)
   (fldiv0-and-mod0 import . core.arithmetic\x27;fldiv0-and-mod0)
   (fleven? import . \x2E;fleven?)
   (flexp import . \x2E;flexp)
   (flexpt import . \x2E;flexpt)
   (flfinite? import . \x2E;flfinite?)
   (flfloor import . \x2E;flfloor)
   (flinfinite? import . \x2E;flinfinite?)
   (flinteger? import . \x2E;flinteger?)
   (fllog import . \x2E;fllog)
   (flmax import . \x2E;flmax)
   (flmin import . \x2E;flmin)
   (flmod import . core.arithmetic\x27;flmod)
   (flmod0 import . core.arithmetic\x27;flmod0)
   (flnan? import . \x2E;flnan?)
   (flnegative? import . \x2E;flnegative?)
   (flnumerator import . \x2E;flnumerator)
   (flodd? import . \x2E;flodd?)
   (flonum? import . \x2E;flonum?)
   (floor import . \x2E;floor)
   (flpositive? import . \x2E;flpositive?)
   (flround import . \x2E;flround)
   (flsin import . \x2E;flsin)
   (flsqrt import . \x2E;flsqrt)
   (fltan import . \x2E;fltan)
   (fltruncate import . \x2E;fltruncate)
   (flush-output-port import . \x2E;flush-output-port)
   (flzero? import . \x2E;flzero?)
   (fold-left import . core.lists\x27;fold-left)
   (fold-right import . core.lists\x27;fold-right)
   (for-all import . core.lists\x27;for-all)
   (for-each import . \x2E;for-each)
   (force import . core.r5rs\x27;force)
   (format import . \x2E;format)
   (free-identifier=? import . \x2E;free-identifier=?)
   (fx* import . \x2E;fx*)
   (fx*/carry import . core.arithmetic\x27;fx*/carry)
   (fx+ import . \x2E;fx+)
   (fx+/carry import . core.arithmetic\x27;fx+/carry)
   (fx- import . \x2E;fx-)
   (fx-/carry import . core.arithmetic\x27;fx-/carry)
   (fx<=? import . \x2E;fx<=?)
   (fx<? import . \x2E;fx<?)
   (fx=? import . \x2E;fx=?)
   (fx>=? import . \x2E;fx>=?)
   (fx>? import . \x2E;fx>?)
   (fxand import . \x2E;fxand)
   (fxarithmetic-shift import . \x2E;fxarithmetic-shift)
   (fxarithmetic-shift-left import . \x2E;fxarithmetic-shift-left)
   (fxarithmetic-shift-right import . \x2E;fxarithmetic-shift-right)
   (fxbit-count import . \x2E;fxbit-count)
   (fxbit-field import . \x2E;fxbit-field)
   (fxbit-set? import . \x2E;fxbit-set?)
   (fxcopy-bit import . \x2E;fxcopy-bit)
   (fxcopy-bit-field import . \x2E;fxcopy-bit-field)
   (fxdiv import . \x2E;fxdiv)
   (fxdiv-and-mod import . core.arithmetic\x27;fxdiv-and-mod)
   (fxdiv0 import . \x2E;fxdiv0)
   (fxdiv0-and-mod0 import . core.arithmetic\x27;fxdiv0-and-mod0)
   (fxeven? import . \x2E;fxeven?)
   (fxfirst-bit-set import . \x2E;fxfirst-bit-set)
   (fxif import . \x2E;fxif)
   (fxior import . \x2E;fxior)
   (fxlength import . \x2E;fxlength)
   (fxmax import . \x2E;fxmax)
   (fxmin import . \x2E;fxmin)
   (fxmod import . core.arithmetic\x27;fxmod)
   (fxmod0 import . core.arithmetic\x27;fxmod0)
   (fxnegative? import . \x2E;fxnegative?)
   (fxnot import . \x2E;fxnot)
   (fxodd? import . \x2E;fxodd?)
   (fxpositive? import . \x2E;fxpositive?)
   (fxreverse-bit-field import . core.arithmetic\x27;fxreverse-bit-field)
   (fxrotate-bit-field import . core.arithmetic\x27;fxrotate-bit-field)
   (fxxor import . \x2E;fxxor)
   (fxzero? import . \x2E;fxzero?)
   (gcd import . \x2E;gcd)
   (generate-temporaries import . \x2E;generate-temporaries)
   (generate-temporary-symbol import . \x2E;generate-temporary-symbol)
   (gensym import . \x2E;gensym)
   (get-accumulated-string import . \x2E;get-accumulated-string)
   (get-bytevector-all import . \x2E;get-bytevector-all)
   (get-bytevector-n import . \x2E;get-bytevector-n)
   (get-bytevector-n! import . \x2E;get-bytevector-n!)
   (get-bytevector-some import . \x2E;get-bytevector-some)
   (get-char import . \x2E;get-char)
   (get-datum import . \x2E;get-datum)
   (get-line import . \x2E;get-line)
   (get-string-all import . \x2E;get-string-all)
   (get-string-n import . \x2E;get-string-n)
   (get-string-n! import . \x2E;get-string-n!)
   (get-u8 import . \x2E;get-u8)
   (getenv import . \x2E;getenv)
   (gethostname import . \x2E;gethostname)
   (greatest-fixnum import . \x2E;greatest-fixnum)
   (guard import . core.exceptions\x27;guard)
   (hashtable->alist import . \x2E;core-hashtable->alist)
   (hashtable-clear! import . \x2E;core-hashtable-clear!)
   (hashtable-contains? import . \x2E;core-hashtable-contains?)
   (hashtable-copy import . \x2E;core-hashtable-copy)
   (hashtable-delete! import . \x2E;core-hashtable-delete!)
   (hashtable-entries import . core.hashtables\x27;hashtable-entries)
   (hashtable-equivalence-function import . \x2E;core-hashtable-equivalence-function)
   (hashtable-hash-function import . \x2E;core-hashtable-hash-function)
   (hashtable-keys import . core.hashtables\x27;hashtable-keys)
   (hashtable-mutable? import . \x2E;core-hashtable-mutable?)
   (hashtable-ref import . \x2E;core-hashtable-ref)
   (hashtable-set! import . \x2E;core-hashtable-set!)
   (hashtable-size import . \x2E;core-hashtable-size)
   (hashtable-update! import . core.hashtables\x27;hashtable-update!)
   (hashtable? import . \x2E;core-hashtable?)
   (home-directory import . \x2E;home-directory)
   (i/o-decoding-error? import . \x2E;i/o-decoding-error?)
   (i/o-encoding-error-char import . \x2E;i/o-encoding-error-char)
   (i/o-encoding-error? import . \x2E;i/o-encoding-error?)
   (i/o-error-filename import . \x2E;i/o-error-filename)
   (i/o-error-port import . \x2E;i/o-error-port)
   (i/o-error-position import . \x2E;i/o-error-position)
   (i/o-error? import . \x2E;i/o-error?)
   (i/o-file-already-exists-error? import . \x2E;i/o-file-already-exists-error?)
   (i/o-file-does-not-exist-error? import . \x2E;i/o-file-does-not-exist-error?)
   (i/o-file-is-read-only-error? import . \x2E;i/o-file-is-read-only-error?)
   (i/o-file-protection-error? import . \x2E;i/o-file-protection-error?)
   (i/o-filename-error? import . \x2E;i/o-filename-error?)
   (i/o-invalid-position-error? import . \x2E;i/o-invalid-position-error?)
   (i/o-port-error? import . \x2E;i/o-port-error?)
   (i/o-read-error? import . \x2E;i/o-read-error?)
   (i/o-write-error? import . \x2E;i/o-write-error?)
   (identifier-syntax import . \x2E;identifier-syntax)
   (identifier? import . \x2E;identifier?)
   (if import . \x2E;if)
   (imag-part import . \x2E;imag-part)
   (immutable import . core.records\x27;immutable)
   (implementation-restriction-violation? import . \x2E;implementation-restriction-violation?)
   (inexact import . \x2E;inexact)
   (inexact->exact import . \x2E;exact)
   (inexact? import . \x2E;inexact?)
   (infinite? import . \x2E;infinite?)
   (input-port? import . \x2E;input-port?)
   (integer->char import . \x2E;integer->char)
   (integer-valued? import . \x2E;integer-valued?)
   (integer? import . \x2E;integer?)
   (interaction-environment import . \x2E;interaction-environment)
   (iota import . core.lists\x27;iota)
   (irritants-condition? import . \x2E;irritants-condition?)
   (lambda import . \x2E;lambda)
   (latin-1-codec import . core.io\x27;latin-1-codec)
   (lcm import . \x2E;lcm)
   (least-fixnum import . \x2E;least-fixnum)
   (length import . \x2E;length)
   (let import . \x2E;let)
   (let* import . \x2E;let*)
   (let*-values import . \x2E;let*-values)
   (let-optionals import . core.optargs\x27;let-optionals)
   (let-syntax import . \x2E;let-syntax)
   (let-values import . \x2E;let-values)
   (letrec import . \x2E;letrec)
   (letrec* import . \x2E;letrec*)
   (letrec-syntax import . \x2E;letrec-syntax)
   (lexical-violation? import . \x2E;lexical-violation?)
   (library import . \x2E;library)
   (library-extensions import . \x2E;library-extensions)
   (list import . \x2E;list)
   (list->string import . \x2E;list->string)
   (list->vector import . \x2E;list->vector)
   (list-copy import . \x2E;list-copy)
   (list-head import . \x2E;list-head)
   (list-of-unique-symbols? import . core.lists\x27;list-of-unique-symbols?)
   (list-ref import . \x2E;list-ref)
   (list-sort import . core.sorting\x27;list-sort)
   (list-tail import . \x2E;list-tail)
   (list-transpose import . \x2E;list-transpose)
   (list-transpose* import . \x2E;list-transpose*)
   (list-transpose+ import . \x2E;list-transpose+)
   (list? import . \x2E;list?)
   (load import . \x2E;load)
   (local-heap-object? import . \x2E;local-heap-object?)
   (log import . \x2E;log)
   (lookahead-char import . \x2E;lookahead-char)
   (lookahead-u8 import . \x2E;lookahead-u8)
   (lookup-process-environment import . \x2E;lookup-process-environment)
   (macro-expand import . \x2E;macro-expand)
   (magnitude import . \x2E;magnitude)
   (make-assertion-violation import . \x2E;make-assertion-violation)
   (make-bytevector import . \x2E;make-bytevector)
   (make-bytevector-mapping import . \x2E;make-bytevector-mapping)
   (make-cmwc-random-state import . \x2E;make-cmwc-random-state)
   (make-core-hashtable import . \x2E;make-core-hashtable)
   (make-custom-binary-input-port import . core.io\x27;make-custom-binary-input-port)
   (make-custom-binary-input/output-port import . core.io\x27;make-custom-binary-input/output-port)
   (make-custom-binary-output-port import . core.io\x27;make-custom-binary-output-port)
   (make-custom-textual-input-port import . core.io\x27;make-custom-textual-input-port)
   (make-custom-textual-input/output-port
     import
     .
     core.io\x27;make-custom-textual-input/output-port)
   (make-custom-textual-output-port import . core.io\x27;make-custom-textual-output-port)
   (make-enumeration import . core.enums\x27;make-enumeration)
   (make-environment import . \x2E;make-environment)
   (make-eq-hashtable import . core.hashtables\x27;make-eq-hashtable)
   (make-eqv-hashtable import . core.hashtables\x27;make-eqv-hashtable)
   (make-error import . \x2E;make-error)
   (make-hashtable import . core.hashtables\x27;make-hashtable)
   (make-i/o-decoding-error import . \x2E;make-i/o-decoding-error)
   (make-i/o-encoding-error import . \x2E;make-i/o-encoding-error)
   (make-i/o-error import . \x2E;make-i/o-error)
   (make-i/o-file-already-exists-error import . \x2E;make-i/o-file-already-exists-error)
   (make-i/o-file-does-not-exist-error import . \x2E;make-i/o-file-does-not-exist-error)
   (make-i/o-file-is-read-only-error import . \x2E;make-i/o-file-is-read-only-error)
   (make-i/o-file-protection-error import . \x2E;make-i/o-file-protection-error)
   (make-i/o-filename-error import . \x2E;make-i/o-filename-error)
   (make-i/o-invalid-position-error import . \x2E;make-i/o-invalid-position-error)
   (make-i/o-port-error import . \x2E;make-i/o-port-error)
   (make-i/o-read-error import . \x2E;make-i/o-read-error)
   (make-i/o-write-error import . \x2E;make-i/o-write-error)
   (make-implementation-restriction-violation
     import
     .
     \x2E;make-implementation-restriction-violation)
   (make-irritants-condition import . \x2E;make-irritants-condition)
   (make-lexical-violation import . \x2E;make-lexical-violation)
   (make-list import . core.lists\x27;make-list)
   (make-message-condition import . \x2E;make-message-condition)
   (make-no-infinities-violation import . \x2E;make-no-infinities-violation)
   (make-no-nans-violation import . \x2E;make-no-nans-violation)
   (make-non-continuable-violation import . \x2E;make-non-continuable-violation)
   (make-parameter import . \x2E;make-parameter)
   (make-polar import . \x2E;make-polar)
   (make-record-constructor-descriptor import . \x2E;make-record-constructor-descriptor)
   (make-record-type import . \x2E;make-record-type)
   (make-record-type-descriptor import . \x2E;make-record-type-descriptor)
   (make-rectangular import . \x2E;make-rectangular)
   (make-serious-condition import . \x2E;make-serious-condition)
   (make-shared-bag import . \x2E;make-shared-bag)
   (make-shared-core-hashtable import . \x2E;make-shared-core-hashtable)
   (make-shared-queue import . \x2E;make-shared-queue)
   (make-socket import . \x2E;make-socket)
   (make-string import . \x2E;make-string)
   (make-string-hashtable import . core.hashtables\x27;make-string-hashtable)
   (make-string-input-port import . \x2E;make-string-input-port)
   (make-string-output-port import . \x2E;make-string-output-port)
   (make-syntax-violation import . \x2E;make-syntax-violation)
   (make-temporary-file-port import . \x2E;make-temporary-file-port)
   (make-transcoded-port import . \x2E;make-transcoded-port)
   (make-transcoder import . core.io\x27;make-transcoder)
   (make-tuple import . \x2E;make-tuple)
   (make-undefined-violation import . \x2E;make-undefined-violation)
   (make-uuid import . \x2E;make-uuid)
   (make-variable-transformer import . \x2E;make-variable-transformer)
   (make-vector import . \x2E;make-vector)
   (make-violation import . \x2E;make-violation)
   (make-warning import . \x2E;make-warning)
   (make-weak-core-hashtable import . \x2E;make-weak-core-hashtable)
   (make-weak-hashtable import . \x2E;make-weak-shared-core-hashtable)
   (make-weak-mapping import . \x2E;make-weak-mapping)
   (make-weak-shared-core-hashtable import . \x2E;make-weak-shared-core-hashtable)
   (make-who-condition import . \x2E;make-who-condition)
   (map import . \x2E;map)
   (max import . \x2E;max)
   (member import . \x2E;member)
   (memp import . core.lists\x27;memp)
   (memq import . \x2E;memq)
   (memv import . \x2E;memv)
   (message-condition? import . \x2E;message-condition?)
   (microsecond import . \x2E;microsecond)
   (microsecond->string import . \x2E;microsecond->string)
   (microsecond->utc import . \x2E;microsecond->utc)
   (min import . \x2E;min)
   (mod import . \x2E;mod)
   (mod0 import . \x2E;mod0)
   (modulo import . \x2E;modulo)
   (mutable import . core.records\x27;mutable)
   (nan? import . \x2E;nan?)
   (native-endianness import . \x2E;native-endianness)
   (native-eol-style import . core.io\x27;native-eol-style)
   (native-transcoder import . core.io\x27;native-transcoder)
   (native-transcoder-descriptor import . \x2E;native-transcoder-descriptor)
   (negative? import . \x2E;negative?)
   (newline import . \x2E;newline)
   (no-infinities-violation? import . \x2E;no-infinities-violation?)
   (no-nans-violation? import . \x2E;no-nans-violation?)
   (non-continuable-violation? import . \x2E;non-continuable-violation?)
   (nonblock-byte-ready? import . \x2E;nonblock-byte-ready?)
   (nongenerative import . core.records\x27;nongenerative)
   (not import . \x2E;not)
   (null? import . \x2E;null?)
   (number->string import . \x2E;number->string)
   (number? import . \x2E;number?)
   (numerator import . \x2E;numerator)
   (odd? import . \x2E;odd?)
   (on-primordial-thread? import . \x2E;on-primordial-thread?)
   (opaque import . core.records\x27;opaque)
   (open-builtin-data-input-port import . \x2E;open-builtin-data-input-port)
   (open-bytevector-input-port import . core.io\x27;open-bytevector-input-port)
   (open-bytevector-output-port import . core.io\x27;open-bytevector-output-port)
   (open-file-input-port import . core.io\x27;open-file-input-port)
   (open-file-input/output-port import . core.io\x27;open-file-input/output-port)
   (open-file-output-port import . core.io\x27;open-file-output-port)
   (open-input-file import . core.io\x27;open-input-file)
   (open-output-file import . core.io\x27;open-output-file)
   (open-port import . \x2E;open-port)
   (open-string-input-port import . core.io\x27;open-string-input-port)
   (open-string-output-port import . core.io\x27;open-string-output-port)
   (open-temporary-file-port import . core.io\x27;open-temporary-file-port)
   (or import . \x2E;or)
   (output-port-buffer-mode import . \x2E;output-port-buffer-mode)
   (output-port? import . \x2E;output-port?)
   (pair? import . \x2E;pair?)
   (parameterize import . core.parameters\x27;parameterize)
   (parent import . core.records\x27;parent)
   (parent-rtd import . core.records\x27;parent-rtd)
   (partition import . core.lists\x27;partition)
   (peek-char import . \x2E;peek-char)
   (port-closed? import . \x2E;port-closed?)
   (port-device-subtype import . \x2E;port-device-subtype)
   (port-eof? import . \x2E;port-eof?)
   (port-has-port-position? import . \x2E;port-has-port-position?)
   (port-has-set-port-position!? import . \x2E;port-has-set-port-position!?)
   (port-position import . \x2E;port-position)
   (port-transcoder import . core.io\x27;port-transcoder)
   (port-transcoder-descriptor import . \x2E;port-transcoder-descriptor)
   (port? import . \x2E;port?)
   (positive? import . \x2E;positive?)
   (pretty-print import . \x2E;pretty-print)
   (pretty-print-initial-indent import . \x2E;pretty-print-initial-indent)
   (pretty-print-line-length import . \x2E;pretty-print-line-length)
   (pretty-print-maximum-lines import . \x2E;pretty-print-maximum-lines)
   (pretty-print-unwrap-syntax import . \x2E;pretty-print-unwrap-syntax)
   (procedure? import . \x2E;procedure?)
   (process import . \x2E;process)
   (process-environment->alist import . \x2E;process-environment->alist)
   (process-shell-command import . \x2E;process-shell-command)
   (process-spawn import . \x2E;process-spawn)
   (process-wait import . \x2E;process-wait)
   (protocol import . core.records\x27;protocol)
   (put-byte import . \x2E;put-byte)
   (put-bytevector import . \x2E;put-bytevector)
   (put-char import . \x2E;put-char)
   (put-datum import . \x2E;put-datum)
   (put-string import . \x2E;put-string)
   (put-u8 import . \x2E;put-u8)
   (quasiquote import . \x2E;quasiquote)
   (quasisyntax import . core.syntax-case\x27;quasisyntax)
   (quote import . \x2E;quote)
   (quotient import . \x2E;quotient)
   (raise import . \x2E;raise)
   (raise-continuable import . \x2E;raise-continuable)
   (rational-valued? import . \x2E;rational-valued?)
   (rational? import . \x2E;rational?)
   (rationalize import . \x2E;rationalize)
   (read import . \x2E;read)
   (read-char import . \x2E;read-char)
   (read-with-shared-structure import . \x2E;read-with-shared-structure)
   (real->flonum import . \x2E;real->flonum)
   (real-part import . \x2E;real-part)
   (real-valued? import . \x2E;real-valued?)
   (real? import . \x2E;real?)
   (record-accessor import . \x2E;record-accessor)
   (record-constructor import . \x2E;record-constructor)
   (record-constructor-descriptor import . core.records\x27;record-constructor-descriptor)
   (record-field-mutable? import . \x2E;record-field-mutable?)
   (record-mutator import . \x2E;record-mutator)
   (record-predicate import . \x2E;record-predicate)
   (record-print-nesting-limit import . \x2E;record-print-nesting-limit)
   (record-rtd import . \x2E;record-rtd)
   (record-type-descriptor import . core.records\x27;record-type-descriptor)
   (record-type-descriptor? import . \x2E;record-type-descriptor?)
   (record-type-field-names import . \x2E;record-type-field-names)
   (record-type-generative? import . \x2E;record-type-generative?)
   (record-type-name import . \x2E;record-type-name)
   (record-type-opaque? import . \x2E;record-type-opaque?)
   (record-type-parent import . \x2E;record-type-parent)
   (record-type-rcd import . \x2E;record-type-rcd)
   (record-type-rtd import . \x2E;record-type-rtd)
   (record-type-sealed? import . \x2E;record-type-sealed?)
   (record-type-uid import . \x2E;record-type-uid)
   (record-type? import . \x2E;record-type?)
   (record? import . \x2E;record?)
   (remainder import . \x2E;remainder)
   (remove import . core.lists\x27;remove)
   (remove-duplicate-symbols import . core.lists\x27;remove-duplicate-symbols)
   (remp import . core.lists\x27;remp)
   (remq import . core.lists\x27;remq)
   (remv import . core.lists\x27;remv)
   (rename-file import . \x2E;rename-file)
   (restricted-print-line-length import . \x2E;restricted-print-line-length)
   (reverse import . \x2E;reverse)
   (round import . \x2E;round)
   (scheme-error import . \x2E;scheme-error)
   (scheme-library-exports import . \x2E;scheme-library-exports)
   (scheme-library-paths import . \x2E;scheme-library-paths)
   (scheme-load-paths import . \x2E;scheme-load-paths)
   (scheme-load-verbose import . \x2E;scheme-load-verbose)
   (sealed import . core.records\x27;sealed)
   (serializable? import . \x2E;serializable?)
   (serious-condition? import . \x2E;serious-condition?)
   (set! import . \x2E;set!)
   (set-car! import . \x2E;set-car!)
   (set-cdr! import . \x2E;set-cdr!)
   (set-current-error-port! import . \x2E;set-current-error-port!)
   (set-current-input-port! import . \x2E;set-current-input-port!)
   (set-current-output-port! import . \x2E;set-current-output-port!)
   (set-port-position! import . \x2E;set-port-position!)
   (set-top-level-value! import . \x2E;set-top-level-value!)
   (shared-bag-get! import . \x2E;shared-bag-get!)
   (shared-bag-put! import . \x2E;shared-bag-put!)
   (shared-bag? import . \x2E;shared-bag?)
   (shared-queue-pop! import . \x2E;shared-queue-pop!)
   (shared-queue-push! import . \x2E;shared-queue-push!)
   (shared-queue-shutdown import . \x2E;shared-queue-shutdown)
   (shared-queue? import . \x2E;shared-queue?)
   (shutdown-object? import . \x2E;shutdown-object?)
   (shutdown-output-port import . \x2E;shutdown-output-port)
   (simple-conditions import . \x2E;simple-conditions)
   (sin import . \x2E;sin)
   (sint-list->bytevector import . core.bytevectors\x27;sint-list->bytevector)
   (socket->port import . \x2E;socket->port)
   (socket-accept import . \x2E;socket-accept)
   (socket-close import . \x2E;socket-close)
   (socket-port import . \x2E;socket-port)
   (socket-recv import . \x2E;socket-recv)
   (socket-send import . \x2E;socket-send)
   (socket-shutdown import . \x2E;socket-shutdown)
   (socket? import . \x2E;socket?)
   (spawn import . \x2E;spawn)
   (spawn-heap-limit import . \x2E;spawn-heap-limit)
   (spawn-timeout import . \x2E;spawn-timeout)
   (sqrt import . \x2E;sqrt)
   (standard-error-port import . \x2E;standard-error-port)
   (standard-input-port import . \x2E;standard-input-port)
   (standard-output-port import . \x2E;standard-output-port)
   (string import . \x2E;string)
   (string->bytevector import . core.io\x27;string->bytevector)
   (string->list import . \x2E;string->list)
   (string->number import . \x2E;string->number)
   (string->symbol import . \x2E;string->symbol)
   (string->uninterned-symbol import . \x2E;string->uninterned-symbol)
   (string->utf16 import . core.bytevector-transcoders\x27;string->utf16)
   (string->utf32 import . core.bytevector-transcoders\x27;string->utf32)
   (string->utf8 import . \x2E;string->utf8)
   (string->utf8/nul import . \x2E;string->utf8/nul)
   (string-append import . \x2E;string-append)
   (string-ci-hash import . core.hashtables\x27;string-ci-hash)
   (string-ci<=? import . core.unicode\x27;string-ci<=?)
   (string-ci<? import . core.unicode\x27;string-ci<?)
   (string-ci=? import . core.unicode\x27;string-ci=?)
   (string-ci>=? import . core.unicode\x27;string-ci>=?)
   (string-ci>? import . core.unicode\x27;string-ci>?)
   (string-contains import . \x2E;string-contains)
   (string-copy import . \x2E;string-copy)
   (string-downcase import . core.unicode\x27;string-downcase)
   (string-fill! import . \x2E;string-fill!)
   (string-foldcase import . core.unicode\x27;string-foldcase)
   (string-for-each import . \x2E;string-for-each)
   (string-hash import . \x2E;string-hash)
   (string-length import . \x2E;string-length)
   (string-normalize-nfc import . core.unicode\x27;string-normalize-nfc)
   (string-normalize-nfd import . core.unicode\x27;string-normalize-nfd)
   (string-normalize-nfkc import . core.unicode\x27;string-normalize-nfkc)
   (string-normalize-nfkd import . core.unicode\x27;string-normalize-nfkd)
   (string-ref import . \x2E;string-ref)
   (string-set! import . \x2E;string-set!)
   (string-titlecase import . core.unicode\x27;string-titlecase)
   (string-upcase import . core.unicode\x27;string-upcase)
   (string<=? import . \x2E;string<=?)
   (string<? import . \x2E;string<?)
   (string=? import . \x2E;string=?)
   (string>=? import . \x2E;string>=?)
   (string>? import . \x2E;string>?)
   (string? import . \x2E;string?)
   (subr? import . \x2E;subr?)
   (substring import . \x2E;substring)
   (symbol->string import . \x2E;symbol->string)
   (symbol-contains import . \x2E;symbol-contains)
   (symbol-hash import . \x2E;symbol-hash)
   (symbol=? import . \x2E;symbol=?)
   (symbol? import . \x2E;symbol?)
   (syntax import . \x2E;syntax)
   (syntax->datum import . \x2E;syntax->datum)
   (syntax-case import . \x2E;syntax-case)
   (syntax-rules import . \x2E;syntax-rules)
   (syntax-violation import . \x2E;syntax-violation)
   (syntax-violation-form import . \x2E;syntax-violation-form)
   (syntax-violation-subform import . \x2E;syntax-violation-subform)
   (syntax-violation? import . \x2E;syntax-violation?)
   (system import . \x2E;system)
   (system-environment import . \x2E;system-environment)
   (system-extension-path import . \x2E;system-extension-path)
   (system-share-path import . \x2E;system-share-path)
   (take import . core.lists\x27;take)
   (tan import . \x2E;tan)
   (textual-port? import . core.io\x27;textual-port?)
   (time-usage import . \x2E;time-usage)
   (timeout-object? import . \x2E;timeout-object?)
   (top-level-bound? import . \x2E;top-level-bound?)
   (top-level-value import . \x2E;top-level-value)
   (track-file-open import . \x2E;track-file-open)
   (transcoded-port import . core.io\x27;transcoded-port)
   (transcoder-codec import . core.io\x27;transcoder-codec)
   (transcoder-eol-style import . core.io\x27;transcoder-eol-style)
   (transcoder-error-handling-mode import . core.io\x27;transcoder-error-handling-mode)
   (truncate import . \x2E;truncate)
   (tuple import . \x2E;tuple)
   (tuple->list import . \x2E;tuple->list)
   (tuple-index import . \x2E;tuple-index)
   (tuple-length import . \x2E;tuple-length)
   (tuple-ref import . \x2E;tuple-ref)
   (tuple-set! import . \x2E;tuple-set!)
   (tuple? import . \x2E;tuple?)
   (u8-list->bytevector import . \x2E;u8-list->bytevector)
   (uint-list->bytevector import . core.bytevectors\x27;uint-list->bytevector)
   (undefined-violation? import . \x2E;undefined-violation?)
   (uninterned-symbol-prefix import . \x2E;uninterned-symbol-prefix)
   (uninterned-symbol-suffix import . \x2E;uninterned-symbol-suffix)
   (uninterned-symbol? import . \x2E;uninterned-symbol?)
   (unless import . core.control\x27;unless)
   (unquote import . \x2E;unquote)
   (unquote-splicing import . \x2E;unquote-splicing)
   (unspecified import . \x2E;unspecified)
   (unspecified? import . \x2E;unspecified?)
   (unsyntax import . core.syntax-case\x27;unsyntax)
   (unsyntax-splicing import . core.syntax-case\x27;unsyntax-splicing)
   (usleep import . \x2E;usleep)
   (utf-16-codec import . core.io\x27;utf-16-codec)
   (utf-8-codec import . core.io\x27;utf-8-codec)
   (utf16->string import . core.bytevector-transcoders\x27;utf16->string)
   (utf32->string import . core.bytevector-transcoders\x27;utf32->string)
   (utf8->string import . \x2E;utf8->string)
   (values import . \x2E;values)
   (vector import . \x2E;vector)
   (vector->list import . \x2E;vector->list)
   (vector-copy import . \x2E;vector-copy)
   (vector-fill! import . \x2E;vector-fill!)
   (vector-for-each import . \x2E;vector-for-each)
   (vector-length import . \x2E;vector-length)
   (vector-map import . \x2E;vector-map)
   (vector-ref import . \x2E;vector-ref)
   (vector-set! import . \x2E;vector-set!)
   (vector-sort import . core.sorting\x27;vector-sort)
   (vector-sort! import . core.sorting\x27;vector-sort!)
   (vector? import . \x2E;vector?)
   (violation? import . \x2E;violation?)
   (warning-level import . \x2E;warning-level)
   (warning? import . \x2E;warning?)
   (weak-core-hashtable? import . \x2E;weak-core-hashtable?)
   (weak-hashtable? import . \x2E;weak-core-hashtable?)
   (weak-mapping-key import . \x2E;weak-mapping-key)
   (weak-mapping-value import . \x2E;weak-mapping-value)
   (weak-mapping? import . \x2E;weak-mapping?)
   (when import . core.control\x27;when)
   (who-condition? import . \x2E;who-condition?)
   (with-exception-handler import . \x2E;with-exception-handler)
   (with-input-from-file import . core.io\x27;with-input-from-file)
   (with-output-to-file import . core.io\x27;with-output-to-file)
   (with-syntax import . core.syntax-case\x27;with-syntax)
   (write import . \x2E;write)
   (write-char import . \x2E;write-char)
   (write-with-shared-structure import . \x2E;write-with-shared-structure)
   (zero? import . \x2E;zero?))
 (apply.gloc.of
   \x2E;intern-scheme-library
   (\x2E;intern-scheme-library
     'core
     #f
     '((&assertion import . \x2E;&assertion)
       (&condition import . \x2E;&condition)
       (&error import . \x2E;&error)
       (&i/o import . \x2E;&i/o)
       (&i/o-decoding import . \x2E;&i/o-decoding)
       (&i/o-encoding import . \x2E;&i/o-encoding)
       (&i/o-file-already-exists import . \x2E;&i/o-file-already-exists)
       (&i/o-file-does-not-exist import . \x2E;&i/o-file-does-not-exist)
       (&i/o-file-is-read-only import . \x2E;&i/o-file-is-read-only)
       (&i/o-file-protection import . \x2E;&i/o-file-protection)
       (&i/o-filename import . \x2E;&i/o-filename)
       (&i/o-invalid-position import . \x2E;&i/o-invalid-position)
       (&i/o-port import . \x2E;&i/o-port)
       (&i/o-read import . \x2E;&i/o-read)
       (&i/o-write import . \x2E;&i/o-write)
       (&implementation-restriction import . \x2E;&implementation-restriction)
       (&irritants import . \x2E;&irritants)
       (&lexical import . \x2E;&lexical)
       (&message import . \x2E;&message)
       (&no-infinities import . \x2E;&no-infinities)
       (&no-nans import . \x2E;&no-nans)
       (&non-continuable import . \x2E;&non-continuable)
       (&serious import . \x2E;&serious)
       (&syntax import . \x2E;&syntax)
       (&undefined import . \x2E;&undefined)
       (&violation import . \x2E;&violation)
       (&warning import . \x2E;&warning)
       (&who import . \x2E;&who)
       (* import . \x2E;*)
       (+ import . \x2E;+)
       (- import . \x2E;-)
       (... import . \x2E;...)
       (/ import . \x2E;/)
       (< import . \x2E;<)
       (<= import . \x2E;<=)
       (= import . \x2E;=)
       (=> import . \x2E;=>)
       (> import . \x2E;>)
       (>= import . \x2E;>=)
       (_ import . \x2E;_)
       (abs import . \x2E;abs)
       (acos import . \x2E;acos)
       (add-library-path import . \x2E;add-library-path)
       (add-load-path import . \x2E;add-load-path)
       (and import . \x2E;and)
       (angle import . \x2E;angle)
       (append import . \x2E;append)
       (apply import . \x2E;apply)
       (architecture-feature import . \x2E;architecture-feature)
       (asin import . \x2E;asin)
       (assert import . \x2E;assert)
       (assertion-violation import . \x2E;assertion-violation)
       (assertion-violation? import . \x2E;assertion-violation?)
       (assoc import . \x2E;assoc)
       (assp import . core.lists\x27;assp)
       (assq import . \x2E;assq)
       (assv import . \x2E;assv)
       (atan import . \x2E;atan)
       (auto-compile-cache import . \x2E;auto-compile-cache)
       (auto-compile-verbose import . \x2E;auto-compile-verbose)
       (backtrace import . \x2E;backtrace)
       (backtrace-line-length import . \x2E;backtrace-line-length)
       (begin import . \x2E;begin)
       (binary-port? import . core.io\x27;binary-port?)
       (bitwise-and import . \x2E;bitwise-and)
       (bitwise-arithmetic-shift import . \x2E;bitwise-arithmetic-shift)
       (bitwise-arithmetic-shift-left import . core.arithmetic\x27;bitwise-arithmetic-shift-left)
       (bitwise-arithmetic-shift-right import . core.arithmetic\x27;bitwise-arithmetic-shift-right)
       (bitwise-bit-count import . \x2E;bitwise-bit-count)
       (bitwise-bit-field import . core.arithmetic\x27;bitwise-bit-field)
       (bitwise-bit-set? import . core.arithmetic\x27;bitwise-bit-set?)
       (bitwise-copy-bit import . core.arithmetic\x27;bitwise-copy-bit)
       (bitwise-copy-bit-field import . core.arithmetic\x27;bitwise-copy-bit-field)
       (bitwise-first-bit-set import . \x2E;bitwise-first-bit-set)
       (bitwise-if import . core.arithmetic\x27;bitwise-if)
       (bitwise-ior import . \x2E;bitwise-ior)
       (bitwise-length import . \x2E;bitwise-length)
       (bitwise-not import . \x2E;bitwise-not)
       (bitwise-reverse-bit-field import . core.arithmetic\x27;bitwise-reverse-bit-field)
       (bitwise-rotate-bit-field import . core.arithmetic\x27;bitwise-rotate-bit-field)
       (bitwise-xor import . \x2E;bitwise-xor)
       (boolean=? import . \x2E;boolean=?)
       (boolean? import . \x2E;boolean?)
       (bound-identifier=? import . \x2E;bound-identifier=?)
       (break import . core.lists\x27;break)
       (buffer-mode import . core.io\x27;buffer-mode)
       (buffer-mode? import . core.io\x27;buffer-mode?)
       (bytevector->sint-list import . core.bytevectors\x27;bytevector->sint-list)
       (bytevector->string import . core.io\x27;bytevector->string)
       (bytevector->u8-list import . \x2E;bytevector->u8-list)
       (bytevector->uint-list import . core.bytevectors\x27;bytevector->uint-list)
       (bytevector-c-double-ref import . \x2E;bytevector-c-double-ref)
       (bytevector-c-double-set! import . \x2E;bytevector-c-double-set!)
       (bytevector-c-float-ref import . \x2E;bytevector-c-float-ref)
       (bytevector-c-float-set! import . \x2E;bytevector-c-float-set!)
       (bytevector-c-int-ref import . \x2E;bytevector-c-int-ref)
       (bytevector-c-int-set! import . \x2E;bytevector-c-int-set!)
       (bytevector-c-int16-ref import . \x2E;bytevector-c-int16-ref)
       (bytevector-c-int16-set! import . \x2E;bytevector-c-int16-set!)
       (bytevector-c-int32-ref import . \x2E;bytevector-c-int32-ref)
       (bytevector-c-int32-set! import . \x2E;bytevector-c-int32-set!)
       (bytevector-c-int64-ref import . \x2E;bytevector-c-int64-ref)
       (bytevector-c-int64-set! import . \x2E;bytevector-c-int64-set!)
       (bytevector-c-int8-ref import . \x2E;bytevector-c-int8-ref)
       (bytevector-c-int8-set! import . \x2E;bytevector-c-int8-set!)
       (bytevector-c-long-long-ref import . \x2E;bytevector-c-long-long-ref)
       (bytevector-c-long-long-set! import . \x2E;bytevector-c-long-long-set!)
       (bytevector-c-long-ref import . \x2E;bytevector-c-long-ref)
       (bytevector-c-long-set! import . \x2E;bytevector-c-long-set!)
       (bytevector-c-short-ref import . \x2E;bytevector-c-short-ref)
       (bytevector-c-short-set! import . \x2E;bytevector-c-short-set!)
       (bytevector-c-strlen import . \x2E;bytevector-c-strlen)
       (bytevector-c-uint16-ref import . \x2E;bytevector-c-uint16-ref)
       (bytevector-c-uint32-ref import . \x2E;bytevector-c-uint32-ref)
       (bytevector-c-uint64-ref import . \x2E;bytevector-c-uint64-ref)
       (bytevector-c-uint8-ref import . \x2E;bytevector-c-uint8-ref)
       (bytevector-c-unsigned-int-ref import . \x2E;bytevector-c-unsigned-int-ref)
       (bytevector-c-unsigned-long-long-ref import . \x2E;bytevector-c-unsigned-long-long-ref)
       (bytevector-c-unsigned-long-ref import . \x2E;bytevector-c-unsigned-long-ref)
       (bytevector-c-unsigned-short-ref import . \x2E;bytevector-c-unsigned-short-ref)
       (bytevector-c-void*-ref import . \x2E;bytevector-c-void*-ref)
       (bytevector-c-void*-set! import . \x2E;bytevector-c-void*-set!)
       (bytevector-copy import . \x2E;bytevector-copy)
       (bytevector-copy! import . \x2E;bytevector-copy!)
       (bytevector-fill! import . \x2E;bytevector-fill!)
       (bytevector-ieee-double-native-ref import . \x2E;bytevector-ieee-double-native-ref)
       (bytevector-ieee-double-native-set! import . \x2E;bytevector-ieee-double-native-set!)
       (bytevector-ieee-double-ref import . \x2E;bytevector-ieee-double-ref)
       (bytevector-ieee-double-set! import . \x2E;bytevector-ieee-double-set!)
       (bytevector-ieee-single-native-ref import . \x2E;bytevector-ieee-single-native-ref)
       (bytevector-ieee-single-native-set! import . \x2E;bytevector-ieee-single-native-set!)
       (bytevector-ieee-single-ref import . \x2E;bytevector-ieee-single-ref)
       (bytevector-ieee-single-set! import . \x2E;bytevector-ieee-single-set!)
       (bytevector-length import . \x2E;bytevector-length)
       (bytevector-mapping? import . \x2E;bytevector-mapping?)
       (bytevector-s16-native-ref import . \x2E;bytevector-s16-native-ref)
       (bytevector-s16-native-set! import . \x2E;bytevector-s16-native-set!)
       (bytevector-s16-ref import . \x2E;bytevector-s16-ref)
       (bytevector-s16-set! import . \x2E;bytevector-s16-set!)
       (bytevector-s32-native-ref import . \x2E;bytevector-s32-native-ref)
       (bytevector-s32-native-set! import . \x2E;bytevector-s32-native-set!)
       (bytevector-s32-ref import . \x2E;bytevector-s32-ref)
       (bytevector-s32-set! import . \x2E;bytevector-s32-set!)
       (bytevector-s64-native-ref import . \x2E;bytevector-s64-native-ref)
       (bytevector-s64-native-set! import . \x2E;bytevector-s64-native-set!)
       (bytevector-s64-ref import . \x2E;bytevector-s64-ref)
       (bytevector-s64-set! import . \x2E;bytevector-s64-set!)
       (bytevector-s8-ref import . \x2E;bytevector-s8-ref)
       (bytevector-s8-set! import . \x2E;bytevector-s8-set!)
       (bytevector-sint-ref import . core.bytevectors\x27;bytevector-sint-ref)
       (bytevector-sint-set! import . core.bytevectors\x27;bytevector-sint-set!)
       (bytevector-u16-native-ref import . \x2E;bytevector-u16-native-ref)
       (bytevector-u16-native-set! import . \x2E;bytevector-u16-native-set!)
       (bytevector-u16-ref import . \x2E;bytevector-u16-ref)
       (bytevector-u16-set! import . \x2E;bytevector-u16-set!)
       (bytevector-u32-native-ref import . \x2E;bytevector-u32-native-ref)
       (bytevector-u32-native-set! import . \x2E;bytevector-u32-native-set!)
       (bytevector-u32-ref import . \x2E;bytevector-u32-ref)
       (bytevector-u32-set! import . \x2E;bytevector-u32-set!)
       (bytevector-u64-native-ref import . \x2E;bytevector-u64-native-ref)
       (bytevector-u64-native-set! import . \x2E;bytevector-u64-native-set!)
       (bytevector-u64-ref import . \x2E;bytevector-u64-ref)
       (bytevector-u64-set! import . \x2E;bytevector-u64-set!)
       (bytevector-u8-ref import . \x2E;bytevector-u8-ref)
       (bytevector-u8-set! import . \x2E;bytevector-u8-set!)
       (bytevector-uint-ref import . core.bytevectors\x27;bytevector-uint-ref)
       (bytevector-uint-set! import . core.bytevectors\x27;bytevector-uint-set!)
       (bytevector=? import . \x2E;bytevector=?)
       (bytevector? import . \x2E;bytevector?)
       (caaaar import . \x2E;caaaar)
       (caaadr import . \x2E;caaadr)
       (caaar import . \x2E;caaar)
       (caadar import . \x2E;caadar)
       (caaddr import . \x2E;caaddr)
       (caadr import . \x2E;caadr)
       (caar import . \x2E;caar)
       (cadaar import . \x2E;cadaar)
       (cadadr import . \x2E;cadadr)
       (cadar import . \x2E;cadar)
       (caddar import . \x2E;caddar)
       (cadddr import . \x2E;cadddr)
       (caddr import . \x2E;caddr)
       (cadr import . \x2E;cadr)
       (call-with-bytevector-output-port import . core.io\x27;call-with-bytevector-output-port)
       (call-with-current-continuation import . \x2E;call-with-current-continuation)
       (call-with-input-file import . core.io\x27;call-with-input-file)
       (call-with-output-file import . core.io\x27;call-with-output-file)
       (call-with-port import . \x2E;call-with-port)
       (call-with-string-output-port import . core.io\x27;call-with-string-output-port)
       (call-with-values import . \x2E;call-with-values)
       (call/cc import . \x2E;call/cc)
       (car import . \x2E;car)
       (case import . \x2E;case)
       (case-lambda import . core.control\x27;case-lambda)
       (cdaaar import . \x2E;cdaaar)
       (cdaadr import . \x2E;cdaadr)
       (cdaar import . \x2E;cdaar)
       (cdadar import . \x2E;cdadar)
       (cdaddr import . \x2E;cdaddr)
       (cdadr import . \x2E;cdadr)
       (cdar import . \x2E;cdar)
       (cddaar import . \x2E;cddaar)
       (cddadr import . \x2E;cddadr)
       (cddar import . \x2E;cddar)
       (cdddar import . \x2E;cdddar)
       (cddddr import . \x2E;cddddr)
       (cdddr import . \x2E;cdddr)
       (cddr import . \x2E;cddr)
       (cdr import . \x2E;cdr)
       (ceiling import . \x2E;ceiling)
       (change-file-mode import . \x2E;change-file-mode)
       (char->integer import . \x2E;char->integer)
       (char-alphabetic? import . core.unicode\x27;char-alphabetic?)
       (char-ci<=? import . core.unicode\x27;char-ci<=?)
       (char-ci<? import . core.unicode\x27;char-ci<?)
       (char-ci=? import . core.unicode\x27;char-ci=?)
       (char-ci>=? import . core.unicode\x27;char-ci>=?)
       (char-ci>? import . core.unicode\x27;char-ci>?)
       (char-downcase import . core.unicode\x27;char-downcase)
       (char-foldcase import . core.unicode\x27;char-foldcase)
       (char-general-category import . core.unicode\x27;char-general-category)
       (char-lower-case? import . core.unicode\x27;char-lower-case?)
       (char-numeric? import . core.unicode\x27;char-numeric?)
       (char-title-case? import . core.unicode\x27;char-title-case?)
       (char-titlecase import . core.unicode\x27;char-titlecase)
       (char-upcase import . core.unicode\x27;char-upcase)
       (char-upper-case? import . core.unicode\x27;char-upper-case?)
       (char-whitespace? import . \x2E;char-whitespace?)
       (char<=? import . \x2E;char<=?)
       (char<? import . \x2E;char<?)
       (char=? import . \x2E;char=?)
       (char>=? import . \x2E;char>=?)
       (char>? import . \x2E;char>?)
       (char? import . \x2E;char?)
       (circular-list? import . \x2E;circular-list?)
       (close-input-port import . core.io\x27;close-input-port)
       (close-output-port import . core.io\x27;close-output-port)
       (close-port import . \x2E;close-port)
       (closure-code import . \x2E;closure-code)
       (cmwc-random-real import . \x2E;cmwc-random-real)
       (cmwc-random-u32 import . \x2E;cmwc-random-u32)
       (collect import . \x2E;collect)
       (collect-notify import . \x2E;collect-notify)
       (collect-stack-notify import . \x2E;collect-stack-notify)
       (collect-trip-bytes import . \x2E;collect-trip-bytes)
       (command-line import . \x2E;command-line)
       (command-line-shift import . \x2E;command-line-shift)
       (compile import . \x2E;compile)
       (compile-coreform import . \x2E;compile-coreform)
       (complex? import . \x2E;complex?)
       (cond import . \x2E;cond)
       (condition import . \x2E;condition)
       (condition-accessor import . \x2E;condition-accessor)
       (condition-irritants import . \x2E;condition-irritants)
       (condition-message import . \x2E;condition-message)
       (condition-predicate import . \x2E;condition-predicate)
       (condition-who import . \x2E;condition-who)
       (condition? import . \x2E;condition?)
       (cons import . \x2E;cons)
       (cons* import . \x2E;cons*)
       (copy-environment-macros! import . \x2E;copy-environment-macros!)
       (copy-environment-variables! import . \x2E;copy-environment-variables!)
       (core-eval import . \x2E;core-eval)
       (core-hashtable->alist import . \x2E;core-hashtable->alist)
       (core-hashtable-clear! import . \x2E;core-hashtable-clear!)
       (core-hashtable-contains? import . \x2E;core-hashtable-contains?)
       (core-hashtable-copy import . \x2E;core-hashtable-copy)
       (core-hashtable-delete! import . \x2E;core-hashtable-delete!)
       (core-hashtable-equivalence-function import . \x2E;core-hashtable-equivalence-function)
       (core-hashtable-hash-function import . \x2E;core-hashtable-hash-function)
       (core-hashtable-mutable? import . \x2E;core-hashtable-mutable?)
       (core-hashtable-ref import . \x2E;core-hashtable-ref)
       (core-hashtable-set! import . \x2E;core-hashtable-set!)
       (core-hashtable-size import . \x2E;core-hashtable-size)
       (core-hashtable? import . \x2E;core-hashtable?)
       (core-read import . \x2E;core-read)
       (coreform-optimize import . core.optimize\x27;coreform-optimize)
       (cos import . \x2E;cos)
       (create-directory import . \x2E;create-directory)
       (create-hard-link import . \x2E;create-hard-link)
       (create-symbolic-link import . \x2E;create-symbolic-link)
       (current-after-expansion-hook import . \x2E;current-after-expansion-hook)
       (current-directory import . \x2E;current-directory)
       (current-dynamic-environment import . \x2E;current-dynamic-environment)
       (current-environment import . \x2E;current-environment)
       (current-error-port import . \x2E;current-error-port)
       (current-exception-printer import . \x2E;current-exception-printer)
       (current-input-port import . \x2E;current-input-port)
       (current-library-infix import . \x2E;current-library-infix)
       (current-library-suffix import . \x2E;current-library-suffix)
       (current-macro-environment import . \x2E;current-macro-environment)
       (current-output-port import . \x2E;current-output-port)
       (current-primitive-prefix import . \x2E;current-primitive-prefix)
       (current-rename-delimiter import . \x2E;current-rename-delimiter)
       (current-source-comments import . \x2E;current-source-comments)
       (current-variable-environment import . \x2E;current-variable-environment)
       (cyclic-object? import . \x2E;cyclic-object?)
       (datum import . core.syntax-case\x27;datum)
       (datum->syntax import . \x2E;datum->syntax)
       (decode-flonum import . \x2E;decode-flonum)
       (decode-microsecond import . \x2E;decode-microsecond)
       (define import . \x2E;define)
       (define-condition-type import . core.conditions\x27;define-condition-type)
       (define-enumeration import . core.enums\x27;define-enumeration)
       (define-macro import . core.syntax-case\x27;define-macro)
       (define-record-type import . core.records\x27;define-record-type)
       (define-struct import . core.struct\x27;define-struct)
       (define-syntax import . \x2E;define-syntax)
       (delay import . core.r5rs\x27;delay)
       (delete-file import . \x2E;delete-file)
       (denominator import . \x2E;denominator)
       (destructuring-bind import . core.destructuring\x27;destructuring-bind)
       (destructuring-match import . core.destructuring\x27;destructuring-match)
       (directory-list import . \x2E;directory-list)
       (display import . \x2E;display)
       (display-backtrace import . \x2E;display-backtrace)
       (display-heap-statistics import . \x2E;display-heap-statistics)
       (display-object-statistics import . \x2E;display-object-statistics)
       (display-thread-status import . \x2E;display-thread-status)
       (div import . \x2E;div)
       (div-and-mod import . \x2E;div-and-mod)
       (div0 import . \x2E;div0)
       (div0-and-mod0 import . \x2E;div0-and-mod0)
       (do import . \x2E;do)
       (drop import . core.lists\x27;drop)
       (dynamic-wind import . \x2E;dynamic-wind)
       (else import . \x2E;else)
       (encode-microsecond import . \x2E;encode-microsecond)
       (endianness import . core.bytevectors\x27;endianness)
       (enum-set->list import . core.enums\x27;enum-set->list)
       (enum-set-complement import . core.enums\x27;enum-set-complement)
       (enum-set-constructor import . core.enums\x27;enum-set-constructor)
       (enum-set-difference import . core.enums\x27;enum-set-difference)
       (enum-set-indexer import . core.enums\x27;enum-set-indexer)
       (enum-set-intersection import . core.enums\x27;enum-set-intersection)
       (enum-set-member? import . core.enums\x27;enum-set-member?)
       (enum-set-projection import . core.enums\x27;enum-set-projection)
       (enum-set-subset? import . core.enums\x27;enum-set-subset?)
       (enum-set-union import . core.enums\x27;enum-set-union)
       (enum-set-universe import . core.enums\x27;enum-set-universe)
       (enum-set=? import . core.enums\x27;enum-set=?)
       (enum-set? import . core.enums\x27;enum-set?)
       (environment import . \x2E;environment)
       (eof-object import . \x2E;eof-object)
       (eof-object? import . \x2E;eof-object?)
       (eol-style import . core.io\x27;eol-style)
       (eq? import . \x2E;eq?)
       (equal-hash import . \x2E;equal-hash)
       (equal? import . \x2E;equal?)
       (eqv? import . \x2E;eqv?)
       (error import . \x2E;error)
       (error-handling-mode import . core.io\x27;error-handling-mode)
       (error? import . \x2E;error?)
       (eval import . \x2E;eval)
       (even? import . \x2E;even?)
       (exact import . \x2E;exact)
       (exact->inexact import . \x2E;inexact)
       (exact-integer-sqrt import . \x2E;exact-integer-sqrt)
       (exact? import . \x2E;exact?)
       (exists import . core.lists\x27;exists)
       (exit import . \x2E;exit)
       (exp import . \x2E;exp)
       (expansion-backtrace import . \x2E;expansion-backtrace)
       (expt import . \x2E;expt)
       (extract-accumulated-bytevector import . \x2E;extract-accumulated-bytevector)
       (extract-accumulated-string import . \x2E;extract-accumulated-string)
       (fields import . core.records\x27;fields)
       (file-directory? import . \x2E;file-directory?)
       (file-executable? import . \x2E;file-executable?)
       (file-exists? import . \x2E;file-exists?)
       (file-options import . core.io\x27;file-options)
       (file-readable? import . \x2E;file-readable?)
       (file-regular? import . \x2E;file-regular?)
       (file-size-in-bytes import . \x2E;file-size-in-bytes)
       (file-stat-atime import . \x2E;file-stat-atime)
       (file-stat-ctime import . \x2E;file-stat-ctime)
       (file-stat-mtime import . \x2E;file-stat-mtime)
       (file-symbolic-link? import . \x2E;file-symbolic-link?)
       (file-writable? import . \x2E;file-writable?)
       (filter import . core.lists\x27;filter)
       (find import . core.lists\x27;find)
       (finite? import . \x2E;finite?)
       (fixnum->flonum import . \x2E;fixnum->flonum)
       (fixnum-width import . \x2E;fixnum-width)
       (fixnum? import . \x2E;fixnum?)
       (fl* import . \x2E;fl*)
       (fl+ import . \x2E;fl+)
       (fl- import . \x2E;fl-)
       (fl/ import . \x2E;fl/)
       (fl<=? import . \x2E;fl<=?)
       (fl<? import . \x2E;fl<?)
       (fl=? import . \x2E;fl=?)
       (fl>=? import . \x2E;fl>=?)
       (fl>? import . \x2E;fl>?)
       (flabs import . \x2E;flabs)
       (flacos import . \x2E;flacos)
       (flasin import . \x2E;flasin)
       (flatan import . \x2E;flatan)
       (flceiling import . \x2E;flceiling)
       (flcos import . \x2E;flcos)
       (fldenominator import . \x2E;fldenominator)
       (fldiv import . \x2E;fldiv)
       (fldiv-and-mod import . core.arithmetic\x27;fldiv-and-mod)
       (fldiv0 import . \x2E;fldiv0)
       (fldiv0-and-mod0 import . core.arithmetic\x27;fldiv0-and-mod0)
       (fleven? import . \x2E;fleven?)
       (flexp import . \x2E;flexp)
       (flexpt import . \x2E;flexpt)
       (flfinite? import . \x2E;flfinite?)
       (flfloor import . \x2E;flfloor)
       (flinfinite? import . \x2E;flinfinite?)
       (flinteger? import . \x2E;flinteger?)
       (fllog import . \x2E;fllog)
       (flmax import . \x2E;flmax)
       (flmin import . \x2E;flmin)
       (flmod import . core.arithmetic\x27;flmod)
       (flmod0 import . core.arithmetic\x27;flmod0)
       (flnan? import . \x2E;flnan?)
       (flnegative? import . \x2E;flnegative?)
       (flnumerator import . \x2E;flnumerator)
       (flodd? import . \x2E;flodd?)
       (flonum? import . \x2E;flonum?)
       (floor import . \x2E;floor)
       (flpositive? import . \x2E;flpositive?)
       (flround import . \x2E;flround)
       (flsin import . \x2E;flsin)
       (flsqrt import . \x2E;flsqrt)
       (fltan import . \x2E;fltan)
       (fltruncate import . \x2E;fltruncate)
       (flush-output-port import . \x2E;flush-output-port)
       (flzero? import . \x2E;flzero?)
       (fold-left import . core.lists\x27;fold-left)
       (fold-right import . core.lists\x27;fold-right)
       (for-all import . core.lists\x27;for-all)
       (for-each import . \x2E;for-each)
       (force import . core.r5rs\x27;force)
       (format import . \x2E;format)
       (free-identifier=? import . \x2E;free-identifier=?)
       (fx* import . \x2E;fx*)
       (fx*/carry import . core.arithmetic\x27;fx*/carry)
       (fx+ import . \x2E;fx+)
       (fx+/carry import . core.arithmetic\x27;fx+/carry)
       (fx- import . \x2E;fx-)
       (fx-/carry import . core.arithmetic\x27;fx-/carry)
       (fx<=? import . \x2E;fx<=?)
       (fx<? import . \x2E;fx<?)
       (fx=? import . \x2E;fx=?)
       (fx>=? import . \x2E;fx>=?)
       (fx>? import . \x2E;fx>?)
       (fxand import . \x2E;fxand)
       (fxarithmetic-shift import . \x2E;fxarithmetic-shift)
       (fxarithmetic-shift-left import . \x2E;fxarithmetic-shift-left)
       (fxarithmetic-shift-right import . \x2E;fxarithmetic-shift-right)
       (fxbit-count import . \x2E;fxbit-count)
       (fxbit-field import . \x2E;fxbit-field)
       (fxbit-set? import . \x2E;fxbit-set?)
       (fxcopy-bit import . \x2E;fxcopy-bit)
       (fxcopy-bit-field import . \x2E;fxcopy-bit-field)
       (fxdiv import . \x2E;fxdiv)
       (fxdiv-and-mod import . core.arithmetic\x27;fxdiv-and-mod)
       (fxdiv0 import . \x2E;fxdiv0)
       (fxdiv0-and-mod0 import . core.arithmetic\x27;fxdiv0-and-mod0)
       (fxeven? import . \x2E;fxeven?)
       (fxfirst-bit-set import . \x2E;fxfirst-bit-set)
       (fxif import . \x2E;fxif)
       (fxior import . \x2E;fxior)
       (fxlength import . \x2E;fxlength)
       (fxmax import . \x2E;fxmax)
       (fxmin import . \x2E;fxmin)
       (fxmod import . core.arithmetic\x27;fxmod)
       (fxmod0 import . core.arithmetic\x27;fxmod0)
       (fxnegative? import . \x2E;fxnegative?)
       (fxnot import . \x2E;fxnot)
       (fxodd? import . \x2E;fxodd?)
       (fxpositive? import . \x2E;fxpositive?)
       (fxreverse-bit-field import . core.arithmetic\x27;fxreverse-bit-field)
       (fxrotate-bit-field import . core.arithmetic\x27;fxrotate-bit-field)
       (fxxor import . \x2E;fxxor)
       (fxzero? import . \x2E;fxzero?)
       (gcd import . \x2E;gcd)
       (generate-temporaries import . \x2E;generate-temporaries)
       (generate-temporary-symbol import . \x2E;generate-temporary-symbol)
       (gensym import . \x2E;gensym)
       (get-accumulated-string import . \x2E;get-accumulated-string)
       (get-bytevector-all import . \x2E;get-bytevector-all)
       (get-bytevector-n import . \x2E;get-bytevector-n)
       (get-bytevector-n! import . \x2E;get-bytevector-n!)
       (get-bytevector-some import . \x2E;get-bytevector-some)
       (get-char import . \x2E;get-char)
       (get-datum import . \x2E;get-datum)
       (get-line import . \x2E;get-line)
       (get-string-all import . \x2E;get-string-all)
       (get-string-n import . \x2E;get-string-n)
       (get-string-n! import . \x2E;get-string-n!)
       (get-u8 import . \x2E;get-u8)
       (getenv import . \x2E;getenv)
       (gethostname import . \x2E;gethostname)
       (greatest-fixnum import . \x2E;greatest-fixnum)
       (guard import . core.exceptions\x27;guard)
       (hashtable->alist import . \x2E;core-hashtable->alist)
       (hashtable-clear! import . \x2E;core-hashtable-clear!)
       (hashtable-contains? import . \x2E;core-hashtable-contains?)
       (hashtable-copy import . \x2E;core-hashtable-copy)
       (hashtable-delete! import . \x2E;core-hashtable-delete!)
       (hashtable-entries import . core.hashtables\x27;hashtable-entries)
       (hashtable-equivalence-function import . \x2E;core-hashtable-equivalence-function)
       (hashtable-hash-function import . \x2E;core-hashtable-hash-function)
       (hashtable-keys import . core.hashtables\x27;hashtable-keys)
       (hashtable-mutable? import . \x2E;core-hashtable-mutable?)
       (hashtable-ref import . \x2E;core-hashtable-ref)
       (hashtable-set! import . \x2E;core-hashtable-set!)
       (hashtable-size import . \x2E;core-hashtable-size)
       (hashtable-update! import . core.hashtables\x27;hashtable-update!)
       (hashtable? import . \x2E;core-hashtable?)
       (home-directory import . \x2E;home-directory)
       (i/o-decoding-error? import . \x2E;i/o-decoding-error?)
       (i/o-encoding-error-char import . \x2E;i/o-encoding-error-char)
       (i/o-encoding-error? import . \x2E;i/o-encoding-error?)
       (i/o-error-filename import . \x2E;i/o-error-filename)
       (i/o-error-port import . \x2E;i/o-error-port)
       (i/o-error-position import . \x2E;i/o-error-position)
       (i/o-error? import . \x2E;i/o-error?)
       (i/o-file-already-exists-error? import . \x2E;i/o-file-already-exists-error?)
       (i/o-file-does-not-exist-error? import . \x2E;i/o-file-does-not-exist-error?)
       (i/o-file-is-read-only-error? import . \x2E;i/o-file-is-read-only-error?)
       (i/o-file-protection-error? import . \x2E;i/o-file-protection-error?)
       (i/o-filename-error? import . \x2E;i/o-filename-error?)
       (i/o-invalid-position-error? import . \x2E;i/o-invalid-position-error?)
       (i/o-port-error? import . \x2E;i/o-port-error?)
       (i/o-read-error? import . \x2E;i/o-read-error?)
       (i/o-write-error? import . \x2E;i/o-write-error?)
       (identifier-syntax import . \x2E;identifier-syntax)
       (identifier? import . \x2E;identifier?)
       (if import . \x2E;if)
       (imag-part import . \x2E;imag-part)
       (immutable import . core.records\x27;immutable)
       (implementation-restriction-violation? import . \x2E;implementation-restriction-violation?)
       (inexact import . \x2E;inexact)
       (inexact->exact import . \x2E;exact)
       (inexact? import . \x2E;inexact?)
       (infinite? import . \x2E;infinite?)
       (input-port? import . \x2E;input-port?)
       (integer->char import . \x2E;integer->char)
       (integer-valued? import . \x2E;integer-valued?)
       (integer? import . \x2E;integer?)
       (interaction-environment import . \x2E;interaction-environment)
       (iota import . core.lists\x27;iota)
       (irritants-condition? import . \x2E;irritants-condition?)
       (lambda import . \x2E;lambda)
       (latin-1-codec import . core.io\x27;latin-1-codec)
       (lcm import . \x2E;lcm)
       (least-fixnum import . \x2E;least-fixnum)
       (length import . \x2E;length)
       (let import . \x2E;let)
       (let* import . \x2E;let*)
       (let*-values import . \x2E;let*-values)
       (let-optionals import . core.optargs\x27;let-optionals)
       (let-syntax import . \x2E;let-syntax)
       (let-values import . \x2E;let-values)
       (letrec import . \x2E;letrec)
       (letrec* import . \x2E;letrec*)
       (letrec-syntax import . \x2E;letrec-syntax)
       (lexical-violation? import . \x2E;lexical-violation?)
       (library import . \x2E;library)
       (library-extensions import . \x2E;library-extensions)
       (list import . \x2E;list)
       (list->string import . \x2E;list->string)
       (list->vector import . \x2E;list->vector)
       (list-copy import . \x2E;list-copy)
       (list-head import . \x2E;list-head)
       (list-of-unique-symbols? import . core.lists\x27;list-of-unique-symbols?)
       (list-ref import . \x2E;list-ref)
       (list-sort import . core.sorting\x27;list-sort)
       (list-tail import . \x2E;list-tail)
       (list-transpose import . \x2E;list-transpose)
       (list-transpose* import . \x2E;list-transpose*)
       (list-transpose+ import . \x2E;list-transpose+)
       (list? import . \x2E;list?)
       (load import . \x2E;load)
       (local-heap-object? import . \x2E;local-heap-object?)
       (log import . \x2E;log)
       (lookahead-char import . \x2E;lookahead-char)
       (lookahead-u8 import . \x2E;lookahead-u8)
       (lookup-process-environment import . \x2E;lookup-process-environment)
       (macro-expand import . \x2E;macro-expand)
       (magnitude import . \x2E;magnitude)
       (make-assertion-violation import . \x2E;make-assertion-violation)
       (make-bytevector import . \x2E;make-bytevector)
       (make-bytevector-mapping import . \x2E;make-bytevector-mapping)
       (make-cmwc-random-state import . \x2E;make-cmwc-random-state)
       (make-core-hashtable import . \x2E;make-core-hashtable)
       (make-custom-binary-input-port import . core.io\x27;make-custom-binary-input-port)
       (make-custom-binary-input/output-port
         import
         .
         core.io\x27;make-custom-binary-input/output-port)
       (make-custom-binary-output-port import . core.io\x27;make-custom-binary-output-port)
       (make-custom-textual-input-port import . core.io\x27;make-custom-textual-input-port)
       (make-custom-textual-input/output-port
         import
         .
         core.io\x27;make-custom-textual-input/output-port)
       (make-custom-textual-output-port import . core.io\x27;make-custom-textual-output-port)
       (make-enumeration import . core.enums\x27;make-enumeration)
       (make-environment import . \x2E;make-environment)
       (make-eq-hashtable import . core.hashtables\x27;make-eq-hashtable)
       (make-eqv-hashtable import . core.hashtables\x27;make-eqv-hashtable)
       (make-error import . \x2E;make-error)
       (make-hashtable import . core.hashtables\x27;make-hashtable)
       (make-i/o-decoding-error import . \x2E;make-i/o-decoding-error)
       (make-i/o-encoding-error import . \x2E;make-i/o-encoding-error)
       (make-i/o-error import . \x2E;make-i/o-error)
       (make-i/o-file-already-exists-error import . \x2E;make-i/o-file-already-exists-error)
       (make-i/o-file-does-not-exist-error import . \x2E;make-i/o-file-does-not-exist-error)
       (make-i/o-file-is-read-only-error import . \x2E;make-i/o-file-is-read-only-error)
       (make-i/o-file-protection-error import . \x2E;make-i/o-file-protection-error)
       (make-i/o-filename-error import . \x2E;make-i/o-filename-error)
       (make-i/o-invalid-position-error import . \x2E;make-i/o-invalid-position-error)
       (make-i/o-port-error import . \x2E;make-i/o-port-error)
       (make-i/o-read-error import . \x2E;make-i/o-read-error)
       (make-i/o-write-error import . \x2E;make-i/o-write-error)
       (make-implementation-restriction-violation
         import
         .
         \x2E;make-implementation-restriction-violation)
       (make-irritants-condition import . \x2E;make-irritants-condition)
       (make-lexical-violation import . \x2E;make-lexical-violation)
       (make-list import . core.lists\x27;make-list)
       (make-message-condition import . \x2E;make-message-condition)
       (make-no-infinities-violation import . \x2E;make-no-infinities-violation)
       (make-no-nans-violation import . \x2E;make-no-nans-violation)
       (make-non-continuable-violation import . \x2E;make-non-continuable-violation)
       (make-parameter import . \x2E;make-parameter)
       (make-polar import . \x2E;make-polar)
       (make-record-constructor-descriptor import . \x2E;make-record-constructor-descriptor)
       (make-record-type import . \x2E;make-record-type)
       (make-record-type-descriptor import . \x2E;make-record-type-descriptor)
       (make-rectangular import . \x2E;make-rectangular)
       (make-serious-condition import . \x2E;make-serious-condition)
       (make-shared-bag import . \x2E;make-shared-bag)
       (make-shared-core-hashtable import . \x2E;make-shared-core-hashtable)
       (make-shared-queue import . \x2E;make-shared-queue)
       (make-socket import . \x2E;make-socket)
       (make-string import . \x2E;make-string)
       (make-string-hashtable import . core.hashtables\x27;make-string-hashtable)
       (make-string-input-port import . \x2E;make-string-input-port)
       (make-string-output-port import . \x2E;make-string-output-port)
       (make-syntax-violation import . \x2E;make-syntax-violation)
       (make-temporary-file-port import . \x2E;make-temporary-file-port)
       (make-transcoded-port import . \x2E;make-transcoded-port)
       (make-transcoder import . core.io\x27;make-transcoder)
       (make-tuple import . \x2E;make-tuple)
       (make-undefined-violation import . \x2E;make-undefined-violation)
       (make-uuid import . \x2E;make-uuid)
       (make-variable-transformer import . \x2E;make-variable-transformer)
       (make-vector import . \x2E;make-vector)
       (make-violation import . \x2E;make-violation)
       (make-warning import . \x2E;make-warning)
       (make-weak-core-hashtable import . \x2E;make-weak-core-hashtable)
       (make-weak-hashtable import . \x2E;make-weak-shared-core-hashtable)
       (make-weak-mapping import . \x2E;make-weak-mapping)
       (make-weak-shared-core-hashtable import . \x2E;make-weak-shared-core-hashtable)
       (make-who-condition import . \x2E;make-who-condition)
       (map import . \x2E;map)
       (max import . \x2E;max)
       (member import . \x2E;member)
       (memp import . core.lists\x27;memp)
       (memq import . \x2E;memq)
       (memv import . \x2E;memv)
       (message-condition? import . \x2E;message-condition?)
       (microsecond import . \x2E;microsecond)
       (microsecond->string import . \x2E;microsecond->string)
       (microsecond->utc import . \x2E;microsecond->utc)
       (min import . \x2E;min)
       (mod import . \x2E;mod)
       (mod0 import . \x2E;mod0)
       (modulo import . \x2E;modulo)
       (mutable import . core.records\x27;mutable)
       (nan? import . \x2E;nan?)
       (native-endianness import . \x2E;native-endianness)
       (native-eol-style import . core.io\x27;native-eol-style)
       (native-transcoder import . core.io\x27;native-transcoder)
       (native-transcoder-descriptor import . \x2E;native-transcoder-descriptor)
       (negative? import . \x2E;negative?)
       (newline import . \x2E;newline)
       (no-infinities-violation? import . \x2E;no-infinities-violation?)
       (no-nans-violation? import . \x2E;no-nans-violation?)
       (non-continuable-violation? import . \x2E;non-continuable-violation?)
       (nonblock-byte-ready? import . \x2E;nonblock-byte-ready?)
       (nongenerative import . core.records\x27;nongenerative)
       (not import . \x2E;not)
       (null? import . \x2E;null?)
       (number->string import . \x2E;number->string)
       (number? import . \x2E;number?)
       (numerator import . \x2E;numerator)
       (odd? import . \x2E;odd?)
       (on-primordial-thread? import . \x2E;on-primordial-thread?)
       (opaque import . core.records\x27;opaque)
       (open-builtin-data-input-port import . \x2E;open-builtin-data-input-port)
       (open-bytevector-input-port import . core.io\x27;open-bytevector-input-port)
       (open-bytevector-output-port import . core.io\x27;open-bytevector-output-port)
       (open-file-input-port import . core.io\x27;open-file-input-port)
       (open-file-input/output-port import . core.io\x27;open-file-input/output-port)
       (open-file-output-port import . core.io\x27;open-file-output-port)
       (open-input-file import . core.io\x27;open-input-file)
       (open-output-file import . core.io\x27;open-output-file)
       (open-port import . \x2E;open-port)
       (open-string-input-port import . core.io\x27;open-string-input-port)
       (open-string-output-port import . core.io\x27;open-string-output-port)
       (open-temporary-file-port import . core.io\x27;open-temporary-file-port)
       (or import . \x2E;or)
       (output-port-buffer-mode import . \x2E;output-port-buffer-mode)
       (output-port? import . \x2E;output-port?)
       (pair? import . \x2E;pair?)
       (parameterize import . core.parameters\x27;parameterize)
       (parent import . core.records\x27;parent)
       (parent-rtd import . core.records\x27;parent-rtd)
       (partition import . core.lists\x27;partition)
       (peek-char import . \x2E;peek-char)
       (port-closed? import . \x2E;port-closed?)
       (port-device-subtype import . \x2E;port-device-subtype)
       (port-eof? import . \x2E;port-eof?)
       (port-has-port-position? import . \x2E;port-has-port-position?)
       (port-has-set-port-position!? import . \x2E;port-has-set-port-position!?)
       (port-position import . \x2E;port-position)
       (port-transcoder import . core.io\x27;port-transcoder)
       (port-transcoder-descriptor import . \x2E;port-transcoder-descriptor)
       (port? import . \x2E;port?)
       (positive? import . \x2E;positive?)
       (pretty-print import . \x2E;pretty-print)
       (pretty-print-initial-indent import . \x2E;pretty-print-initial-indent)
       (pretty-print-line-length import . \x2E;pretty-print-line-length)
       (pretty-print-maximum-lines import . \x2E;pretty-print-maximum-lines)
       (pretty-print-unwrap-syntax import . \x2E;pretty-print-unwrap-syntax)
       (procedure? import . \x2E;procedure?)
       (process import . \x2E;process)
       (process-environment->alist import . \x2E;process-environment->alist)
       (process-shell-command import . \x2E;process-shell-command)
       (process-spawn import . \x2E;process-spawn)
       (process-wait import . \x2E;process-wait)
       (protocol import . core.records\x27;protocol)
       (put-byte import . \x2E;put-byte)
       (put-bytevector import . \x2E;put-bytevector)
       (put-char import . \x2E;put-char)
       (put-datum import . \x2E;put-datum)
       (put-string import . \x2E;put-string)
       (put-u8 import . \x2E;put-u8)
       (quasiquote import . \x2E;quasiquote)
       (quasisyntax import . core.syntax-case\x27;quasisyntax)
       (quote import . \x2E;quote)
       (quotient import . \x2E;quotient)
       (raise import . \x2E;raise)
       (raise-continuable import . \x2E;raise-continuable)
       (rational-valued? import . \x2E;rational-valued?)
       (rational? import . \x2E;rational?)
       (rationalize import . \x2E;rationalize)
       (read import . \x2E;read)
       (read-char import . \x2E;read-char)
       (read-with-shared-structure import . \x2E;read-with-shared-structure)
       (real->flonum import . \x2E;real->flonum)
       (real-part import . \x2E;real-part)
       (real-valued? import . \x2E;real-valued?)
       (real? import . \x2E;real?)
       (record-accessor import . \x2E;record-accessor)
       (record-constructor import . \x2E;record-constructor)
       (record-constructor-descriptor import . core.records\x27;record-constructor-descriptor)
       (record-field-mutable? import . \x2E;record-field-mutable?)
       (record-mutator import . \x2E;record-mutator)
       (record-predicate import . \x2E;record-predicate)
       (record-print-nesting-limit import . \x2E;record-print-nesting-limit)
       (record-rtd import . \x2E;record-rtd)
       (record-type-descriptor import . core.records\x27;record-type-descriptor)
       (record-type-descriptor? import . \x2E;record-type-descriptor?)
       (record-type-field-names import . \x2E;record-type-field-names)
       (record-type-generative? import . \x2E;record-type-generative?)
       (record-type-name import . \x2E;record-type-name)
       (record-type-opaque? import . \x2E;record-type-opaque?)
       (record-type-parent import . \x2E;record-type-parent)
       (record-type-rcd import . \x2E;record-type-rcd)
       (record-type-rtd import . \x2E;record-type-rtd)
       (record-type-sealed? import . \x2E;record-type-sealed?)
       (record-type-uid import . \x2E;record-type-uid)
       (record-type? import . \x2E;record-type?)
       (record? import . \x2E;record?)
       (remainder import . \x2E;remainder)
       (remove import . core.lists\x27;remove)
       (remove-duplicate-symbols import . core.lists\x27;remove-duplicate-symbols)
       (remp import . core.lists\x27;remp)
       (remq import . core.lists\x27;remq)
       (remv import . core.lists\x27;remv)
       (rename-file import . \x2E;rename-file)
       (restricted-print-line-length import . \x2E;restricted-print-line-length)
       (reverse import . \x2E;reverse)
       (round import . \x2E;round)
       (scheme-error import . \x2E;scheme-error)
       (scheme-library-exports import . \x2E;scheme-library-exports)
       (scheme-library-paths import . \x2E;scheme-library-paths)
       (scheme-load-paths import . \x2E;scheme-load-paths)
       (scheme-load-verbose import . \x2E;scheme-load-verbose)
       (sealed import . core.records\x27;sealed)
       (serializable? import . \x2E;serializable?)
       (serious-condition? import . \x2E;serious-condition?)
       (set! import . \x2E;set!)
       (set-car! import . \x2E;set-car!)
       (set-cdr! import . \x2E;set-cdr!)
       (set-current-error-port! import . \x2E;set-current-error-port!)
       (set-current-input-port! import . \x2E;set-current-input-port!)
       (set-current-output-port! import . \x2E;set-current-output-port!)
       (set-port-position! import . \x2E;set-port-position!)
       (set-top-level-value! import . \x2E;set-top-level-value!)
       (shared-bag-get! import . \x2E;shared-bag-get!)
       (shared-bag-put! import . \x2E;shared-bag-put!)
       (shared-bag? import . \x2E;shared-bag?)
       (shared-queue-pop! import . \x2E;shared-queue-pop!)
       (shared-queue-push! import . \x2E;shared-queue-push!)
       (shared-queue-shutdown import . \x2E;shared-queue-shutdown)
       (shared-queue? import . \x2E;shared-queue?)
       (shutdown-object? import . \x2E;shutdown-object?)
       (shutdown-output-port import . \x2E;shutdown-output-port)
       (simple-conditions import . \x2E;simple-conditions)
       (sin import . \x2E;sin)
       (sint-list->bytevector import . core.bytevectors\x27;sint-list->bytevector)
       (socket->port import . \x2E;socket->port)
       (socket-accept import . \x2E;socket-accept)
       (socket-close import . \x2E;socket-close)
       (socket-port import . \x2E;socket-port)
       (socket-recv import . \x2E;socket-recv)
       (socket-send import . \x2E;socket-send)
       (socket-shutdown import . \x2E;socket-shutdown)
       (socket? import . \x2E;socket?)
       (spawn import . \x2E;spawn)
       (spawn-heap-limit import . \x2E;spawn-heap-limit)
       (spawn-timeout import . \x2E;spawn-timeout)
       (sqrt import . \x2E;sqrt)
       (standard-error-port import . \x2E;standard-error-port)
       (standard-input-port import . \x2E;standard-input-port)
       (standard-output-port import . \x2E;standard-output-port)
       (string import . \x2E;string)
       (string->bytevector import . core.io\x27;string->bytevector)
       (string->list import . \x2E;string->list)
       (string->number import . \x2E;string->number)
       (string->symbol import . \x2E;string->symbol)
       (string->uninterned-symbol import . \x2E;string->uninterned-symbol)
       (string->utf16 import . core.bytevector-transcoders\x27;string->utf16)
       (string->utf32 import . core.bytevector-transcoders\x27;string->utf32)
       (string->utf8 import . \x2E;string->utf8)
       (string->utf8/nul import . \x2E;string->utf8/nul)
       (string-append import . \x2E;string-append)
       (string-ci-hash import . core.hashtables\x27;string-ci-hash)
       (string-ci<=? import . core.unicode\x27;string-ci<=?)
       (string-ci<? import . core.unicode\x27;string-ci<?)
       (string-ci=? import . core.unicode\x27;string-ci=?)
       (string-ci>=? import . core.unicode\x27;string-ci>=?)
       (string-ci>? import . core.unicode\x27;string-ci>?)
       (string-contains import . \x2E;string-contains)
       (string-copy import . \x2E;string-copy)
       (string-downcase import . core.unicode\x27;string-downcase)
       (string-fill! import . \x2E;string-fill!)
       (string-foldcase import . core.unicode\x27;string-foldcase)
       (string-for-each import . \x2E;string-for-each)
       (string-hash import . \x2E;string-hash)
       (string-length import . \x2E;string-length)
       (string-normalize-nfc import . core.unicode\x27;string-normalize-nfc)
       (string-normalize-nfd import . core.unicode\x27;string-normalize-nfd)
       (string-normalize-nfkc import . core.unicode\x27;string-normalize-nfkc)
       (string-normalize-nfkd import . core.unicode\x27;string-normalize-nfkd)
       (string-ref import . \x2E;string-ref)
       (string-set! import . \x2E;string-set!)
       (string-titlecase import . core.unicode\x27;string-titlecase)
       (string-upcase import . core.unicode\x27;string-upcase)
       (string<=? import . \x2E;string<=?)
       (string<? import . \x2E;string<?)
       (string=? import . \x2E;string=?)
       (string>=? import . \x2E;string>=?)
       (string>? import . \x2E;string>?)
       (string? import . \x2E;string?)
       (subr? import . \x2E;subr?)
       (substring import . \x2E;substring)
       (symbol->string import . \x2E;symbol->string)
       (symbol-contains import . \x2E;symbol-contains)
       (symbol-hash import . \x2E;symbol-hash)
       (symbol=? import . \x2E;symbol=?)
       (symbol? import . \x2E;symbol?)
       (syntax import . \x2E;syntax)
       (syntax->datum import . \x2E;syntax->datum)
       (syntax-case import . \x2E;syntax-case)
       (syntax-rules import . \x2E;syntax-rules)
       (syntax-violation import . \x2E;syntax-violation)
       (syntax-violation-form import . \x2E;syntax-violation-form)
       (syntax-violation-subform import . \x2E;syntax-violation-subform)
       (syntax-violation? import . \x2E;syntax-violation?)
       (system import . \x2E;system)
       (system-environment import . \x2E;system-environment)
       (system-extension-path import . \x2E;system-extension-path)
       (system-share-path import . \x2E;system-share-path)
       (take import . core.lists\x27;take)
       (tan import . \x2E;tan)
       (textual-port? import . core.io\x27;textual-port?)
       (time-usage import . \x2E;time-usage)
       (timeout-object? import . \x2E;timeout-object?)
       (top-level-bound? import . \x2E;top-level-bound?)
       (top-level-value import . \x2E;top-level-value)
       (track-file-open import . \x2E;track-file-open)
       (transcoded-port import . core.io\x27;transcoded-port)
       (transcoder-codec import . core.io\x27;transcoder-codec)
       (transcoder-eol-style import . core.io\x27;transcoder-eol-style)
       (transcoder-error-handling-mode import . core.io\x27;transcoder-error-handling-mode)
       (truncate import . \x2E;truncate)
       (tuple import . \x2E;tuple)
       (tuple->list import . \x2E;tuple->list)
       (tuple-index import . \x2E;tuple-index)
       (tuple-length import . \x2E;tuple-length)
       (tuple-ref import . \x2E;tuple-ref)
       (tuple-set! import . \x2E;tuple-set!)
       (tuple? import . \x2E;tuple?)
       (u8-list->bytevector import . \x2E;u8-list->bytevector)
       (uint-list->bytevector import . core.bytevectors\x27;uint-list->bytevector)
       (undefined-violation? import . \x2E;undefined-violation?)
       (uninterned-symbol-prefix import . \x2E;uninterned-symbol-prefix)
       (uninterned-symbol-suffix import . \x2E;uninterned-symbol-suffix)
       (uninterned-symbol? import . \x2E;uninterned-symbol?)
       (unless import . core.control\x27;unless)
       (unquote import . \x2E;unquote)
       (unquote-splicing import . \x2E;unquote-splicing)
       (unspecified import . \x2E;unspecified)
       (unspecified? import . \x2E;unspecified?)
       (unsyntax import . core.syntax-case\x27;unsyntax)
       (unsyntax-splicing import . core.syntax-case\x27;unsyntax-splicing)
       (usleep import . \x2E;usleep)
       (utf-16-codec import . core.io\x27;utf-16-codec)
       (utf-8-codec import . core.io\x27;utf-8-codec)
       (utf16->string import . core.bytevector-transcoders\x27;utf16->string)
       (utf32->string import . core.bytevector-transcoders\x27;utf32->string)
       (utf8->string import . \x2E;utf8->string)
       (values import . \x2E;values)
       (vector import . \x2E;vector)
       (vector->list import . \x2E;vector->list)
       (vector-copy import . \x2E;vector-copy)
       (vector-fill! import . \x2E;vector-fill!)
       (vector-for-each import . \x2E;vector-for-each)
       (vector-length import . \x2E;vector-length)
       (vector-map import . \x2E;vector-map)
       (vector-ref import . \x2E;vector-ref)
       (vector-set! import . \x2E;vector-set!)
       (vector-sort import . core.sorting\x27;vector-sort)
       (vector-sort! import . core.sorting\x27;vector-sort!)
       (vector? import . \x2E;vector?)
       (violation? import . \x2E;violation?)
       (warning-level import . \x2E;warning-level)
       (warning? import . \x2E;warning?)
       (weak-core-hashtable? import . \x2E;weak-core-hashtable?)
       (weak-hashtable? import . \x2E;weak-core-hashtable?)
       (weak-mapping-key import . \x2E;weak-mapping-key)
       (weak-mapping-value import . \x2E;weak-mapping-value)
       (weak-mapping? import . \x2E;weak-mapping?)
       (when import . core.control\x27;when)
       (who-condition? import . \x2E;who-condition?)
       (with-exception-handler import . \x2E;with-exception-handler)
       (with-input-from-file import . core.io\x27;with-input-from-file)
       (with-output-to-file import . core.io\x27;with-output-to-file)
       (with-syntax import . core.syntax-case\x27;with-syntax)
       (write import . \x2E;write)
       (write-char import . \x2E;write-char)
       (write-with-shared-structure import . \x2E;write-with-shared-structure)
       (zero? import . \x2E;zero?)))))

